<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>游戏编程算法和技巧·网络游戏</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-wang-luo-you-xi/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-wang-luo-you-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h1><p>想像寄真实的邮件。我们至少需要一个信封，上面写着这封邮件的寄信地址和手信地址。在信封里面放着的才是你真正需要传递的信息——邮件本身。<strong>数据包</strong>可以想象成是在网络上传输的电子信封。在它的<strong>数据头</strong>中有地址和其他相关信息，然后才发出真正的<strong>数据帧</strong>。</p><p>对于信封来说，地址有较标准的格式。寄信地址在左上角，目的地址在右边中间，而邮票在右上角。这是大多数国家最常见的格式。但是对于网络数据传输，有着很多不同的<strong>协议</strong>或规则来定义数据包以什么格式以及为了发生必须做什么。网络游戏现在通常会让游戏逻辑使用两种协议之一:TCP、UDP。有的游戏会使用第三种协议，ICMP，常用于一些非游戏逻辑的功能。</p><h2 id="1-IP"><a href="#1-IP" class="headerlink" title="1.IP"></a>1.IP</h2><p>IP，全称Internet Protocol(国际网络协议)，要通过网络发送数据，这是需要遵守的最基本的协议。本章提到的每一个协议，不管是ICMP、TCP还是UDP，都必须附加IP协议才能够传输数据。哪怕数据只是在本地网络上传输。这就造就了一个事实，那就是现在所有在本地网络上的机器都需要有一个特定的本地地址，只有这样才能通过IP标识某个特定的本地机器。</p><p>IP的数据头有着大量的字段。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://pw9tlh9pq.bkt.clouddn.com/1.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 IPv4数据头的结构</div></center><p>有两个广泛使用的IP协议版本:IPv4和IPv6。IPv4地址是四个字节被分开用十进制写出，中间用点分隔。所以，举个例子，本地网络地址可能是192.168.1.1。由于IPv4地址是32位的，所以大概有40亿种可能组合，在1977年IPv4第一次出现时，这看起来是非常庞大的地址空间，但是到了今天，却有点不够用了。</p><p>为了解决这个问题，IPv6被开发了出来。它使用128位地址，所以支持惊人的$2^128$的地址空间。IPv6的一个缺点就是它们很难记忆，因为它们的完整形式是用冒号隔开的十六进制数，就像是2001:0db8:85a3:0042:1000:8a2e:0370:7334这样。</p><h2 id="2-ICMP"><a href="#2-ICMP" class="headerlink" title="2.ICMP"></a>2.ICMP</h2><p>ICMP，全称Internet Control Messaging Protocol(国际网络控制消息协议)，并不用于在网络上传输大量数据。因此，它不能用于发送游戏数据。但ICMP具有发送<strong>回声</strong>包的能力。通过ICMP，可以发送数据包给特定地址，然后直接让数据包返回给发送者，这是通过ICMP的回声请求和回声响应机制完成的。这个回声功能可以用于策测量两台计算机之间发包所需要的时间。</p><p>行程往返的时间，就是<strong>延迟</strong>，在玩家有多台服务器可以选择连接的时候特别有用。在游戏测量所有可以连接的服务器的延迟之后，就可以选择连接延迟最低的服务器。这个测量某个地址的延迟的过程称为ping。</p><p>当回声请求发送之后，接收者收到数据包接着以正确的回声包回传回去。由于ICMP数据头没有任何的时间戳信息，在发出回声请求之前，发送者需要自己决定当前的时间戳，然后记录到数据帧里面。当回声应答的数据帧返回之后，发送和接收的时间戳的差别就可以计算出来，这样就能得到往返时间。这个过程通常会重复很多次，这样就可以得到平均延迟。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://pw9tlh9pq.bkt.clouddn.com/2.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 ICMP回声请求数据包的结构</div></center><p>ICMP数据包中的校验和被用来确保数据包在传输的过程中不会有数据出错，校验和的值是用ICMP数据头和数据帧计算出来的。如果接收者收到ICMP数据包，但是校验和不正确，这个包会被拒绝。因为校验和是基于数据包中的所有其他数据计算得出的，所以在数据包传输之前一定要计算好。标识符和顺序号有回声请求指定——通常每台机器的标识符都不一样，而顺序号应该随着每次发送新的回声请求的时候递增。</p><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h2><p><strong>传输控制协议</strong>(TCP)是游戏在网络上用来传输数据最常用的两个协议之一。TCP是一个基于连接的、可靠的、保证顺序的协议。</p><p>TCP是基于连接的，就是说两台计算机在任何数据传输之前，必须先建立好彼此的连接。连接完成的方法是通过握手。请求连接的计算机发送一个连接请求到目标计算机，告诉它自己想要如何连接，然后接收者确认这个请求，这个确认在被最初的请求者再次确认之后，三次握手的过程就完成了。</p><p>一旦在TCP连接建立之后，就可以在两台计算机之间传输数据。之前提到，所有通过TCP发送的数据包都是可靠的。可靠的工作原理就是在每当数据包通过TCP发送之后，接收者都会告诉发送者我收到数据包。如果发送者在一定时间之内(超时)没有收到应答，就会将数据包再发送一次，发送者会不断地发送数据包，直到收到应答为止。</p><p>结果就是TCP不仅保证所有数据包的接收时可按扣的，还会保证它们的顺序。如果发生<strong>数据包丢失</strong>等情况，会大大减慢数据的传输。对于游戏来说，保证顺序很容易成为不必要的瓶颈。</p><p>还有一个TCP需要考虑的有用的方面。所有网络都有MTC，或者maximum transmission unit(最大传输单元)，它会决定数据包的大小限制。如果你尝试发送大于MTU的数据包，它会没法通过。幸运的是，TCP在设计上会由操作系统自动将大的数据块分成合适大小的数据包。所以如果你需要从网站上下载1MB的文件，如果使用了TCP，那么分解为合适大小的数据包以及保证接收顺序的事情，程序员就不用操心了。</p><p>在大多数场景中，通常不需要在游戏中传输那么大量的数据。但是还是会有用到的情况，比如说，如果游戏支持自定义地图，就会有一个问题，那就是新玩家试图加入游戏会话的时候是没有这张自定义地图的。通过TCP，就可以轻松地将自定义地图发送给试图进入游戏的新玩家，而且不用管地图的大小。</p><p>也就是说，对于真正的游戏逻辑来说，只有小部分游戏类型需要用到TCP。对于回合制游戏，使用TCP是有意义的，因为通过网络发送的所有信息都是相关的，它定义了某个回合中玩家执行的动作。另一个常用TCP的游戏类型是MMO，特别是《魔兽世界》，它的所有数据都用TCP传送。</p><p>由于TCP是一个相当复杂的协议，TCP数据头跟IP数据头一样大(20字节)。<strong>端口</strong>是一个非常重要的概念。在数据包经过网络发送之后，相同的排序方式也被应用于端口。比如说，大多数Web服务器在80端口接收连接。总共有大约65000个端口可以选择，虽然有的已经被指定使用，但是大多数系统都会有大量的端口空闲着。游戏应该选用一个没有被其他程序使用的端口。。要注意的是，源端口和目标端口不一定是一致的，也就是说，虽然Web服务器连接建立在80端口，但是客户端连接服务器可以使用不同的端口。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://pw9tlh9pq.bkt.clouddn.com/3.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 TCP数据头的结构</div></center><h2 id="4-UDP"><a href="#4-UDP" class="headerlink" title="4.UDP"></a>4.UDP</h2><p><strong>数据包协议</strong>(UDP)是一种无连接、不可靠的协议，就是说你可以直接发UDP数据包，而不需要与指定目标建立连接。由于它是一个不可靠协议，所以不会有保证数据包到达的手段，也不会保证数据包到达的顺序，也没有接收者应答的功能。由于UDP是一种更加简单的协议，数据头比TCP要小得多。</p><p>像TCP一样，UDP也支持大约65000个端口。UDP端口和TCP端口是独立的，所以如果TCP和UDP使用同一个端口是不会冲突的。由于UDP是不可靠的，它的传输比TCP要高效得多。但是由于不知道数据包是否到达，也会造成一些问题。虽然有些数据不太重要，但还是会有一些重要的保证游戏状态一致的数据。如果玩多人FPS游戏，你反射了子弹，这个信息就很重要，要保证它被服务器或者其他玩家所接收。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://pw9tlh9pq.bkt.clouddn.com/4.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 UDP数据头的结构</div></center><p>一个尝试的解决方案就是将TCP用于关键数据，使用UDP传输不太重要的数据。但是INET 97 proceedings paper指出，在TCP保证系统运行的同时，使用UDP会导致UDP丢包增加。一个更严重的问题是：虽然移动数据不是那么重要，用UDP传送很合理，但我们还是需要数据包的顺序。</p><p>大多数游戏处理这个问题都是使用UDP，然后在所需的数据包里增加一些自定义的可靠层来完成。这个额外的层在UDP数据段的开始位置添加——可以认为是自定义的协议数据头。最基本的可靠性数据是<strong>顺序号</strong>，可以跟踪哪个数据包号是哪个，然后通过设置位域莱英达。通过使用位域，某个数据包可以同时应答多个数据包，而不需要每个数据包都应答一次。这个系统同时还有灵活性，就是如果某个系统不需要可靠性和顺序信息，那么可以不添加数据头直接发送。</p><p>就行之前所提到的，UDP在实时游戏领域中是占主导地位的协议。几乎所有FPS、动作类、RTS以及其他网络游戏中对时间敏感的信息都会使用UDP。这也是为什么几乎所有为游戏设计的网络中间件(比如RakNet)只支持UDP。</p><h1 id="二、网络拓扑"><a href="#二、网络拓扑" class="headerlink" title="二、网络拓扑"></a>二、网络拓扑</h1><p>拓扑决定了不同的计算机在网络游戏会话中是如何相互连接的。虽然配置上有很多种不同的方式，但大多数游戏都支持一种或两种模型：服务器/客户端或是点对点。对于很多情况，两种方法各有优劣。</p><h2 id="1-服务器-客户端"><a href="#1-服务器-客户端" class="headerlink" title="1.服务器/客户端"></a>1.服务器/客户端</h2><p>在<strong>服务端/客户端</strong>模型中，有一个中心计算机(也就是<strong>服务器</strong>)，所有的其他计算机(也就是<strong>客户端</strong>)都会与之通信。因为服务器与每一台客户端通信，所以在这个模型中，会需要一台有着比客户端更高带宽和处理能力的机器。比如说，如果客户端发送10Kps数据，在8人游戏中，意味着服务器需要接收80Kps的数据。这类模型通常也叫作中心型结构，因为服务器是所有客户端的中心节点。</p><p>服务器/客户端模型是今天最流行的网络游戏拓扑结构。大多数FPS、动作游戏、MMO、策略游戏、回合制游戏等都使用服务器/客户端模型。</p><p>在常见的服务器/客户端模型的视线中，服务器会被认为是<strong>权威的</strong>，就是说它需要验证大多数客户端行为。假设网络游戏允许玩家向另一名玩家投掷闪避球，在另一名玩家被闪避球打中之后，投掷的玩家会得分。在权威服务器中，当玩家想投掷闪避球的时候，会先向服务器发起请求，服务器会检查是否是一个合法动作。然后服务器会模拟闪避球的弹道，在每一帧检查这个球是否与某个客户端发生碰撞。如果客户端被击中，服务器会通知客户端被打败。</p><p>服务器验证的理由有两个。第一个理由就是服务器会拥有所有客户端的最新位置信息。一个客户端投出闪避球，可能会认为自己投中了，但这可能是因为当时位置不是最新的。而如果客户端能够用闪避球淘汰其他玩家而无须经过服务器验证的话，就很容易有外挂程序作弊淘汰其他玩家。</p><p>因为服务器需要认证，服务器/客户端模型的游戏逻辑实现起来就比单人游戏更加复杂。在单人游戏中，如果用空格键发射导弹，相同的代码会检测空格键可以创建和发射导弹。但是在服务器/客户端游戏中，空格键代码必须创建发射请求数据包到服务器，然后服务器通知所有其他玩家导弹的存在。</p><p>因为这是两种完全不同的方法，对于想要实现两种模式(多人与单人)的游戏来说，最好的方法就是将单人模式当作特殊的多人模式。这在许多游戏引擎中是默认的实现方式，包括id Software引擎。就是说单人模式实际上是将服务器和客户端都放在一台机器上运行。将单人模式看作多人模式的一种特例的优点在于，只需要一套逻辑代码。否则，网络程序员要在权威服务器的游戏逻辑开发上花很多时间。</p><p>我们回到闪避球的例子，相像以下如果玩家可以选择目标。就是说，他们需要用一些方法来知道对手玩家的运动方向才能够预判出成功的投掷。在最好的情况下，客户端可以以四分之一秒一次地收到服务器下发的对手玩家的位置更新数据。现在相像如果客户端只在收到服务器数据的时候才更新对手未知，就是说每隔四份之一秒，对手玩家都会上传新的位置，而对手位置总是闪来闪去，当然听上去游戏似乎不太好玩。</p><p>为了解决这个问题，大多数游戏都会实现某种<strong>客户端预测</strong>，也就是客户端会在两次服务器下发数据之间猜测中间的过渡情况。在移动的例子中，如果服务器在下发对手玩家的速度的同时一起下发位置，那么客户端预测就可以工作。然后，在服务器更新的几帧里，客户端可以根据最后收到的速度和位置，推算对手玩家的速度。</p><p>只要更新足够频繁，客户端就能让对手玩家在所有时刻都有足够准确的表现。但是，如果由于连接问题导致更新不够频繁，客户端预测就会变得不准确。由于服务器是最权威的存在，客户端必须修复预测位置与真实位置之间的差异。</p><p>在任何事件中，为了防止主机带来的问题，许多服务器/客户端游戏只支持<strong>专用服务器</strong>。在大多数例子下，这意味着服务器都是安装在一个特别的位置的(通常在数据中心)，而所有玩家都需要连接到这些服务器(没有玩家可以做主机)。虽然网速快的玩家还是比网速慢的玩家有优势，但是通过这种将服务器放在第三方的方法使得这种优势会大大减弱。可是，运行专用服务器的缺点就是部署得越多，费用就越高。</p><h2 id="2-点对点"><a href="#2-点对点" class="headerlink" title="2.点对点"></a>2.点对点</h2><p>在<strong>点对点</strong>模型中，每个客户端都连接到其他客户端。这意味着对于多有客户端都要求同样的性能和带宽。由于点对点模型中没有中心的权威服务器，会有很多种可能：每个客户端只认证自己的动作，或者每个客户端都认证其他客户端，又或者每个客户端都模拟整个世界。</p><p>RTS类型中经常会用到点对点模型。正式一点的名称为<strong>帧同步</strong>模型，就是网络更新被分为每次150ms到200ms的回合更新。每当执行一次输入动作，这个命令都会保存到队列里，在每轮结束的时候执行。</p><p>因为输入命令通过网络传递，RTS游戏中的每个客户端实际上是在模拟所有单位。它们像本地玩家一样处理输入。这样使得记录下所有对手的指令并在游戏结束后查看即时回放成为可能。</p><p>客户端的帧同步方法会使所有客户端都紧密地同步，没有任何玩家能够比其他玩家先走。当然，这种同步方式的缺点就是——如果一个客户端开始延迟，其他客户端都要等待，一直到这个玩家赶上去。但是帧同步方法在RTS游戏里面非常流行，因为它通过网络传输的数据相对来讲会更少。比起发送所有单位的信息，游戏只在每分钟发生相对小数量的动作，即使是最好的RTS玩家每分钟最多也就发送300-400次指令。</p><p>因为在点对点配置中，每个点都要模拟游戏世界的一部分，游戏状态必须保证100%的确定。这使得基于变化的游戏逻辑不太好做。</p><h1 id="三、作弊"><a href="#三、作弊" class="headerlink" title="三、作弊"></a>三、作弊</h1><p>任何网络游戏主要考虑的一点就是要为玩家打造公平的游戏环境。但不幸的是，有的玩家为了胜利会不择手段，哪怕打破游戏的规则。在网络多人游戏中，有很多规则都有可能会被打破，所以不管是否可能，网络游戏需要防止玩家作弊。</p><h2 id="1-信息作弊"><a href="#1-信息作弊" class="headerlink" title="1.信息作弊"></a>1.信息作弊</h2><p><strong>信息作弊</strong>是一种让玩家获得本不该拥有的额外信息的手段。比如FPS游戏中常见的透视挂。</p><p>最简单的方法就是通过限制信息来防止信息作弊。但是有的时候这个方案不是那么简单。比如说，在RTS游戏中有一种常见啊的作弊称为图挂。就是让玩家可以看到整张地图，包括所有对手玩家的任何操作。</p><p>不幸的是，在图挂的例子中，不能够限制信息的发送，因为这会影响帧同步模型的工作。因为每个点都会模拟整个游戏世界，它必须在所有时间都知道敌人单位的位置，所以这种情况下唯一的方法就是建立反外挂对策。在《星级争霸2》中，暴雪就运行了Warden外挂检测程序，它会在游戏运行的时候，检测是否有其他外挂程序在运行。</p><p>这就是外挂制作者和游戏开发公司的一场战争，在任何事件下，开发公平竞技网络游戏的公司都需要对作弊保持高度警惕。</p><h2 id="2-游戏状态作弊"><a href="#2-游戏状态作弊" class="headerlink" title="2.游戏状态作弊"></a>2.游戏状态作弊</h2><p>信息作弊能够让玩家获得不对称的优势，而<strong>游戏状态作弊</strong>则可以完全破坏游戏。一旦玩家可以修改游戏状态，玩家很快就能让游戏变得不可玩。常见于游戏作为主机的时候，如果玩家控制了服务器，就很难阻止玩家作弊。</p><h2 id="3-中间人攻击"><a href="#3-中间人攻击" class="headerlink" title="3.中间人攻击"></a>3.中间人攻击</h2><p>影响最坏的一种作弊就是在两台通信机器之间设立一台机器，用于拦截所有数据包。这种称为<strong>中间人攻击</strong>，在通过网络发送明文消息的时候特别容易被人篡改。这种攻击是为什么应该使用HTTPS而不是HTTP的主要原因。</p><p>使用HTTP，所有数据都以明文的方式通过网络发送。就是说，如果在网站上你用HTTP提交你的用户名和密码，容易遇到中间人窃取信息。而通过HTTPS，所有数据都是加密的，这使得中间人几乎不可能访问到这些信息。</p><p>但是，在游戏的情况下，中间人攻击最大的优点在于它允许作弊发生在不需要玩游戏的机器。这就是说几乎所有的外挂检测程序都不起作业——它们根本就不知道数据包被拦截而且被篡改了。还有一个问题就是，一般通过访问数据包信息可能允许黑客更加深入地发掘其他能够渗透游戏的漏洞。</p><p>一种防止这类攻击的方法就是对所有数据包进行加密，这样只有服务器才能解密并理解数据包。但这对于大多数游戏消息来说都过重了，对所有信息加密实际上增加了符合。但至少，我们可以在玩家登陆的时候进行一次加密，通过某种加密算法来有效避免玩家账号被盗。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·脚本语言和数据格式</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-jiao-ben-yu-yan-he-shu-ju-ge-shi/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-jiao-ben-yu-yan-he-shu-ju-ge-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、脚本语言"><a href="#一、脚本语言" class="headerlink" title="一、脚本语言"></a>一、脚本语言</h1><p>多年前，游戏全部使用汇编语言开发。这是因为早期的机器需要汇编级别的优化才能运行。但是随着计算能力的提升，而游戏又变得很复杂，使用汇编开发就变得越来越没意义了。直到某一天，使用汇编语言开发游戏带来的优点被完全抵消了，这就是为什么现在的所有游戏引擎都使用像C++那样的高级语言开发。</p><p>同样，随着计算机性能的提升，越来越多的游戏逻辑开始从C++或者类似的语言转移。现在许多游戏逻辑使用<strong>脚本语言</strong>开发，常用的脚本语言有Lua、Python、UnrealScript等。</p><h2 id="1-折中"><a href="#1-折中" class="headerlink" title="1.折中"></a>1.折中</h2><p>脚本语言并不是万灵药，在使用之前必须考虑很多折中。第一个要考虑的就是脚本语言的性能远不如编译型语言，比如C++。即使比起JIT或者基于VM的语言，比如Java、C#，那些脚本语言，比如Lua、Python，在性能上都不具备可比性。这是因为<strong>解释型</strong> 语言按需加载文本，而不是提前编译好。多数脚本语言都提供了编译为中间格式的选项。虽然始终达不到编译型语言的速度，但还是会比解释型语言要快。</p><p>由于这个性能差异的存在，性能敏感的代码不应该使用脚本语言开发。以AI系统为例，寻路算法(比如A*)应该是高效的，因此不应该用脚本开发。但是由状态机驱动的AI行为应该完全用脚本开发，因为那不需要复杂的计算。</p><p>使用脚本语言的巨大优势就是使得开发时迭代更加快速。假设某个游戏的AI状态机必须以C++开发。在玩游戏的过程中，AI程序员发现某个敌人的行为不正确。如果状态机使用C++开发，这意味着通常程序员必须暂停游戏，修改代码，重新生成可执行文件，重新开始游戏，最后才能看到问题是否解决。</p><p>但是同样的场景如果出现在AI状态机是用脚本语言开发的时候，就可以动态重新加载脚本，然后在游戏仍在运行的时候就把问题解决的。运动中动态加载脚本的能力可以很大程度地提升生产力。</p><p>另外，如果使用C++开发，假设有访问野指针引起的bug，那么通常都会引发崩溃。但是如果状态机是使用脚本语言开发的，那可能只会让某个特定AI的角色行动不正常，而游戏的其他部分都是正常的。第二种情况要比第一种友好得多。</p><p>进一步来讲，由于脚本与可执行文件是分开的文件，使得提交工作更加简单。在大型项目中，生成可执行文件需要好几分钟，而且最终文件可能会有100MB。这意味着如果有新版本，需要的人要下载整个文件。但是，如果使用了脚本语言，用户只要下载几KB的文件就可以了，这样会快得多。这不仅对发售后更新补丁非常有帮助，在开发中也同样有用。</p><p>由于生产力的优势，一个最好的经验法则就是，只要系统不是性能敏感的，都能从脚本语言中受益。</p><h2 id="2-脚本语言的类型"><a href="#2-脚本语言的类型" class="headerlink" title="2.脚本语言的类型"></a>2.脚本语言的类型</h2><p>那么该使用哪个脚本语言呢？有两方面需要考虑：使用现有的，比如Lua、Python，还是使用自己开发的。一些自己开发的脚本语言有UnrealScript和QuakeC。</p><p>使用现有脚本语言的优势就是可减少很多工作量，因为编写脚本语言解释器非常花时间而且容易出错。</p><p>另一个要考虑的脚本语言开发的事情就是需要设计者深入了解编译器和虚拟机知识——比大多数游戏开发的话题还要多得多。</p><p>但是现有的脚本语言的缺点就是不能与游戏结合得非常好。既有语言设计上的内存和性能问题上的顾虑，也有桥接脚本语言和引擎之间的问题。而自定义的脚本语言是为游戏大量优化过的——这些语言的功能是面向游戏的，比如UnrealScript。</p><p><strong>Lua</strong></p><p>Lua是一门通用脚本语言，大概是现在游戏领域最流行的脚本语言。使用Lua的游戏的例子包括:《魔兽世界》、《英雄连》、《冥界狂想曲》等。Lua这么流行的一个原因是它的解释器非常轻量——纯C实现大概占用内存150KB。另外一个原因就是它非常容易做<strong>绑定</strong>，也就是在Lua中调用C/C++代码的能力。它同时支持多任务，所以它可以让许多Lua函数同时运行。</p><p><strong>UnrealScript</strong></p><p>UnrealScript是Epic为Unreal引擎专门设计的严格的面向对象语言。不像很多脚本语言，UnrealScript是编译型的。由于是编译型的，它有着比脚本语言更好的性能，但也意味着不支持在运行时重新加载。</p><p>在语法上，UnrealScript看上去非常像C++或者Java。因为它是严格面向对象的，每个类都继承自Object或者Object的子类，而几乎每个类都表示场景中派生自Actor的一个角色。UnrealScript非常特别的功能是内建对状态的支持。可以根据状态有不同的函数重载，这样对于AI行为会更加容易设置。</p><h2 id="3-可视化脚本系统"><a href="#3-可视化脚本系统" class="headerlink" title="3.可视化脚本系统"></a>3.可视化脚本系统</h2><p>越来越多的游戏引擎支持<strong>可视化脚本系统</strong>，它看上去就像流程图。这些系统通常用于设置关卡逻辑。比如Unreal中的BluePrint。</p><h1 id="二、实现一门脚本语言"><a href="#二、实现一门脚本语言" class="headerlink" title="二、实现一门脚本语言"></a>二、实现一门脚本语言</h1><p>虽然一门脚本语言的完整实现很困难，而且也超出了本文的范畴，但是讨论那些必要的核心概念还是很有价值的。这样不仅能知道问题的复杂程度，还能提供入门指导。</p><h2 id="1-标记化"><a href="#1-标记化" class="headerlink" title="1.标记化"></a>1.标记化</h2><p>我们要做的第一步就是将代码文本加载进来，然后分成一块块的<strong>标记</strong>，比如标识符、关键词、操作符和符号。这个过程被称为<strong>标记化</strong>，更正式一点叫做<strong>词法分析</strong>。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/28/52LqlYfpvmz1Ek7.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 C语言的标记化</div></center><p>虽然手写标记器(也叫扫描器或者词法分析器)是完全可行的，但这不是推荐的做法。这样的代码写出来容易出错，因为有很多需要处理的情况。比如说，C++的标记器需要知道下面这些哪个才是真正的new关键词:</p><pre><code>newnew_newnew_new_new_new</code></pre><p>比起手写标记器，更倾向于与使用像flex这样的工具，它会自动为你生成标记器。flex的工作方式需要你指定一系列匹配规则，称之为<strong>正则表达式</strong>，然后声明哪些正则表达式匹配哪些标记。它会自动生成代码(用flex的话，会生成C代码)，可以用来根据给定的规则开始标记化。</p><h2 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2.正则表达式"></a>2.正则表达式</h2><p>正则表达式(也叫regex)在标记化之外还有很多用途。比如说，大多数IDE支持在多个文件之间使用正则表达式查找，这样可以找到那些特殊的序列。虽然正则表达式可以很复杂，但是脚本语言用到的模式匹配只用到正则表达式很小的一个子集。</p><p>最基本的正则表达式用于匹配关键词，也就是说每个字母必须一样。为了完成匹配，正则表达式只是带括号或者不带括号的一串字符:</p><pre><code>//匹配新关键词new//同样匹配新关键词"new"</code></pre><p>在一段正则表达式中，还会有特殊含义的操作符。[]操作符表示在其中的所有字母都会匹配。它还可以通过连字符表达区间，以下是一些例子:</p><pre><code>//匹配aac、abc或acca[abc]c//匹配aac、abc、acc...azca[a-z]c//可以组合多种范围//匹配aac、abc...azc、aAc...aZca[a-zA-Z]c</code></pre><p>操作符+表示“一个或者多个特定字母”，而操作符*表示“零个或者多个特定字母”。这些可以通过[]操作符组合起来，这样就可以匹配某种语言的大多数标记。</p><pre><code>//匹配一个或者多个数字(整型标记)[0-9]+//匹配单个字母或者下划线，后接零个或者多个字母、数字和下划线[a-zA-Z_][a-zA-Z0-9_]*</code></pre><p>在任何情况下，一旦一系列的标记和正则表达式对应起来，这些数据就可以提供给像flex这样的程序来生成标记器。一旦脚本语言传递给标记器，被分析为标记之后，就可以继续下一步了。</p><h2 id="3-语法分析"><a href="#3-语法分析" class="headerlink" title="3.语法分析"></a>3.语法分析</h2><p><strong>语法分析</strong>的任务就是遍历所有标记，然后确保它们符合语法规则。比如说，if表达式需要有适当数目和位置的括号、大括号、测试表达式和表达式来执行。在检测脚本语法的过程中，会生成<strong>抽象语法树</strong>(AST)，它是基于树的数据结构，定义了整个程序的布局。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/28/IrxcUJagOfCzpsu.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 5 + 6 * 10的AST</div></center><p>注意，此图中的树以后序遍历(左孩子、右孩子、父节点)的方式遍历的，结果会是5 6 10 * +，这个结果就是中序表达式以后续表达式的方式表示的结果。这不是随意决定的，后序遍历在栈上计算非常方便。最后，所有AST(不管是否是数学表达式)再语法分析之后都会被以后序的方式遍历。</p><p>在遍历AST之前，我们必须先生成一份AST。生成AST的第一步就是定义一份语法。计算机语言定义语法的经典方式就是通过<strong>巴科斯范式</strong>，一般缩写为BNF。BNF的设计是相对简洁的。能够做整形加法和减法的运算子语法可以像下面这样定义:</p><pre><code>&lt;integer&gt;   ::== [0-9]+&lt;expression&gt; ::== &lt;expression&gt; "+" &lt;expression&gt; | &lt;expression&gt; "-" &lt;expression&gt; | &lt;integer&gt;</code></pre><p>这个::==操作符表示“定义为”，|操作符表示“或者”，&lt;&gt;操作符用于表示语法规则的名字。所以上面的BNF语法的意思是，expression要么是expression加另一个expression，要么是expression减另一个expression，要么是一个integer。</p><p>就像标记化一样，语法分析也有可以使用的工具。其中之一就是bison，它可以在语法规则匹配的时候执行C/C++动作。动作的一般用法就是让它读取AST的时候创建合适的节点。</p><p>最好能有一个类能对应一种类型的节点，所以加/减语法会需要4种不同的类：一个抽象的表达式类、一个整型节点、一个加法节点和一个减法节点。</p><h2 id="4-代码的执行和生成"><a href="#4-代码的执行和生成" class="headerlink" title="4.代码的执行和生成"></a>4.代码的执行和生成</h2><p>仅从脚本文件到AST生成之后，有两个可选方案，两种都需要以后序遍历的方式遍历AST。对于传统一些的编译器，遍历AST的目标就是生成能够在目标机器上运行的代码。所以当C++编译的时候，会遍历AST，然后生成能够在目标平台上运行的汇编代码。</p><p>如果游戏脚本是编译型的，比如UnrealScript，它生成代码是非常有意义的。但是如果语言是解释型的，代码生成就不是必需的。换言之，遍历AST然后执行节点表示的动作会是更好的方案。</p><p>对于加法/减法的粒子，节点可以像下面这样定义:</p><pre><code>abstract class Expression    function Execute()endclass Integer inherits Expression    //存储整数    int value    //构造函数    ...    function Execute()        //将结果压到运算符的栈顶        ...    endendclass Addition inherits Expression    //左右操作数    Expression lhs, rhs    //构造函数    ...    function Execute()        //后续表示先访问左孩子，然后右孩子，最后到自己        lhs.Execute()        rhs.Execute()        //将栈顶的两个值相加，再将结果压到栈里        ...    endend</code></pre><h1 id="三、数据格式"><a href="#三、数据格式" class="headerlink" title="三、数据格式"></a>三、数据格式</h1><p>另外一个游戏开发中要做的决定就是如何通过数据描述像关卡、游戏属性等游戏元素。对于非常简单的游戏来说，可以直接将数据硬编码，但这不是一个理想的解决方案。通过将数据存储在外部文件，就可以让非程序员来编辑。同时还使得创建编辑工具(比如关卡编辑器)来处理数据变得可能。</p><p>当你确定数据格式的时候，第一个要决定的就是数据是二进制格式还是文本格式。一个<strong>二进制</strong>文件通常都不具备可读性。如果你用文本编辑器打开二进制文件，可以看到一大串乱码。一个<strong>文本</strong>文件，通常会用ASCII码表示，因此具备可读性。就像判断是否使用脚本语言一样，两种方法之间有一种折中。最后，有的情况用文本格式合理，而有的情况用二进制格式合理。</p><h2 id="1-折中-1"><a href="#1-折中-1" class="headerlink" title="1.折中"></a>1.折中</h2><p>使用二进制文件的第一个优点是体积更小，加载更快。比起花费时间解析文本并转换到内存格式，通常可以直接把整块加载到内存，而不需要任何转换。因为对于游戏来说，效率是非常重要的，所以对于携带大量信息的文件来说，通常都会采用二进制格式。</p><p>但是，效率的提升不是没有代价的。二进制文件的一大缺点就是很难分辨出两个二进制文件到底有什么不同。</p><p>对于文本格式而言，查看两个版本的不同就非常容易了。同时也说明了一个事实，那就是文本文件对于最终用户的编辑来说是相对容易的。比如键盘输入的配置文件，采用文本格式会更好，因为使用标准的文本编辑器就能很容易地进行编辑。但在另一方面，这对于关卡数据不一定是优点，因为这会让玩家很容易就修改数据，然后将其破解。</p><p>还有最后一个方案，对于数据文本和二进制表达式都适用。在开发的时候，检查变动是很重要的，所以所有关卡和游戏数据都可以存成文本。然后，在发布的时候，我们可以加入一个<strong>烘焙</strong>步骤，将所有文本格式转换为二进制格式。这样，我们在开发的时候就能够得到文本格式带来的便利，同时又能在发布的时候获得二进制格式的优点。</p><h2 id="2-二进制格式"><a href="#2-二进制格式" class="headerlink" title="2.二进制格式"></a>2.二进制格式</h2><p>对于存储游戏数据来说，二进制格式通常都没有自定义格式。这是因为有很多方式存储数据，这些很大程度上取决于语言和框架。如果是C++游戏，有时候最简单的方法就是将类的数据直接输出到外部文件，这个过程被称为<strong>序列化</strong>。但是有一些问题需要考虑，比如说，任何类中的动态数据都以指针形式存在，你需要执行深拷贝，然后重新构造数据。</p><h2 id="3-INI"><a href="#3-INI" class="headerlink" title="3.INI"></a>3.INI</h2><p>最简单的文本格式就是<strong>INI</strong>，经常在用户需要改配置的时候使用。INI文件是分为几节的，而每一节有一系列的键和值。比如说，INI文件的图形设置可能会是这样的：</p><pre><code>[Graphics]Width=1680Height=1050FullScreen=trueVsync=false</code></pre><p>虽然对于简单数据来讲，INI能工作得很好，但是对于复杂的数据而言就显得有些笨重。这对于关卡这种有布局的数据结构而言不太适合。比如说，INI不支持嵌套的参数和节。</p><p>由于INI简单而且使用广泛，所以有着大量容易使用的库可供选择。比如C/C++的库minIni</p><h2 id="4-XML"><a href="#4-XML" class="headerlink" title="4.XML"></a>4.XML</h2><p>XML,全称Extensible Markup Language，是一种HTML概念扩展出来的文件格式。比起使用HTML标签，如、的名号，在XML中，你可以使用任意自定义的标签和属性。比如说，下面是某一项，其存储了某个剑的状态:</p><pre><code>&lt;ability name="Forgotten Sword of Vrane _Stats"&gt;    &lt;damage_min mult="false" always_random="false" min="50" max="50"/&gt;    &lt;damage_max mult="false" always_random="false" min="55" max="55"/&gt;    &lt;endurance mult="false" always_random="false" min="1" max="1"/&gt;    &lt;crt_freeze display_perc="true" mult="false" always_random="false" min="0.2" max="0.2" type="critical"/&gt;    &lt;instant_kill_chance display_perc="true" mult="false" always_random="false" min="0.02" max="0.02" type="bonus"&gt;    &lt;vitality_regen mult="false" always_random="false" min="2" max="2"&gt;&lt;/ability&gt;</code></pre><p>关于XML的一个批评就是需要很多额外的字符来表示数据。有很多&lt;和&gt;符号，而且总是需要用名字和引号等修饰每个参数，总是需要确保有配对的标签，所有的组合导致文件比较大。</p><p>但是XML的一大优势就是可以使用<strong>模式</strong>，就是强制要求哪些字段是必须要有的。这就是说，很容易验证XML文件和确保它声明了必要的参数。</p><p>像其他常见文件格式一样，有很多解析器都支持XML。用于C/C++最流行的解析器毫无疑问就是TinyXML(C++会附带ticpp)。一些语言会有内建的XML解析。比如，C#有System.Xml命名空间用于处理XML文件。</p><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5.JSON"></a>5.JSON</h2><p>JSON，全称JavaScript Object Notation，比起INI和XML这种新型的文件格式，JSON在近几年非常流行。虽然JSON在互联网交换数据中应用比较多，但在游戏中用于轻量级数据格式也是可以的。有大量的第三方库可以解析JSON，包括C++的libjson和C#的JSON.NET。</p><p>根据存储数据的类型，JSON可能与XML相比速度更快、体积更小。但也不总是这样，比如说，如果我们将《巫师2》中剑的数据以JSON文件表示，通常回比XML版本要大:</p><pre><code>"ability":{    "name":"Forgotten Sword of Vrane _Stats",    "damage_min":{        "mult":false,"always_random":false,"min":50, "max":50    },    "damage_max":{        "mult":false,"always_random":false,"min":55, "max":55    },    "endurance":{        "mult":false,"always_random":false,"min":1, "max":1    },    "crt_freeze":{        "display_perc":true,"mult":false,"always_random":false,"min":0.2, "max":0.2, "type":"critical"    },    "instant_kill_chance":{        "display_perc":true,"mult":false,"always_random":false,"min":0.2, "max":0.2, "type":"bonus"    },    "vitality_regen":{        "mult":false,"always_random":false,"min":2, "max":2    },}</code></pre><p>哪怕你对JSON和XML都减少多余的空格和回车，在一些特殊的例子里，JSON文件还是会比XML要稍稍大一些。所以虽然JSON在大多数情况下是好用的文本格式文件，但是在《巫师2》的例子中，开发者做出了正确的选择，使用XML。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·用户界面</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-yong-hu-jie-mian/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-yong-hu-jie-mian/</url>
      
        <content type="html"><![CDATA[<p>一个游戏的用户界面通常有两个主要部分:一个是菜单系统，一个是平视显示器(HUD)。菜单系统决定玩家如何进入和退出游戏，包括改变模式、暂停游戏、选择选项等。一些游戏(特别是RPG)都会有菜单系统来展示和升级技能。</p><p>HUD包括了展示玩家游戏中额外信息的元素。通常包括雷达、子弹数量、指南针和准心。虽然不是所有游戏都有HUD(而一些游戏则有隐藏HUD的选项)，但是大多数都会有至少一个。</p><h1 id="一、菜单系统"><a href="#一、菜单系统" class="headerlink" title="一、菜单系统"></a>一、菜单系统</h1><p>一个实现良好的菜单系统应该能够提供很多不同方面的灵活性。与此同时，它又必须集成尽可能多的功能。</p><h2 id="1-菜单栈"><a href="#1-菜单栈" class="headerlink" title="1.菜单栈"></a>1.菜单栈</h2><p>典型家用机游戏的菜单系统都以“点击开始”作为开始阶码。在用户按键之后，就会进入主菜单界面。也许还可以通过点击选项进入选项界面。通常来讲，玩家都能够退出当前菜单然后返回之前的界面。</p><p>一个确保菜单总能回退到基本界面的方法就是使用栈这种数据结构。栈最上层的元素就是当前活跃的菜单，而打开新菜单就是往栈中压入新的菜单。回退到之前的菜单就是将当前的菜单弹出栈。这个机制还可以改进为支持多个菜单同时可见。比如说，如果需要接受/拒绝某个请求，一个弹出框可以在某个菜单之前。为了达到目标。菜单系统需要对栈的底部到顶部全部引用。</p><h2 id="2，按钮"><a href="#2，按钮" class="headerlink" title="2，按钮"></a>2，按钮</h2><p>几乎所有菜单系统都有玩家可以交互的按钮。一般按钮都有两种状态:未选中和选中。</p><p>如果菜单只能通过键盘或者手柄控制，按钮的支持就相当直观。一个菜单界面可以用双向链表的形式来组织按钮，很容易前进和后退，而且如果过了最后一个按钮也很容易回到第一个按钮。</p><p>通常在按钮按下的时候，用户会期待发生一些事情。一个足够抽象的支持方式就是让按钮拥有一个函数成员变量。当创建新按钮的时候，可以为它分配正确的函数，使能够在按钮按下的时候得到执行。</p><p>如果游戏也支持通过鼠标导航，系统就会增加一定的复杂度。每个按钮需要有一个<strong>感应区</strong>，或者用一个2D包围盒表示按钮可点击区域。所以随着用户鼠标在菜单中移动，需要检测鼠标是否进入某个按钮的感应区。</p><p>允许玩家在鼠标导航和键盘导航之间切换也是可以的。一个常见的方式就是当用户按下键盘的时候隐藏鼠标(同时也忽略鼠标位置)。然后，如果鼠标移动，鼠标的选择模式被再次激活。</p><h2 id="3-打字"><a href="#3-打字" class="headerlink" title="3.打字"></a>3.打字</h2><p>计算机游戏中最常见的菜单功能就是让用户在其中输入一到两个单词。传统的应用程序支持打字的方法通常是通过标准输入，但是标准输入不适合游戏。</p><p>允许输入的第一步就是准备一个空字符串。每次玩家输入一个字母，我们就可以将字母拼接到字符串后面。可以通过虚拟键盘将键盘上的每个键和枚举值对应起来。比如说，K_A对应A键，K_Z对应Z键。</p><pre><code>function KeyCodeToChar(int keyCode)    //确保这是子母键    if keyCode &gt;= K_A &amp;&amp; keyCode &lt;= K_Z        return ('A' + (char)(keyCode - K_A))    else if keyCode == K_SPACE        return ' '    else        return ''    endend</code></pre><p>如果需要，可以进一步扩展函数同时支持大小写，可以根据Shift键是否按下进行判断。</p><h1 id="二、HUD元素"><a href="#二、HUD元素" class="headerlink" title="二、HUD元素"></a>二、HUD元素</h1><p>最基础的<strong>HUD</strong> 元素就是玩家得分和剩余生命值。这种HUD实现起来相对琐碎——在主要游戏场景渲染之后，我们只要在顶层绘制文字或者图标以展示相应的信息即可。但是很多游戏都使用了更加复杂的元素，包括路点箭头、雷达、指南和准心。</p><h2 id="1-路点箭头"><a href="#1-路点箭头" class="headerlink" title="1.路点箭头"></a>1.路点箭头</h2><p>路点箭头用于引导玩家到下一个目标点。一个最简单的方法就是让箭头成为真正的3D对象，然后放置在屏幕对应的位置。然后随着玩家在游戏世界中移动，3D箭头会旋转到正确的指向以指引玩家移动。</p><p>实现这种路点箭头的第一步就是建立一个在没有任何旋转作用在上面的时候超前指向的箭头，然后在游戏过程中有3个参数需要跟踪：箭头朝向的向量、箭头在屏幕空间中的位置，还有箭头跟踪的路点。</p><p>朝向向量应该先初始化轴向使得指向屏幕内。在传统的左手坐标系中，就是+z轴。箭头在屏幕空间中所在的位置就是我们所希望箭头在屏幕中的相应位置。这是我们需要把箭头从屏幕空间的坐标转换为3D世界中的坐标。最后，路点位置就是箭头朝向所需要的指向位置。</p><p>为了更新路点箭头，每一帧都需要构造一个从玩家到路点的向量。然后进行正规化，就可得到箭头所需要的朝向。接下来的问题就是使用点乘和叉乘来确定原始朝向到新朝向所需要的旋转角度。这个旋转可以使用四元数，是用插值得到平滑的箭头过渡。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/27/uRoQsjC3YD8VkUH.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 《疯狂出租车》中的路点箭头</div></center><p>这种类型箭头的实现如下所示。这种实现有几件事需要记住。首先就是摄像机在路点箭头之前更新，因为这是保证路点箭头在屏幕上同一位置的唯一方法。否则，当摄像机发生改变是，路点箭头会延后更新一帧。</p><p>还有，路点箭头渲染时需要在其他3D物体渲染之后关闭z-buffer才能进行渲染。这样能够确保箭头总能被渲染出来，哪怕有其他3D物体在它前面。</p><pre><code>class WaypointArraw    //记录箭头的朝向    Vector3 facing    //箭头在屏幕上的2D位置    Vector2 screenPosition    //箭头指向的当前路点    Vector3 waypoint    //用于渲染箭头的世界变换矩阵    Matrix worldTransform    //通过给定位置/旋转计算世界变换矩阵    function ComputeMatrix(Vector3 worldPosition, Quaternion rotation)        //缩放、旋转、平移        worldTransform = CreateFromQuaternion(rotation) * CreateTranslation(worldPosition)    end    //根据屏幕位置计算3D箭头的世界坐标    function ComputeWorldPosition()        //为了计算反投影，我们需要一个3D向量        //z分量是一个在近平面和远平面之间的百分比        //在这种情况下，我选择二者之间10%的一个点(z=0.1)        Vector3 unprojectPos = Vector3(screenPosition.x, screenPosition.y, 0.1)        //得到摄像机和投影矩阵        ...        //调用反投影函数        return Unproject(unprojectPos, cameraMatrix, projectionMatrix)    end    function Initialize(Vector2 myScreenPos, Vector3 myWaypoint)        screenPosition = myScreenPos        //对于Y轴向上的左手坐标系        facing = Vector3(0, 0, 1)        SetNewWaypoint(myWaypoint)        //初始化世界变换坐标系        ComputeMatrix(ComputeWorldPosition(), Quaternion.Identity)    end    function SetNewWaypoint(Vector3 myWaypoint)        waypoint = myWaypoint    end    function Update(float deltaTime)        //得到箭头的当前世界坐标        Vector3 worldPos = ComputeWorldPosition()        //得到玩家位置        ...        //箭头的新朝向是一个正规化向量        //从玩家的位置指向路点        facing = waypoint - playerPosition        facing.Normalize()        //使用点乘得到原始朝向(0,0,1)和新朝向之间的夹角        float angle = acos(DotProduct(Vector3(0, 0, 1), facing))        //使用叉乘得到轴的旋转轴        Vector3 axis = CrossProduct(Vector3(0, 0, 1), facing)        Quaternion quat        //如果长度为0，意味着平行        //意味着不需要旋转        if axis.Length() &lt; 0.01f            quat = Quaternion.Identity        else            //计算用来表示旋转的四元数            axis.Normalize()            quat = CreateFromAxisAngle(axis, angle)        end        //现在设置箭头最后的世界变换        ComputeMatrix(worldPos, quat)    endend</code></pre><h2 id="2-准心"><a href="#2-准心" class="headerlink" title="2.准心"></a>2.准心</h2><p>大多数第一人称或者第三人称游戏带有的远程攻击都会使用准心这种标准的HUD，它使得玩家指定自己距离打中目标还差多远。不管准心是传统的十字形还是圆形，实现原理都一样。</p><p>就像鼠标光标一样，准心是一个在屏幕上的光标。我们拿到整个2D坐标，然后执行两个反投影：一个在近平面，一个在远平面。得到这两个点以后，可以在这两点之间执行光线投射。</p><h2 id="3-雷达"><a href="#3-雷达" class="headerlink" title="3.雷达"></a>3.雷达</h2><p>有的游戏会有雷达系统来显示雷达范围附近的敌方(或者友方)。为了让雷达顺利工作，需要完成两件事情。首先，我们有一种方式可以遍历能够在雷达上显示的所有对象。然后，所有在雷达范围内的对象都需要根据UI中心做出相应的偏移。计算距离和转换为2D偏移，我们都希望忽视高度，这意味着我们必须投影雷达对象到雷达面板上。</p><p>在我们计算之前，应该先定义<strong>雷达光点</strong>结构体，就是那些在雷达上显示的点。这样，就可以根据实际情况让这些点有不同的大小和颜色。</p><pre><code>struct RadarBlip    //雷达光点的颜色    Color color = Color.Red    //雷达光点的位置    Vector2 position    //雷达光点的缩放    float scale = 1.0fend</code></pre><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/27/R4EyLhPeWaXixKC.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 《战地5》中的雷达(在左下角)</div></center><p>对于Radar类来说，需要有两个参数：游戏世界中的对象能够被探测出来的最大距离，以及屏幕上显示的雷达半径。通过这两个参数，在我们得到光点位置之后，就可转换到屏幕上正确的位置。</p><pre><code>class Radar    //雷达在游戏世界单位中的范围    float range    //雷达在屏幕中的位置(x,y)    Vector2 position    //雷达在屏幕中的半径    float radius    //雷达的背景图片    ImageFile radarImage    //所有活跃的雷达光点    List blips    //初始化函数设置range、center、radius及image    ...    function Update(float deltaTime)        //清除上一帧的光点        blips.Clear()        //获取玩家位置        ...        //将playerPosition转换为2D坐标        //以下假设y轴向上        Vector2 playerPos2D = Vector2(playerPosition.x, playerPosition.z)        //计算需要添加到blip上的选择        //得到正规化后的玩家朝向向量        ...        //将playerFacing转换为2D        Vector2 playerFacing2D = Vector2(playerFacing.x, playerFacing.z)        //计算雷达前向与玩家朝向之间的夹角        float angle = acos(DotProduct(playerFacing2D, Vector2(0,11)))        //为了使用叉乘，需要转换为3D向量        Vector3 playerFacing3D = Vector3(playerFacing2D.x, playerFacing2D.y, 0)        //使用叉乘判定旋转的方向        Vector3 crossResult = CrossProduct(playerFacing3D, Vector2(0,1,0))        //顺时针为-z，意味着角度应该取负        if crossResult.z &lt; 0            angle *= -1        end        //判定哪些敌人在范围之内        foreach Enemy e in gameWorld            //将敌人的位置转换为2D坐标            Vector2 enemyPos2D = Vector2(e.position.x, e.position.z)            //构造从玩家到敌人的向量            Vector2 playerToEnemy = enemyPos2D - playerPos2D            //检查长度，看看是否在距离之内            if playerToEnemy.Length() &lt;= range                //旋转playerToEnemy，使得它相对于玩家朝向旋转(使用2D旋转矩阵)                playerToEnemy = Rotate2D(angle)                //为敌人创建雷达光点                RadarBlip blip                //取playerToEnemy向量，转换为相对于屏幕上雷达中心点的偏移                blip.position = playerToEnemy                blip.position /= range                blip.position *= radius                //将blip添加到blips中                blips.Add(blip)            end        loop    end    function Draw(float deltaTime)        //绘制雷达图片        ...        foreach RadarBlip r in blips            //在position + blip.position的位置绘制r            //因为blip中存放的是偏移量            ...        loop    endend</code></pre><p>雷达还有一些可以改善的地方。比如，同时显示敌人和友军，以及只显示最近开枪的敌人等等。</p><h1 id="三、其他需要考虑的UI问题"><a href="#三、其他需要考虑的UI问题" class="headerlink" title="三、其他需要考虑的UI问题"></a>三、其他需要考虑的UI问题</h1><h2 id="1-支持多套分辨率"><a href="#1-支持多套分辨率" class="headerlink" title="1.支持多套分辨率"></a>1.支持多套分辨率</h2><p>对于PC游戏来说，通常都会有很高的分辨率，现在最新的5k显示器分辨率是5120x2880，但是其他分辨率也有很多人在使用，比如4k显示器分辨率4096x2160以及2k、1080p等等。</p><p>解决方法就是避免使用绝对坐标，而使用相对坐标。相对坐标可以根据屏幕上的一些关键位置(通常是屏幕角落或者中心)来表达，又或者相对于其他UI元素来表达。</p><h2 id="2-本地化"><a href="#2-本地化" class="headerlink" title="2.本地化"></a>2.本地化</h2><p>虽然一款游戏只支持一种语言也是可行的，但是大多数商业游戏都需要支持多语言。<strong>本地化</strong>就是支持更多语言的过程。由于许多菜单和HUD都有文本显示，在设计UI系统的时候就需要重视。哪怕一款游戏不需要本地化，但将文本硬编码到代码里面本身就非常不好，这样不利于非程序员修改。但是如果游戏需要本地化，将硬编码移除就特别重要。</p><p>最简单的文本本地化方法就是将游戏中这些文本存储到外部文件中。这个外部文件可以使用XML、JSON或者类似的格式。这样紧接着就可以通过字典映射键来访问特定的字符串。</p><p>不幸的是，支持使用不同字符的语言会让问题变得复杂。传统的ASCII字符集只能支持英语字母，不支持阿拉伯语和简体中文之类的象形文字。因此，大多数游戏都通过Unicode字符集来支持不同的编码系统。有多种方式来对Unicode字符进行编码，最流行的方法就是UTF-8。</p><p>还有一个问题就是一个单词在不同语言中的长度不一样，比如说德语单词的平均长度要比英语长一些。这就是说，我们需要考虑UI元素的适配问题使得所有语言都能放在上面。</p><p>除了文本和语言之外，本地化的另一个重要方面就是对游戏内容根据国家本地化。需要遵守不同国家的法律和习俗，需要特别注意。</p><h2 id="3-UI中间件"><a href="#3-UI中间件" class="headerlink" title="3.UI中间件"></a>3.UI中间件</h2><p>一个著名的中间件:Autodesk Scaleform，在AAA游戏中广泛使用。之所以使用Scaleforn是因为它允许美工使用Adobe Flash来创建所有的UI内容。</p><h2 id="4-用户体验"><a href="#4-用户体验" class="headerlink" title="4.用户体验"></a>4.用户体验</h2><p>用户体验(UX)，是当用户使用界面时的交互。一个设计不好的UI会让用户点击多个按钮来完成很简单的动作，不过你的任务不只是编程，还有UI设计，考虑UX是非常重要的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·人工智能</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-ren-gong-zhi-neng/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-ren-gong-zhi-neng/</url>
      
        <content type="html"><![CDATA[<p>本章将谈到人工智能在游戏应用中的3个方面:寻路、基于状态的行为机制、策略/计划。寻路算法可以判定非玩家角色(NPC)如何在游戏世界中移动。基于状态的行为驱动做出相应的行为。最后，策略/计划在大型AI计划的时候是必要的需求，比如实时战略(RTS)游戏。</p><h1 id="一、“真”AI与游戏AI"><a href="#一、“真”AI与游戏AI" class="headerlink" title="一、“真”AI与游戏AI"></a>一、“真”AI与游戏AI</h1><p>在传统计算机科学中，许多人工智能的研究都趋向于复杂形势的AI，包括遗传算法和神经算法。但是这些复杂的算法在计算机和游戏中应用还存在限制。这存在两个主要原因，第一个原因是复杂的算法需要大量的计算时间。大多数游戏只能分出它们每帧的小部分时间在AI上，这意味着高效比复杂重要。另外一个主要原因就是，游戏AI通常都有良好的行为定义，通常都是在策划的控制之下，而传统的AI专注于解决更加模糊而广泛的问题。</p><p>在很多游戏中，AI行为只是一种随机变化的状态机规则的组合，但还是有几个主要的例外。AI对于复杂的棋牌游戏，比如象棋或者围棋，需要决策树支持，这是传统游戏理论的基石。但是棋牌游戏在某一时刻的行动选择相比其他游戏来将还是要小一些。也有一些游戏实时做出很复杂的算法，但那些是特例。一般来讲，如果玩家觉得敌人的AI或者队友的AI行为很聪明，这个AI系统就已经成功了。</p><h1 id="二、寻路"><a href="#二、寻路" class="headerlink" title="二、寻路"></a>二、寻路</h1><p>寻路就是看似简单问题的解：给定点A和B，AI该怎么只能地在游戏世界中行走？这个问题的复杂度来自于实际上A和B之间存在大量的路径可走，但只有一条是最佳的。</p><p>所以只是找到一条两点之间的有效路径是不够的的。理想的寻路算法需要查找所有可能的情况，然后比较出最好的路径。</p><h2 id="1-搜索空间的表示"><a href="#1-搜索空间的表示" class="headerlink" title="1.搜索空间的表示"></a>1.搜索空间的表示</h2><p>最简单的寻路算法设计就是将<strong>图</strong>作为数据结构。一个图包含了多个<strong>节点</strong>，连接任意邻近的点组成<strong>边</strong>。在内存中表示图有很多种方法，但是最简单的是邻接表。在这种表示中，每个节点包含了一系列指向任意邻近节点的指针。图中的完整节点集合可以存储在标准的数据结构容器里。</p><p>这意味着在游戏中实现寻路的第一步是如何将游戏世界用图来表示。这里有多种方法。一种简单的方法就是将世界分区为一个个正方形的格子(或者六边形)。这种情况下，邻近节点就是格子中邻近的正方形。这个方法在回合制策略游戏中很流行，比如《文明》或者XCOM。</p><p>但是，对于实时动作游戏，NPC通常不是在网格上一个正方形一个正方形地走。由此，在主流游戏中要么使用路点要么使用导航网格。可以在场景编辑器照片那个手工构造也可以自动化。</p><p><strong>寻路节点</strong>最早在第一人称射击游戏(FPS)中使用，由id Software再20世纪90年代早期推出。通过这种表示方法，关卡设计师可以在游戏世界中摆放那些AI可以到达的位置。这些路点直接被解释为图中的节点。而边则可以自动生成。</p><p>路点的主要缺点是AI只能在节点和边缘的位置移动。这是因为即使路点组成三角形，也不能保证三角形内部就是可以行走的。通常会有很多不能走的区域，所以寻路算法需要人为不在节点和边缘上的区域都是不可走的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/26/u1mHBhi9wktzYbG.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 《幕府将军的头骨》用AI调试模式演示它用于寻路的格子</div></center><p>实际上，当部署路点之后，游戏世界中就会有很多不可到达的区域要么有很多路点。前者是不希望出现的状况，因为这样会让AI的行为显得不可信且不自然，而后者缺乏效率。越多的节点就会有越多的边缘，寻路算法花费的时间就会越长。通过路点，在性能和精确度上需要折中。</p><p>一个可选的解决方案就是使用<strong>导航网格</strong>。在这种方法中，图上的节点实际上就是凸多边形。邻近节点就是简单的任意邻近的凸多边形。这意味着整个游戏世界区域可以通过很少数量的凸多边形表示，结果就是图上的节点特别少。</p><p>通过导航网格，在凸多边形内部的任意位置都认为是可走的。这意味着AI有了大量的空间可以行走，因此寻路可返回更自然的路径。</p><p>导航网格还有其他一些优点。比如可以只用一份导航网格就可以计算不同的角色是否可以到达。还有一点就是导航网格完全可以自动生成。</p><h2 id="2-可接受的启发式算法"><a href="#2-可接受的启发式算法" class="headerlink" title="2.可接受的启发式算法"></a>2.可接受的启发式算法</h2><p>所有寻路算法都需要一种方法以数学的方式估算某个节点是否应该被选择。大多数游戏都会使用<strong>启发式</strong>，以h(x)表示，就是估算从某个位置到目标位置的开销。理想情况下，启发式结果越接近真实越好。如果它的估算总是保证小于等于真实开销，那么这个启发式是<strong>可接受</strong>的。如果启发式高估了实际的开销，这个寻路算法就会有一定概率无法发现最佳路径。</p><p>对于正方形格子，有两种方式计算启发式。第一种是<strong>曼哈顿距离</strong>，简单来说曼哈顿距离认为不能沿对角线方向移动，也只有这种情况下才能使用启发式。如果对角线移动是被允许的，则曼哈顿距离会经常高估真实开销。</p><p>在2D格子中，曼哈顿距离的计算如下:</p><p>$$<br>h(x)=|start.x-end.x|+|start.y-end.y|<br>$$</p><p>第二种计算启发式的方法就是<strong>欧几里得距离</strong>。这种启发式的计算使用标准距离公式然后估算直线路径。不像曼哈顿距离，欧几里得距离可以用在其他寻路表示中计算启发式，比如路点或者导航网络。在我们的2D格子中，欧几里得距离为:</p><p>$$<br>h(x)=\sqrt{(start.x-end.x)^2+(start.y-end.y)^2}<br>$$</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/26/tBwsnEYD24ky3vP.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 曼哈顿与欧几里得距离： 红、蓝与黄线分别表示所有曼哈顿距离都拥有一样长度（12），而绿线表示欧几里得距离有6×√2 ≈ 8.48的长度</div></center><h2 id="3-贪婪最佳优先算法"><a href="#3-贪婪最佳优先算法" class="headerlink" title="3.贪婪最佳优先算法"></a>3.贪婪最佳优先算法</h2><p>在有了启发式之后，可以开始实现一个相对简单的算法:<strong>贪婪最佳优先算法</strong>。一个算法如果没有做任何长期计划而且只是马上选择最佳答案的话，则可以被认为是贪婪算法。在贪婪最佳优先算法的每一步，算法会先看所有邻近节点，然后选择最低开销的启发式。</p><p>虽然这样看起来理由充足，但是最佳优先算法通常得到的都是次优的路径。如下图，路径上存在不必要的向右移动，这是因为这在当时就是最佳的访问节点。一个理想的路径应该是一开始就往下走，但是这要求一定程度的计划，这是贪婪算法所不具备的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/26/WXpKBMLzkH9gRb7.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 贪婪最佳优先路径</div></center><p>下面来实现这个贪婪算法。首先，先看看我们每个节点所需要存储的数据。为了能够将这些数据构造成图，需要有额外的邻近信息。</p><pre><code>struct Node    Node parent    float hend</code></pre><p>那个parent成员变量用于跟踪哪个节点是当前访问的。parent成员的价值在于构造链表，能够从终点回到起点。当算法完成的时候，parent链表就可以通过遍历得到最终路径。浮点数h存储了某个节点的h(x)的值，这个值导致在选择节点的时候会偏向于h值最小的节点。</p><p>算法的下一个组件就是用于临时存储节点的容器：开放集合和封闭集合。<strong>开放集合</strong>存储了所有目前需要考虑的节点。由于找到最低h(x)值开销节点的操作是很常见的，所以对于开放集合可以采用某种类似于二叉堆或者优先级队列的容器。</p><p>而<strong>封闭集合</strong>则包含了所有已经被算法估值的节点。一旦节点在封闭集合中，算法不再对其进行考虑。由于经常会检查一个节点是否存在于封闭集合里，故会使用搜索的时间复杂度优于O(n)的数据结构，比如二叉搜索树。</p><p>现在我们就有了贪婪最佳优先算法所需要的组件。假设有开始节点和结束节点，而且我们需要计算两点之间的路径。算法的主要部分在循环中处理，但是，在进入循环之前，我们需要先初始化一些数据：</p><pre><code>currentNode = stratNodeadd currentNode to closedSet</code></pre><p>当前节点只是跟踪哪个邻居节点是议案一个估值的节点。在算法开始的时候，我们除了开始节点没有任何节点，所以需要先对开始节点的邻居进行估值。</p><p>在主循环里，我们首先要做的事情就是查看所有与当前节点相邻的节点，而且把一部分加到开放集合里：</p><pre><code>do    foreach Node n adjacent to currentNode    if closedSet conatins n        continue    else        n.parent = currentNode        if openSet does not contain n            compute n.h            add n to openSet        end    endloop</code></pre><p>注意任意已经在封闭集合里的节点都会被忽略。在封闭集合里的节点都在之前进行了估值，所以不需要再进一步估值了。对于其他相邻节点，这个算法会把parent设置为当前节点。然后，如果节点不在开放集合中，我们计算h(x)的值并且把节点加入开放集合。</p><p>在邻近节点处理完之后，如果开放集合中再也没有节点存在，意味着我们把所有节点都估算过了，这就会导致寻路失败。实际上也不能保证总有路径可走，所以算法必须考虑这种情况:</p><pre><code>if openSet is empty    break //退出主循环end</code></pre><p>但是，如果开放集合中还有节点，我们就可以继续。接下来要做的事情就是在开放集合中找到最低h(x)值开销节点，然后移到封闭集合中。在新一轮迭代中，我们依旧将其设为当前节点。</p><pre><code>currentNode = Node with lowest h in openSetremove currentNode from openSetadd currentNode to closedSet</code></pre><p>最后，在找到有效路径之后，当前节点等于终点，这样就能够退出循环了。</p><p>until currentNode == endNode //end main do…until loop</p><p>如果在成功的情况下退出do…until循环，我们会得到一条链表通过parent从终点指向起点。由于我们想要得到从起点到终点的路径，所以必须将其反转。有很多种方法反转链表，最简单的方法就是使用栈。</p><p>完整的贪婪最佳优先算法如下所示。注意这个实现假设h(x)的值在执行过程中总是不变的。</p><pre><code>currentNode = startNodeadd currentNode to closedSetdo    //把邻接节点加入开放集合    foreach Node n adjacent to currentNode        if closedSet contains n            continue        else            n.parent = currentNode            if openSet does not contain n                compute n.h                add n to openSet            end        end    loop    //所有可能性都尝试过了    if openSet is empty        break    end    //选择新的当前节点    currentNode = Node with lowest h in openSet    remove currentNode from openSet    add currentNode to closedSetuntil currentNode == endNode</code></pre><h2 id="4-A-寻路"><a href="#4-A-寻路" class="headerlink" title="4.A*寻路"></a>4.A*寻路</h2><p>比起单一地依赖于h(x)作为寻路的估价，A* 算法 增加了 <strong>路径开销</strong>分量。路径开销就是从起点到当前节点的实际开销，通过g(x)计算。A*中访问一个节点的开销等式为:</p><pre><code>f(x)=g(x)+h(x)</code></pre><p>为了能够使用A*算法，Node结构体需要增加f(x)和g(x)的值。</p><pre><code>struct Node    Node parent    float f    float g    float hend</code></pre><p>当一个节点加入开放集合之后，我们需要计算所有的3个分量，而不仅仅是启发式。而且，开放集合会根据f(x)的值来排序，因为在A*中每次迭代都会选择f(x)值最低的节点。</p><p>对于A* 算法只有一个主要变化，那就是<strong>节点选用</strong> 的概念。在最佳优先算法中，总是把邻接节点作为父节点。但是在A* 算法中，已经放在开放集合中的邻接节点需要估值之后才能决定哪个当前节点是父节点。</p><p>这是因为g(x)的开销取决于父节点g(x)的开销，这意味着如果父节点是可选的，那么g(x)的开销是可变的。所以在A* 算法中我们不想自动更改节点的父节点。只有在当前节点是更好的父节点时才改动。</p><pre><code>currentNode = startNodeadd currentNode to closedSetdo    foreach Node n adjacent to currentNode        if closedSet contains a            continue        else if openSet contains n //选用检查            compute new_g //n节点以当前节点为父节点的g(x)值            if new_g &lt; n.g                n.parent - currentNode                n.g = new_g                n.f = n.g + n.h //该节点的n.h是不变的            end        else            n.parent = currentNode            compute n.h            compute n.g            n.f = n.g + n.h            add n to openSet        end    loop    if openSet is empty        break    end    currentNode = Node with lowest f in openSet    remove currentNode from openSet    add currentNode to closeSetuntil currentNode == endNode</code></pre><h2 id="5-Dijkstra算法"><a href="#5-Dijkstra算法" class="headerlink" title="5.Dijkstra算法"></a>5.Dijkstra算法</h2><p>最后一个寻路算法可以通过稍微修改A* 算法得到。在Dijkstra算法中，没有启发式的估算——或者换个角度:<br>$$<br>f(x)=g(x)+h(x)<br>$$</p><p>$$<br>h(x)=0<br>$$</p><p>$$<br>\therefore f(x)=g(x)<br>$$</p><p>这意味着Dijkstra算法可以使用与A* 算法一样的代码，除了启发式为0之外。但在实际应用中，大多数游戏都不会使用Dijkstra算法。提起这个算法只是因为Dijkstra算法比A* 早10年提出。A* 的创新在于结合了贪婪最佳优先和Dijkstra算法。</p><h1 id="三、基于状态的行为"><a href="#三、基于状态的行为" class="headerlink" title="三、基于状态的行为"></a>三、基于状态的行为</h1><p>大多数基础的AI行为无非就是不同的状态。以《乒乓》的AI举例，它只需要跟踪球的位置。这个行为在整个游戏的过程中都没有改变，所以这样的AI可以被认为是<strong>无状态</strong>的。但是当游戏有点复杂度的时候，AI就需要在不同的时候有不同的行为。大多数现代游戏的NPC在不同的位置都有不同的行为。</p><h2 id="1-AI的状态机"><a href="#1-AI的状态机" class="headerlink" title="1.AI的状态机"></a>1.AI的状态机</h2><p><strong>有限状态机</strong> 可以完美地表达基于状态的AI。它有着一组可能的状态，由一定条件控制状态转换，而在状态切入切除的时候可以执行动作。</p><p>当你为AI实现状态机时，应该先设计好有着什么样的行为，这些行为是如何连接的。假设我们为潜行游戏实现警卫的基础AI。默认情况下，我们会让警卫巡逻预定好的路径。如果警卫在巡逻的时候发现玩家，他应该会攻击玩家。最后，如果警卫被杀死了，他应该死亡。所以AI描述起来应该有3种状态:巡逻、攻击、死亡。</p><p>紧接着，我们需要决定哪些状态机之间可以切换。进入死亡状态的条件很明显，就是警卫被杀死，就会进入死亡状态。对于攻击状态，只有玩家被警卫发现才会进入。</p><p>虽然这个AI能用，但是比起大多数潜行游戏的AI来说就弱多了。</p><h2 id="2-基础的状态机实现"><a href="#2-基础的状态机实现" class="headerlink" title="2.基础的状态机实现"></a>2.基础的状态机实现</h2><p>状态机有多种实现方式。最简单的需求就是当AI更新的时候，正确的更新行为必须根据当前状态来完成。理想情况下，我们还想让状态机有进入和退出行为。</p><p>如果AI只有两种状态，我们可以在AI的Update函数中用一个布尔值来判断。但是这个方案不够健壮。一个稍微灵活的方式是通过枚举值来表示不同的状态，这经常在简单的游戏中可以看到。例如，上述的状态机就可以像下面这样定义枚举:</p><pre><code>enum AIState    Patrol,    Death,    Attackend</code></pre><p>然后可以用AIController类似AIState类型作为成员变量。在我们的AIController的Update函数中，可以根据当前状态来执行不同的行为:</p><pre><code>function AIController.Update(float deltaTime)    if state == Patrol        //执行巡逻行为    else if state == Death        //执行死亡行为    else if state == Attack        //执行攻击行为    endend</code></pre><p>状态的变化和进入/退出行为可以在第二个函数中实现:</p><pre><code>function AIController.SetState(AIState newState)    //退出行为    if state == Patrol        //退出巡逻行为    else if state == Death        //退出死亡行为    else if state == Attack        //退出攻击行为    end    state = newState    //进入行为    if state == Patrol        //进入巡逻行为    else if state == Death        //进入死亡行为    else if state == Attack        //进入攻击行为    endend</code></pre><p>这个实现有几个问题。首先很明显的一点就是，随着状态机的增加，Update和SetState的可读性会减弱。</p><p>第二个主要问题是缺乏灵活性。加入我们有两个AI，它们有不同的状态机。这样我们就需要为不同的AI实现不同的枚举和控制器。如果两个AI之间会公用一些状态，以我们目前的基础代码结构是无法在AI之间共享状态的。</p><p>一个方法是将巡逻的代码复制到两个类中，但是有着两份同样的重复代码是非常不好的实践。另一个方法就是写一个共同的基类，但是这样，意味着任何需要巡逻行为的AI都要从这里继承。</p><p>多以虽然这个基础的实现能工作，但是除非AI状态机非常简单，否则完全不推荐。</p><h2 id="3-状态机设计模式"><a href="#3-状态机设计模式" class="headerlink" title="3.状态机设计模式"></a>3.状态机设计模式</h2><p>有一个通用解法的设计模式能解决类似的问题。这可以通过类组合的方式完成，所以AIController“有一个”AIState作为成员变量。每个特定的状态都是AIState的子类。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/26/9c8anoZTUyJAGMS.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 状态机设计模式</div></center><p>基类AIState的定义如下:</p><pre><code>class AIState    AIController parent    function Update(float deltaTime)    function Enter()    function Exit()end</code></pre><p>父引用使得任何AIState的实例都可以让AIController拥有它。这是必要的，如果我们想要切换到新的状态，需要有一些方法通知AIController这些事情。每个AIState都有自己的Update、Enter、Exit函数，可以为某个特定有需求的状态所实现。</p><p>AIController类会保留一个当前AIState的引用，而且需要Update和SetState函数:</p><pre><code>class AIController    AIState state    function Update(float deltaTime)    function SetState(AIState newState)end</code></pre><p>这样，AIController的Update函数只要简单地调用AIState的Update函数即可:</p><pre><code>function AIController.Update(float deltaTime)    state.Update(deltaTime)end</code></pre><p>通过设计模式，SetState函数也变得清晰多了:</p><pre><code>function AIController.SetState(AIState newState)    state.Exit()    state = newState    state.Enter()end</code></pre><p>通过状态设计模式，所有状态相关的行为都移到AIState的子类当中去了。这使得AIController的代码比之前清晰多了。状态机设计模式也使得系统更加模块化。比如说，如果我们想要在多个状态机中使用巡逻代码，就会容易很多。而且即使我们想让巡逻稍稍不同，只要从巡逻继承出去就可以修改。</p><h1 id="四、策略和计划"><a href="#四、策略和计划" class="headerlink" title="四、策略和计划"></a>四、策略和计划</h1><p>很多游戏都需要比基于状态的敌人更复杂的AI。</p><h2 id="1-策略"><a href="#1-策略" class="headerlink" title="1.策略"></a>1.策略</h2><p><strong>策略</strong>就是从AI的视角来完成游戏。比如说，它要思考的是应该更具侵略性还是防守性。<strong>微观策略</strong>由单位行为组成。这通常可以用状态机来完成。相对而言，<strong>宏观策略</strong>会复杂得多。它是AI的大局观，而且会决定如何完成游戏。</p><p>策略有时候看上去就像很模糊的使命描述，而且模糊的策略是很难开发的。为了让问题更加形象，策略通常被认为是一系列的特定目标。比如说，如果策略是“科技”，一个特定的目标可能就是去“扩张”。</p><p>一个策略通常都不止一个目标，也就是说，我们需要有一个优先级系统来让AI选择哪个目标更加重要。所有其他目标如果优先级不是最高，俺么会先搁在后面不管。其他目标会在最重要的目标完成时重新参与选择。一个实现目标系统的方式就是像这样写一个AIGoal类:</p><pre><code>class AIGoal    function CalculatePriority()    function ConstructPlan()end</code></pre><p>每个特定目标都会作为AIGoal的子类实现。所以当策略进行目标选择之后，所有策略的目标会放到一个根据优先级排序的容器里。注意，真正高级的策略系统应该支持同时选用多个目标的功能。因为如果两个目标不是互斥的，那么是没有理由不同时选择两个目标的。</p><p>计算优先级的启发式函数是CalculatePriority，会根据游戏规则的不如而变化。</p><p>AIGoal中的ConstructPlan函数就是用于构造<strong>计划</strong>的：一系列为了达到目标而计划出来的步骤。</p><h2 id="2-计划"><a href="#2-计划" class="headerlink" title="2.计划"></a>2.计划</h2><p>每个目标都需要一个相应的计划。比如说，如果目标是扩张，那么计划可能如下:</p><ol><li>为扩张侦查合适的地点</li><li>建立足够多的单位来保护扩张</li><li>派遣工人和战斗单位去扩张点</li><li>开始建造扩张点</li></ol><p>特定目标的计划可以用状态机来实现。计划中的每一步都可以是状态机中的一个状态，而状态机持续为该步骤行动直到达到条件。但是，实践中的计划很少是线性的。根据计划某个步骤的成功或者失败，AI可能会调整步骤的顺序。</p><p>一个需要考虑的事情是计划需要定期查看目标的可行性。如果扩张计划中发现没有适合扩张的位置，那么目标就是不可行的。一旦目标被标记为不可行，大局观需要重新估算。最终，必须要有一个“指挥官”来决定策略的改变。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·摄像机</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-she-xiang-ji/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-she-xiang-ji/</url>
      
        <content type="html"><![CDATA[<p>摄像机赋予了玩家在3D世界中的视角。在游戏中会用到很多种类型的摄像机，而选择摄像机又是游戏开发初期的基本设计决策</p><h1 id="一、摄像机的类型"><a href="#一、摄像机的类型" class="headerlink" title="一、摄像机的类型"></a>一、摄像机的类型</h1><h2 id="1，固定摄像机"><a href="#1，固定摄像机" class="headerlink" title="1，固定摄像机"></a>1，固定摄像机</h2><p>严格来讲，<strong>固定摄像机</strong>就是那种永远在同一位置的摄像机。这种固定的摄像机通常只用于非常简单的3D游戏。术语“固定摄像机”也可以扩展为根据玩家的位置而摆放在预先定义好的位置。随着玩家在场景中移动，当玩家位置超过某个阈值时，摄像机位置会突然跳到下一个点。摄像机的位置和阈值完全由策划在创建关卡时控制。</p><h2 id="2-第一人称摄像机"><a href="#2-第一人称摄像机" class="headerlink" title="2.第一人称摄像机"></a>2.第一人称摄像机</h2><p><strong>第一人称摄像机</strong>是以玩家的视角来体验游戏世界的。由于摄像机时角色视角，第一人称摄像机是最让人身临其境的摄像机类型。第一人称摄像机在第一人称射击游戏中非常流行，但是在其他游戏比如《上古卷轴:天际》也会用到。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/23/7Hef9WCFvbTLaQZ.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 第一人称的COD15</div></center><p>第一人称游戏最常见的做法就是在眼睛附近放摄像机，这样其他角色和物体才会有相应的高度。但是，问题是很多第一人称游戏都希望能够显示角色手部。如果摄像机在眼睛位置，当角色向前看的时候是看不到手的。还有一个问题就是，如果玩家的角色模型绘制出来，你会从接近眼睛位置的摄像机看到很奇怪的效果。</p><p>为了解决以上问题，大多数第一人称游戏都不会使用普通模型。取而代之的是，使用一个特殊的只有手臂(可能还有腿)的对解剖来讲不正确的位置。这样，就算向前看，玩家也总能看到手上有什么。如果使用了这个方法，一些特殊情形，比如看到自己的倒影这种情况就需要考虑了。否则，玩家看到空气中悬挂的手臂，就会被吓到。</p><h2 id="3-跟随摄像机"><a href="#3-跟随摄像机" class="headerlink" title="3.跟随摄像机"></a>3.跟随摄像机</h2><p><strong>跟随摄像机</strong>会在一个或者多个方向上跟在目标后面。这种摄像机能够在游戏中得到广泛的应用——不管是赛车游戏，跟随者车，就像《火爆狂飙》系列那样，还是第三人称动作/冒险游戏，就像《神秘海域》那样。由于跟随摄像机能够用在非常多的领域中，所以种类繁多。</p><p>有的跟随摄像机与目标始终保持固定距离，而有的则与目标保持弹性距离。有的跟随角色的过程中会旋转，而有的不会。有的甚至允许玩家突然转身看身后有什么。</p><h2 id="4-场景切换摄像机"><a href="#4-场景切换摄像机" class="headerlink" title="4.场景切换摄像机"></a>4.场景切换摄像机</h2><p>越来越多的游戏会用到<strong>场景切换</strong>，就是在播放游戏剧情的时候，从玩家的摄像机切过去的一种手法。在3D游戏中实现场景切换，要预先在场景中放置动画中用到的固定摄像机。很多场景切换会使用电影设备，比如移动镜头。为了达到效果，会用到样条系统。</p><h1 id="二、透视投影"><a href="#二、透视投影" class="headerlink" title="二、透视投影"></a>二、透视投影</h1><p>透视投影是具有深度的，就是说，如果物体距离摄像机越来越远，那么看上去就会越来越小。</p><h2 id="1-视场"><a href="#1-视场" class="headerlink" title="1.视场"></a>1.视场</h2><p>观看世界视野的广度及角度，称为<strong>视场</strong>(FOV)。对人类来说，我们的眼睛提供了180°的视野，但是并不是每个角度都有等量的淸晰度。双目并视的时候，两只眼都可以同时看到大约120°的视场。而剩余的视场在边缘处，能够快读地发现运动，但是不够清晰。</p><p>设置投影矩阵的时候，视场是需要考虑的非常重要的因素。因为一个不正确的视场可以导致玩家紧张和眩晕。下面我们分别看一下高清电视玩家用机游戏和显示器玩PC游戏的视场问题。</p><p>推荐的观看高清电视的距离很大程度取决于向你推荐的人，THX推荐的观看距离为取对角线长度乘以1.2。所以50°的电视应该从60°的距离观看。这个距离，电视机会有大约40°的<strong>视角度</strong>，就是说电视会占了观看者40°的视场。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/23/zTvYnRXye5Kl4EW.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 50°的高清电视有40°的视角度(a)和PC显示器有90°的视角度(b)</div></center><p>在这种条件下，只要给游戏留下多于40°的视场，几乎所有的角色行动都能看得一清二楚。</p><p>但是如果将家用机游戏替换成PC游戏会怎样？在PC的条件下，显示器会占用玩家更多的视场。这种条件下通常有90°以上的视场，这个视场及视角度的差异会让一些玩家感到不舒服。</p><p>如果视场增加，能够看到的部分便增多。虽然玩家采用更大的视场，会得到更大的优势。但是只要视场限制到最大120°，就可以认为这个优势是很微弱的。如果视场变得太大，就会有<strong>鱼眼效果</strong>，屏幕的边缘变得弯曲。就类似与摄影中使用了广角镜头一样。大多数游戏不会允许玩家选择太高的视场。</p><h2 id="2-宽高比"><a href="#2-宽高比" class="headerlink" title="2.宽高比"></a>2.宽高比</h2><p><strong>宽高比</strong>就是观看世界视口的宽度和高度的比率。对于全屏游戏而言，宽高比就通常取决于显示设备所选择分辨率的宽高比。有个例外就是那些可以分屏多人模式的游戏。在这种情况下，游戏世界就有了多个视口。最流行的游戏宽高比是4:3、16:9、16:10。</p><p>经典的1024x768分辨率(就是横排1024个像素，竖排768个像素)就是4:3的宽高比。今天大多数显示器都使用16:9，而不是4:3。标准的高清分辨率720p(就是1280x720)就是16:9宽高比的例子。</p><p>同时支持4:3和16:9宽高比，需要决定哪个分辨率能够看到更多的游戏世界。常见的方法是16:9在横向上看的更多。但是有的游戏，特别是《生化奇兵》的早期版本，采用了相反的方法，16:9模式下比4:3看到得更少。</p><h1 id="三、摄像机的实现"><a href="#三、摄像机的实现" class="headerlink" title="三、摄像机的实现"></a>三、摄像机的实现</h1><p>现在我们已经讨论了数种不同类型的基础摄像机，下面介绍一下其中一些类型计算机的可能实现方式。</p><h2 id="1-基础的跟随摄像机"><a href="#1-基础的跟随摄像机" class="headerlink" title="1.基础的跟随摄像机"></a>1.基础的跟随摄像机</h2><p>在基础的跟随摄像机中，摄像机总是直接跟随在某个对象后面，而且保持固定的距离。</p><p>为摄像机创建观察矩阵，需要3个参数:眼睛的位置(摄像机的位置)、摄像机观察的目标，以及摄像机的上方向量。在基础跟随摄像机中，眼的位置可以设置为目标的水平和垂直偏移。在计算出位置之后，就可以计算其他参数，然后传递给CreateLookAt函数:</p><pre><code>//tPos, tUp, tForward = 位置、上方和前方向量//hDist = 水平跟随距离//vDist = 垂直跟随距离function BasicFollowCamera(Vector3 tPos, Vector3 tUp, Vector3 tForward, float hDist, float vDist)    //眼睛就是目标位置的偏移量    Vector3 eye = tPos - tForward * hDist + tUp * vDist    //摄像机向前的方向是从眼睛到目标    Vector3 cameraForward = tPos - eye    cameraForward.Normalize()    //叉乘计算出摄像机的左边及上方向量    Vector3 cameraLeft = CrossProduct(tUp, cameraForward)    cameraLeft.Normalize()    Vector3 cameraUp = CrossProduct(cameraForward, cameraLeft)    cameraUp.Normalize()    //CreateLookAt的参数为eye，target，以及up    return CreateLookAt(eye, tPos, cameraUp)end</code></pre><p>虽然基础跟随摄像机会跟着目标在游戏世界中移动，看起来非常僵硬。摄像机总是保持固定距离，没有弹性。当旋转的时候，这个基础跟随行为会让人不知道是世界在转还是人在转。而且，基础跟随摄像机没有一个合理的速度，它的速度就是目标的速度。由于以上种种原因，基础跟随摄像机很少在游戏中使用。</p><p>一个简单的改善方法就是让摄像机有一个随着目标速度调整跟随距离的函数。比如说平时跟随的时候距离为100，但是当目标全速移动的时候，这个距离为200。</p><h2 id="2-弹性跟随摄像机"><a href="#2-弹性跟随摄像机" class="headerlink" title="2.弹性跟随摄像机"></a>2.弹性跟随摄像机</h2><p>有了<strong>弹性跟随摄像机</strong>，就不会由于目标的朝向或者位置改变而突然变化，而是摄像机会在几帧的过程中逐渐变化。实现方式是同时设定好理想位置与现实位置。理想位置每帧立刻变化，就像基础跟随摄像机一样(可能会有跟随距离调整函数)，然后真正的摄像机位置在后续几帧慢慢跟随到理想位置上，这样就能够创造平滑的镜头效果。</p><p>这种实现方式是通过虚拟弹簧将理想摄像机和真实摄像机连接到一起实现等。每当理想摄像机位置变化时，弹簧都被拉伸。如果理想摄像机位置不变，随着时间的推移，真实位置总会被调整到理想位置。</p><p>弹簧的效果可以由弹性常量来控制。这个常量越大，弹簧就越僵硬，就是说摄像机归位得越快。实现弹性跟随摄像机，需要确定每帧的摄像机速度和真实摄像机位置。因此最简单的实现就是使用一个类来实现。这个算法大概的工作方式是首先基于这个弹性常量计算出加速度。然后加速度通过数值积分计算出摄像机的速度，然后再进一步计算位置。</p><pre><code>class SpringCamera    //水平和垂直跟随距离    float hDist, fDist    //弹性常量:越高表示越僵硬    //一个好的初始值很大程度取决于你想要的效果    float springConstant    //阻尼常量由上面的值决定    float dampConstant    //速度和摄像机真实位置向量    Vector3 velocity, actualPosition    //摄像机跟随的目标    //（有目标的位置、向前向量、向上向量）    GameObject target    //最终的摄像机矩阵    Matrix cameraMatrix    //这个帮助函数从真实位置及目标计算出摄像机矩阵    function ComputeMatrix()        //摄像机的前向是从真实位置到目标位置        Vector3 cameraForward = target.position - actualPosition        cameraForward.Normalize()        //叉乘计算出摄像机左边，然后计算出上方        Vector3 cameraLeft = CrossProduct(target.up, cameraForward)        cameraLeft.Normalize()        Vector3 cameraUo = CrossProduct(cameraForward, cameraLeft)        cameraUp.Normalize()        // CreateLookAt参数为eye, target及up        cameraMatrix = CreateLookAt(actualPosition, target.position, cameraUp)    end    //初始化常量及摄像机，然后初始化朝向    function Initialize(GameObject myTarget, float mySpringConstant, float myHDist, float myVDist)        target = myTarget        springConstant = mySpringConstant        hDist = myHDist        vDist = myVDist        //阻尼常量来自于弹性常量        dampConstant = 2.0f * sqrt(springConstant)        //期初，设置位置为理想位置        //就跟基础跟随摄像机的眼睛位置一样        actualPosition = target.position - target.forward * hDist + target.up * vDist        //初始化摄像机速度为0        velocity = Vector3.Zero        //设置摄像机矩阵        ComputeMatrix()    end    function Update(float deltaTime)        //首先计算理想位置        Vector3 idealPosition = target.position - target.forward * hDist + target.up * vDist        //计算从理想位置到真实位置的向量        Vector3 displacement = actualPosition - idealPosition        //根据弹簧计算加速度，然后积分        Vector3 springAccel = (-springConstant * displacement) - (dampConstant * velocity)        velocity += springAccel * deltaTime        actualPosition += velocity * deltaTime        //更新摄像机矩阵        ComputeMatrix()    endend</code></pre><h2 id="3-旋转摄像机"><a href="#3-旋转摄像机" class="headerlink" title="3.旋转摄像机"></a>3.旋转摄像机</h2><p><strong>旋转摄像机</strong>会在目标附近旋转。旋转摄像机最简单的实现方法就是存储摄像机的位置及与目标的偏移，而不是直接记录摄像机的世界坐标系位置。旋转摄像机的控制模式通常可以偏航(yaw)和俯仰(pitch)，但不能滚转(roll)。由于输入方式通常将偏航和俯仰作为两个独立值输入，将旋转实现为两部分会比较好。首先，关于世界坐标系向上向量旋转摄像机(偏航)，然后关于摄像机的左侧向量进行选择(俯仰)。当摄像机比目标要低的时候，需要在两个方向上旋转摄像机才能得到正确的行为。</p><p>下面使用了四元数来实现这个旋转。</p><pre><code>//旋转摄像机class OrbitCamera    //摄像机向上的向量    Vector3 up    //目标偏移    Vector3 offset    //目标对象    GameObject target    //最终的摄像机矩阵    Matrix cameraMatrix    //初始化摄像机状态    function Initialize(GameObject myTarget, Vector3 myOffset)        //在y轴朝上的世界里，up向量就是y轴        up = Vector3(0, 1, 0)        offset = myOffset        target = myTarget        //CreateLookAt参数为eye、target和up        cameraMatrix = CreateLookAt(target.position + offset, target.position, up)    end    //根据这一帧的yaw/pitch增量角度进行更新    function Update(float yaw, float pitch)        //创建一个关于世界向上的四元数        Quaternion quatYaw = CreateFromAxisAngle(Vector3(0,1,0), yaw)        //透过这个四元数变换摄像机偏移        offset = Transform(offset, quatYaw)        up = Transform(up, quatYaw)        //向前就是target.position - (target.position + offset)        //刚好就是-offset        Vector3 forward = -offset        forward.Normalize()        Vector3 left = CrossProduct(up, forward)        left.Normalize()        //创建关于摄像机左边旋转的四元数值        Quaternion quatPitch = CreateFromAxisAngle(left, pitch)        //通过这个四元数变换摄像机偏移        offset = Transform(offset, quatPitch)        up = Transform(up, quatPitch)        //现在计算矩阵        cameraMatrix = CreateLookAt(target.position + offset, target.position, up)    endend</code></pre><h2 id="4-第一人称摄像机"><a href="#4-第一人称摄像机" class="headerlink" title="4.第一人称摄像机"></a>4.第一人称摄像机</h2><p>使用第一人称摄像机，摄像机的位置总是放在角色的相对位置上。所以当角色在世界中移动的时候，摄像机依然是玩家的位置加上偏移。</p><p>旋转的实现其实和旋转摄像机有点类似，主要区别在于目标偏移在旋转，而不是摄像机偏移。但是这种摄像机还有一些不同。其中之一就是当目标是关于向上向量偏移的时候，角色也需要跟着转动。还有一点就是俯仰度有一个取值范围。</p><p>由于这些变化，第一人称摄像机通常会将俯仰角和偏航度记录下来，而不是记录增量。这意味着旋转总是作用到最初的目标偏移，而不是旋转摄像机中增量偏移的做法。</p><pre><code>//第一人称摄像机class FirstPersonCamera    //以角色位置为原点的摄像机偏移    //对于y轴向上的世界，向上就是(0,value,0)    Vector3 verticalOffset    //以摄像机为原点的目标位置偏移    //对于z轴向前的世界，向前就是(0,0,value)    Vector3 targetOffset    //总的偏航和俯仰角度    float totalYaw, totalPitch    //摄像机所在的玩家    GameObject player    //最终的摄像机矩阵    Matrix cameraMatrix    //初始化所有摄像机参数    function Initialize(GameObject myPlayer, Vector3 myVerticalOffset, Vector3 myTargetOffset)        player = myPlayer        verticalOffset = myVerticalOffset        targetOffset = myTargetOffset        //最开始，没有任何偏航和俯仰        totalYaw = 0        totalPitch = 0        //计算摄像机矩阵        Vector3 eye = player.position + verticalOffset        Vector3 target = eye + targetOffset        //在y轴向上的世界里        Vector3 up = Vector(0,1,0)        cameraMatrix = CreateLookAt(eye, target, up)    end    //根据这一帧的增量偏航和俯仰进行更新    function Update(float yaw, float pitch)        totalYaw += yaw        totalPitch += pitch        //对俯仰进行Clamp        //在这种情况下，范围为角度45°(弧度约为0.78)        totalPitch = Clamp(totalPitch, -0.78, 0.78)        //目标在旋转之前偏移        //真实偏移则是在选择之后        Vector3 actualOffset = targetOffset        //关于y轴进行偏航旋转，旋转真实偏移        Quaternion quatYaw = CreateFromAxisAngle(Vector3(0,1,0), totalYaw)        actualOffset = Transform(actualOffset, quatYaw)        //为了俯仰计算左边向量        //前向就是偏航之后的真实偏移(经过正规化)        Vector3 forward = actualOffset        forward.Normalize()        Vector3 left = CrossProduct(Vector3(0,1,0), forward)        left.Normalize()        //现在构造摄像机矩阵        Vector3 eye = player.position + verticalOffset        Vector3 target = eye + actualOffset        //在这种情况下，我们可以传递向上向量，因为我们永远向上        cameraMatrix = CreateLookAt(eye, target, Vector3(0,1,0))    endend</code></pre><h2 id="5-样条摄像机"><a href="#5-样条摄像机" class="headerlink" title="5.样条摄像机"></a>5.样条摄像机</h2><p><strong>样条</strong>可以看作曲线，用线上的点定义。样条在游戏中很常见，因为使用它进行插值能够在整条曲线上得到平滑的效果。</p><p>有很多种不同的样条，最简单的一种是Catmull-Rom样条。这种样条允许邻近的点插值。这种样条允许邻近的点插值，这些点里面有一个控制点在前、两个激活点在后。如下图，P1和P2就是激活点(分别在t=0和t=1处)，而P0和P3就是在前面和后面等控制点。尽管图中只有4个点，但实际上是没有限制的。只要在前后加上控制点，曲线就可以无限延长下去。</p><p>给定4个控制点，这就可以计算t值介于0到1的所有样条，等式如下:</p><p>$$<br>p(t)=0.5·((2·P_1)+(-P_0+P_2)·t+(2·P_0-5·P_1+4·P_2-P_3)·t^2+(-P_0+3·P_1-3·P_2+P_3)·t^3)<br>$$</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/23/Xu1N2acdqLY4oWE.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 最小定点数的Catmull-Rom样条</div></center><p>注意这个等式要在控制点均匀间距的情况下使用。在任何情况下，有了这个等式，一个简单的支持任意数量点的Catmull-Rom样条类实现方法如下:</p><pre><code>class CRSpline    //Vector3的数组(动态数组)    Vector controlPoints    //第一个参数为t=0对应的控制点    //第二个参数为t值    function Compute(int start, float t)        //检查start - 1、start、start + 1以及start + 2都要存在        ···        Vector3 P0 = controlPoints[start - 1]        Vector3 P1 = controlPoints[start]        Vector3 P2 = controlPoints[start + 1]        Vector3 P3 = controlPoints[start + 2]        //使用Catmull-Rom公式计算位置        Vector3 position = 0.5 * ((2*P1)+(-P0+P2)*t+(2*P0-5*p1+4*P2-P3)*t*t+(-P0+3*P1-3*P2+P3)*t*t*t)        return position    endend</code></pre><p>这个公式也可以用数值微分的方式计算t介于0到1之间的切线。</p><p>如果摄像机跟着样条走，那么切线就能够表示摄像机的朝向。提供了样条路劲而且不允许摄像机上下颠倒，所以在有了位置和朝向之后，就可以构造摄像机矩阵了。</p><pre><code>//样条摄像机class SplineCamera    //摄像机跟随的样条路径    CRSpline path    //当前控制点索引及t值    int index    float t    //speed是t每秒变化率    float speed    //摄像机矩阵    Matrix cameraMatrix    //给定当期索引和t，计算计算机矩阵    function ComputeMatrix()        //eye就是样条所在的t及index对应的位置        Vector3 eye = path.Compute(index, t)        //给出一个稍微前一点的点        Vector3 target = path.Compute(index, t + 0.05f)        //假定y轴朝上        Vector3 up = Vector3(0,1,0)        cameraMatrix = CreateLookAt(eye, target, up)    end    function Update(float deltaTime)        t += speed * deltaTime        //如果t&gt;=1.0f，我们可以移动到下一个控制点        //这里代码假设速度不会太快，以至于一帧就超过两个控制点        if t &gt;= 1.0f            index++            t = t - 1.0f        end        //应该检查Index+1和Index+2是否为有效点        //如果不是，这样样条就完成了        ···        ComputeMatrix()    endend</code></pre><h1 id="四、摄像机支持算法"><a href="#四、摄像机支持算法" class="headerlink" title="四、摄像机支持算法"></a>四、摄像机支持算法</h1><p>为了实现更好的摄像机，还要考虑额外的支持算法。</p><h2 id="1-摄像机碰撞"><a href="#1-摄像机碰撞" class="headerlink" title="1.摄像机碰撞"></a>1.摄像机碰撞</h2><p><strong>摄像机碰撞</strong>致力于解决很多类型摄像机都有的问题，那是在摄像机与目标之间有一个不透明物体的时候。最简单的方法(但不是最佳的)就是从目标位置向摄像机位置进行光线投射。如果光线碰撞到任何物体，可以让摄像机移动到阻挡摄像机的物体前面。一个更好的方法是做一个物理对象表示摄像机。</p><p>另外一个问题是在摄像机太过靠近目标的时候。因为，近平面就在摄像机前面一点点，意味着太近的摄像机会让对象消失一部分。一个流行的解决方案是让对象在摄像机太过靠近的时候完全消失或者淡出。</p><h2 id="2-拣选"><a href="#2-拣选" class="headerlink" title="2.拣选"></a>2.拣选</h2><p><strong>拣选</strong>就是通过点击的方式选择3D世界中物体的能力。拣选在RTS游戏中很常见。</p><p>将一个点从世界空间变换到投影空间，它必须乘以一个摄像机矩阵，再乘以一个投影矩阵。但是，鼠标的位置是屏幕空间上的一个2D点。我们要做的是将这个2D点从屏幕空间变换回世界空间去，称之为<strong>反投影</strong>。为了实现反投影，我们需要一个矩阵可以做逆向矩阵变换操作。对于以行为主的表示，我们需要摄像机矩阵乘以投影矩阵的逆矩阵:</p><p>$$<br>unprojection=(camera \times projection)^{-1}<br>$$</p><p>但是2D点不能乘以4x4矩阵，所以在这个点乘以矩阵之前，我们必须将其转换到齐次坐标系。这就需要将z和w分量添加到2D点上。z分量通常设为0或1，取决于该点是放置在近平面还是远平面。而作为一个顶点，w分量总为1。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·物理</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-wu-li/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-wu-li/</url>
      
        <content type="html"><![CDATA[<p>物理都会实现碰撞和运动，但不是所有游戏都需要物理。碰撞检测用于检测两个游戏对象是否相互交错在一起。有大量的算法可以检测碰撞。</p><p>物理学中的运动部分会考虑作用力、加速度、质量等，以及其他经典力学中用到的属性，用于判断物体每帧的取向。为了做到这样，必须用到微积分，主要是数值积分法。</p><h1 id="一、平面、射线和线段"><a href="#一、平面、射线和线段" class="headerlink" title="一、平面、射线和线段"></a>一、平面、射线和线段</h1><h2 id="1-平面"><a href="#1-平面" class="headerlink" title="1.平面"></a>1.平面</h2><p>平面是平的，在二维上无限延伸，就如同线可以在一维空间无限延伸一样。在游戏中，我们通常用平面作为地面和墙体的抽象。一个平面可以有多种表示方法，但是通常游戏程序员会倾向于用以下表示:</p><p>$$<br>P·\hat{n}+d=0<br>$$</p><p>P是平面上任意一点，$\hat{n}$是平面法线，d是平面到原点的最小距离。</p><p>可以用平面上两个向量叉乘得到法线后，再代入顶点值得到d值。然后将这些值存储在我们的Plane数据结构体内:</p><pre><code>struct Plane    Vector3 normal    float dend</code></pre><h2 id="2-射线和线段"><a href="#2-射线和线段" class="headerlink" title="2.射线和线段"></a>2.射线和线段</h2><p><strong>射线</strong>就是从某个点开始出发，朝某个方向无限延伸。在游戏中，通常用参数方程表示射线。参数方程是借助其他参数来表达的，一般称之为t。对于射线来说，参数方程如下:</p><p>$$<br>R(t)=R_0+\overrightarrow{v}t<br>$$</p><p>$R_0$就是起点，而$\overrightarrow{v}$就是射线穿越的方向。由于射线是从某点开始，然后朝着某个方向无限延伸，为了让射线表达式顺利工作，t必须大于等于0。就是说当t为0时，这个参数方程在起点$R_0$就停了。</p><p><strong>线段</strong>与射线类似，除了即有起点又有终点之外。我们可以使用完全同样的参数方程来表示线段。唯一不同的地方就是现在t有了上限，因为线段必须有一个终点。</p><p>技术上来讲，<strong>光线投射</strong>就是射出一条射线，然后检查是否打到某个对象。但是，大多数物理引擎都会由于实际上使用的是线段做检测的方法让人迷惑，包括Havok和Box2D。这么做的原因是游戏世界通常都会有一定的约束，所以使用线段更加合理。</p><p>光线投射在3D游戏中几乎无处不在。举个常见的粒子就是发射一颗子弹穿过一条直线，虽然一些游戏采用弹道模拟的方式计算子弹弹道，但是采用光线投射也差不多，因为子弹运行得很快。还有其他的光线投射应用，包括根据敌友变色、AI判断敌人是否可见、Fresnel声学衍射、鼠标选取物品。所有这些场景都可以使用光线投射。</p><p>由于光线投射要求使用线段，我们至少需要两个参数——线段的起点和终点:</p><pre><code>struct RayCast    Vector3 startPoint    Vector3 endPointend</code></pre><h1 id="二、碰撞几何体"><a href="#二、碰撞几何体" class="headerlink" title="二、碰撞几何体"></a>二、碰撞几何体</h1><p>在现代3D游戏中，人形角色拥有15000以上条边的多变形很常见。当游戏需要判断两个角色是否碰撞时，检查所有三角片的碰撞效率不会很高。正因如此，大多数游戏都使用简化的几何体做碰撞检测，比如球体、盒子。这些碰撞几何体不会绘制到屏幕上，只是用于提高碰撞检测的速度。</p><p>值得一提的是，游戏对象拥有多个不同级别的碰撞几何体也是很常见的。这样，简单的碰撞体可以先进行第一轮碰撞检测。在简单的碰撞体发生了碰撞之后，再选择更精细的碰撞体进一步检测碰撞。</p><h2 id="1-包围球"><a href="#1-包围球" class="headerlink" title="1.包围球"></a>1.包围球</h2><p>最简单的碰撞体就是包围球(在2D游戏中则是包围圈)。一个球体可以通过两个变量定义——向量表示球体的中心点，标量表示球体的半径:</p><pre><code>class BoundingSphere    Vector3 center    float radiusend</code></pre><p>多种物体，比如小行星会在球体内包围，适配得很好。但是其他类型的物体，包括人形角色，则会留出很多空间。这意味着有很多类型的物体使用球形包围体会有很多<strong>漏报(false positive)</strong>。就是说两个游戏对象的包围体发生碰撞，但是两个物体自身还没有碰撞。</p><p>由于包围球对大多数游戏对象都不够精准，使用包围球作为唯一碰撞体是不合理的。但是包围球的优势就是进行碰撞检测非常简单，所以这种碰撞体是个不错的候补。</p><h2 id="2-轴对齐包围盒"><a href="#2-轴对齐包围盒" class="headerlink" title="2.轴对齐包围盒"></a>2.轴对齐包围盒</h2><p>对于2D游戏来说，一个<strong>轴对齐包围盒</strong> (缩写AABB)就是一个每条边都平行于x轴或者y轴的矩阵。类似地，在3D游戏中，AABB就是长方体，而且每条棱都与对应的轴平行。不管2D还是3D，AABB都可以用两个点表示:最大点和最小点。在2D中，最小点就是左下角的点，而最大点则是右上角的点。</p><pre><code>class AABB2D    Vector min    Vector maxend</code></pre><p>由于AABB必须与对应的轴平行，如果一个对象旋转，那么AABB就需要相应变化。但是对于3D游戏来说，人形角色通常只绕向上的轴旋转，这种旋转并不会让AABB有太多的变化。因此，使用AABB作为人形角色的包围体是很常见的，特别是AABB和球体之间的碰撞计算量很小。</p><h2 id="3-朝向包围盒"><a href="#3-朝向包围盒" class="headerlink" title="3.朝向包围盒"></a>3.朝向包围盒</h2><p>一个<strong>朝向包围盒</strong> (或者OBB)类似于轴对齐包围盒，只是不再要求与轴平行。就是说，这是一个长方形(2D)或者长方体(3D),而且每条轴不再需要与之对应的坐标轴平行。OBB的优点就是可以随着游戏对象渲染，因此不管游戏对象的朝向如何，OBB的精准度很高，同时计算花费也很高。OBB在游戏中有多种表示方式，包括用8个顶点或者6个平面。</p><h2 id="4-胶囊体"><a href="#4-胶囊体" class="headerlink" title="4.胶囊体"></a>4.胶囊体</h2><p>在2D游戏中，胶囊体可以看作是一个AABB加上两端各一个半圆。之所以较胶囊体是因为看上去就跟药物胶囊一样。如果我们把胶囊体扩展到3D，就会变成一个圆柱加上两端一个半球。胶囊体在人形角色的碰撞体表示中是很流行的，因为他们比AABB精准一些。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/zo2KM8kXPDY9NOh.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 被胶囊体包围的人形(a)和被凸多边形包围的椅子(b)</div></center><p>胶囊体还可以看作带半径的线段，在游戏引擎中就是这么表示的:</p><pre><code>struct Capsule2D    Vector2 startPoint    Vector2 endPoint    float radiusend</code></pre><h2 id="5-凸多边形"><a href="#5-凸多边形" class="headerlink" title="5.凸多边形"></a>5.凸多边形</h2><p>另一个碰撞几何体表示的选择就是使用<strong>凸多边形</strong>(在3D领域称之为<strong>凸包</strong>)。凸多边形比其他方式效率都要低，但是比它们都精准。虽然还是有很多漏报，但是漏报的情况比其他方式都要好。</p><h2 id="6-组合碰撞几何体"><a href="#6-组合碰撞几何体" class="headerlink" title="6.组合碰撞几何体"></a>6.组合碰撞几何体</h2><p>最后一个增加精准度的选择就是使用<strong>组合碰撞几何体</strong>进行碰撞检测。在人形的粒子中，我们可以在头部使用球形，身干用AABB，凸多边形用于手脚等。通过不同的碰撞几何体组合，我们几乎可以消灭漏报。</p><p>不过检测碰撞几何体组合还是慢的让人不想用。事实上，在人形的例子中，应该先用AABB或者胶囊体进行第一轮碰撞检测，然后通过之后再进行更精确的测试，比如组合碰撞几何体。这种方法取决于你是否需要将精准度分级别。在检测子弹是否打中角色的时候会用到，但是阻挡玩家走进墙里就没必要了。</p><h1 id="三、碰撞检测"><a href="#三、碰撞检测" class="headerlink" title="三、碰撞检测"></a>三、碰撞检测</h1><h2 id="1-球与球的交叉"><a href="#1-球与球的交叉" class="headerlink" title="1.球与球的交叉"></a>1.球与球的交叉</h2><p>如果两个球的半径之和小于两个球之间的距离，那么就发生了交叉。但是，计算距离会用到平方根，为了避免平方根的比较，通常都会使用距离的平方与半径之和的平方进行比较。这个算法只用几行代码，效率非常高，用它作为基本的碰撞体很常见。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/zbsiDpW6k1LwUyo.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 两个球交叉(a)和没有交叉(b)</div></center><pre><code>function SphereIntersection(BoundingSphere a, BoundingSphere b)    //构造两个中心点的向量，然后求长度的平方    Vector3 centerVector = b.center - a.center    //v的长度平方等于v点乘v    float distSquared = DotProduct(centerVector, centerVector)    //distSquared是否小于半径和的平方?    if distSquared &lt; ((a.radius + b.radius) * (a.radius + b.radius))        return true    else        return false    endend</code></pre><h2 id="2-AABB与AABB交叉"><a href="#2-AABB与AABB交叉" class="headerlink" title="2.AABB与AABB交叉"></a>2.AABB与AABB交叉</h2><p>如同球体交叉一样，AABB的交叉计算即使在3D游戏中也是很廉价的。2D中的AABB看起来会容易一些。</p><p>当检测两个2D的AABB交叉的时候，检测没交叉比检测有交叉要容易些。4中没交叉的情况如下。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/eSthkJZb5GOD7iC.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 两个AABB完全没有交叉的4种情形</div></center><pre><code>function AABBIntersection(AABB2D a, AABB2D b)    bool test = (a.max.x &lt; b.min.x) || (b.max.x &lt; a.min.x) || (a.max.y &lt; b.min.y) || (b.max.y &lt; a.min.y)    return !testend</code></pre><h2 id="3-线段与平面交叉"><a href="#3-线段与平面交叉" class="headerlink" title="3.线段与平面交叉"></a>3.线段与平面交叉</h2><p>检测线段是否与平面碰撞在游戏中很常见。先来理解一下背后的线性代数。首先，我们有线段和平面的两个等式:</p><p>$$<br>R(t)=R_0+\overrightarrow{v}t<br>$$</p><p>$$<br>P·\hat{n}+d=0<br>$$</p><p>我们想判断是否存在一个值t，使得点落在平面上。换句话说，我们想判断是否存在t值，使得$R(t)$满足平面等式中$P$的。索引将$R(t)$代入$P$:</p><p>$$<br>R(t)·\hat{n}+d=0<br>$$</p><p>$$<br>(R_0+\overrightarrow{v}t)·\hat{n}+d=0<br>$$</p><p>解出t的值:</p><p>$$<br>R_0·\hat{n}+(\overrightarrow{v}·\hat{n})t+d=0<br>$$</p><p>$$<br>(\overrightarrow{v}·\hat{n})=-(R_0·\hat{n}+d)<br>$$</p><p>$$<br>t=\frac{-(R_0·\hat{n}+d)}{\overrightarrow{v}·\hat{n}}<br>$$</p><p>线段的起点对应于t=0，而终点则对应于t=1。所以当我们解出t时，如果t的值在这个范围外，那么可以忽略它。特别的是，复制表示线段朝向远离平面的方向。</p><p>还有要考虑$\overrightarrow{v}$与$\hat{n}$点乘结果为0的情况，会产生除0异常。这种情况就是线段与平面平行，唯一交叉的情况就是线段在平面上。</p><pre><code>//返回值就是这个结构体struct LSPlaneReturn    bool intersects    Vector3 pointend//记住光线投射实际上就是线段function LSPlaneIntersection(RayCast r, Plane p)    LSPlaneReturn retVal    retVal.intersects = false    //计算线段方程的v    Vector3 v = r.endPoint - r.startPoint    //检查线段是否与平面平行    float vDotn = DotProduct(v, p.normal)    if vDotn is not approximately 0        t = -1 * (DotProduct(r.startPoint, p.normal) + p.d)        t /= vDorn        //t应该介于起点和终点(0到1)之间        if t &gt;= 0 &amp;&amp; t &lt;= 1            retVal.intersects = true            //结算交点            retVal.point = r.startPoint + v * t        end    else        //测试起点是否在平面上        ...    end    return retValend</code></pre><h2 id="4-线段与三角片交叉"><a href="#4-线段与三角片交叉" class="headerlink" title="4.线段与三角片交叉"></a>4.线段与三角片交叉</h2><p>假设你需要算出用线段表示的子弹与某个三角片之间是否发生碰撞。第一步就是算出三角片所在的平面。在有了这个平面之后，你可以看看这个平面是否与线段相交。如果他们相交，你就会得到与三角形所在平面相交的交点。最后，由于平面是无限大的，我们要检测该点是否在三角片之内。</p><pre><code>//这个函数只能在顶点为顺时针顶点序及共面下正常工作function PointInPolygon(Vector[] verts, int numSides, Vector3 point)    //计算多边形的法线    Vector3 normal = CrossProduct(Vector3(verts[1] - verts[0]), Vector3(verts[2] - verts[1]))    normal.Normalize()    //临时变量    Vector3 side, to, cross    for int i = 1, i &lt; numSides, i++        //从上一个顶点到当前顶点        side = vertes[i] - verts[i-1]        //从上一个顶点到point        to = point - verts[i-1]        cross = CrossProduct(side, to)        cross.Normalize()        //表示在多边形外部        if DotProduct(cross, normal) &lt; 0            return false        end    loop    //必须检测最后一条边，就是最后一个顶点到第一个顶点    side = verts[0] - verts[numSides - 1]    to = point - verts[numsSides - 1]    cross = CrossProduct(side, to)    cross.Normalize()    if DotProduct(cross, normal) &lt; 0        return false    end    //在所有边内部    return trueend</code></pre><h2 id="5-球与平面交叉"><a href="#5-球与平面交叉" class="headerlink" title="5.球与平面交叉"></a>5.球与平面交叉</h2><p>在游戏中球可以与墙发生碰撞，为了对这个碰撞准确建模，可以使用球与平面的交叉。给定平面的$\hat{n}$和$d$，碰撞检测最简单的方法就是建立一个新的平面，对齐球心并且与原有平面平行。如果两个平面距离比球的半径要小，那么就发生了交叉。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/AHTdwVZIGjL7nux.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 球与平面不交叉的情况</div></center><pre><code>function SpherePlaneIntersection(BoundingSphere s, Plane p)    //通过平面的法线p.normal及圆中心点s.center计算平面的d    float dSphere = -DotProduct(p.normal, s.center)    //检查是否在范围之内    return (abs(d-dSphere) &lt; s.radius)end</code></pre><h2 id="6-球形扫掠体检测"><a href="#6-球形扫掠体检测" class="headerlink" title="6.球形扫掠体检测"></a>6.球形扫掠体检测</h2><p>到目前为止，我们讲了<strong>即时碰撞检测</strong>算法。就是说那些算法只能检查当前帧中发生的碰撞。虽然很多情况下都有效，但是也有很多不适用的时候。</p><p>如果子弹朝着纸张发射，不存在子弹与纸张错在一起的准确的一帧。这是因为子弹速度很快，而纸张很薄。这个问题通常被称为<strong>子弹穿过纸张问题</strong>。为了解决这个问题，能够进行<strong>连续碰撞检查</strong>(CCD)的能力是必要的。这里只讨论其中一种CCD技术。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/5rzE3KYlCGdetmA.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 子弹穿过纸张问题</div></center><p>在<strong>球形扫掠体检测</strong>中，有两个移动中的球体。而输入则是两个球在上一帧的位置(t=0)和这一帧的位置(t=1)。给定这些数据，我们可以判断两帧之间两个球是否发生了碰撞。</p><p>球形扫掠体看上去和胶囊体差不多。那是因为球形扫掠体确实就是胶囊体。球形扫掠体有起点、终点及半径，完全就是一个胶囊体。所以胶囊体与胶囊体的碰撞完全可以在这里使用。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/NeqRZDMKmjS9U8t.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 球形扫掠体检测</div></center><p>给定球体的上一帧和这一帧的位置，就可以将球的位置转换为参数方程。这个转换得到的函数可以用于光线投射。多以给定球P和球Q，我们可以用两个参数方程表示:</p><p>$$<br>P(t)=P_0+\overrightarrow{v_p}t<br>$$</p><p>$$<br>Q(t)=Q_0+\overrightarrow{v_q}t<br>$$</p><p>我们想要求的是t，t就是两个球距离等于半径之和的时候。这里就不详细列出推导过程。最后结论就是</p><p>$$<br>t=\frac{-b\pm\sqrt{b^2-4ac}}{2a}<br>$$</p><p>其中</p><p>$$<br>a=(\overrightarrow{v_p}-\overrightarrow{v_q})·(\overrightarrow{v_p}-\overrightarrow{v_q})<br>$$</p><p>$$<br>b=2(P_0-Q_0)·(\overrightarrow{v_p}-\overrightarrow{v_q})<br>$$</p><p>$$<br>c=(P_0-Q_0)·(P_0-Q_0)-(r_p+r_q)^2<br>$$</p><p>平方跟下的值$b^2-4ac$，我们称之为为判别式。如果小于0，t就没有实根，就是说没有交叉发生。如果等于0，意味着两个球相切。如果大于0，则意味着交叉。</p><p>在我们解出t的值以后，记住t值如果大于1则是这一帧之后，如果小于0则是这一帧之前。因此，t值超出范围的情况不是这个函数接受的范围。</p><pre><code>//p0/q0是上一帧的球体//p1/q1是这一帧的球体function SweptSphere(BoundingSphere p0, BoundingSphere q0, BoundingSphere p1, BoundingSphere q1)    //首先计算v用于参数方程    Vector3 vp = p1.center - p0.center    Vector3 vq = q1.center - q0.center    //计算A和B    //A = p0 - q0    Vector3 A = p0.center - q0.center    //B = vp - vq    Vector3 B = vp - vq    //计算a、b和c    //a=B dot B    float a = DotProduct(B, B)    //b=2(A dot B)    float b = 2 * DotProduct(A, B)    //c=(A dot A) - (rp + rq)*(rp + rq)    float c = DotProduct(A, A) - ((q0.radius + p0.radius) * (q0.radius + p0.radius))    //现在计算判别式(b^2 - 4ac)    float disc = b * b - 4 * a * c    if disc &gt;= 0        //如果我们需要t的值，我们可以用以下的方式解出:        //t = (-b - sqrt(disc) / (2a))        return true    else        return false    endend</code></pre><h2 id="7-响应碰撞"><a href="#7-响应碰撞" class="headerlink" title="7.响应碰撞"></a>7.响应碰撞</h2><p>我们可以使用前面提到的各种算法来检测碰撞。但是在检测结果出来之后，游戏应该如何处理？这就是<strong>响应</strong>碰撞的问题。一些情况下，响应会很简单：一个或多个对象可能会死亡然后从游戏世界中移除。稍微复杂一点的响应就是一些减少生命值之类的响应。</p><p>但是如果两个对象需要相互弹开呢？比如两个小行星碰撞。一个简单的解决方法就是根据碰撞的方向让速度反向。但这样做会有很多问题。一个问题就是行星会被卡住。简单来说，就是两个行星在速度很慢的情况下某一帧发生碰撞，下一帧还有可能发生碰撞，那么就会陷入死循环中。</p><p>解决方案就是用包围球包围行星来进行碰撞检测，然后再根据发生碰撞的平面的法线将速度进行反射。碰撞的平面即是碰撞点的切线平面。</p><p>为了构造切线平面，我们首先要得到发生碰撞的点。这个可以用线性插值算出。如果有两个球体在某个点发生碰撞，这个点肯定就在两个球心所连成的线段上。它所在的位置就取决于两个球的半径。</p><pre><code>Vector3 pointOfIntersection = Lerp(A.position, B.position, A.radius / (A.radius + B.radius))</code></pre><p>而找出切线平面也很简单，就是一个球心指向另一个球心的向量，然后正规化。有了平面上的点和平面的法线，我们就可以创建在这个碰撞点上的切线平面了。虽然碰撞相应需要对速度进行反射，但是我们只要有平面的法线就可以了。</p><p>有了这个反射之后的速度，行星碰撞看上去好多了，虽然看上去还是很奇怪，因为行星的反射前后都会保持恒定速度。在现实中，两个对象碰撞的时候，有一个<strong>恢复系数</strong>，衡量两个物体在碰撞后的反弹程度:</p><p>$$<br>C_R=\frac{碰撞后的相对速度}{碰撞前的相对速度}<br>$$</p><p>在<strong>弹性</strong>碰撞($C_R&gt;1$)的情况下，碰撞后的相对速度大于碰撞前的相对速度。在另一方面，在<strong>无弹性</strong>碰撞($C_R&lt;1$)就会导致碰撞后相对速度更低。</p><h2 id="8-优化碰撞"><a href="#8-优化碰撞" class="headerlink" title="8.优化碰撞"></a>8.优化碰撞</h2><p>我们讨论的所有碰撞检测算法都只能检测一对物体间的碰撞。一个可能会遇到的问题是，如果有大量的物体需要进行碰撞检测呢？所以必须对游戏世界进行分区，这样主角只要跟所在区域的对象进行碰撞检测就可以了。2D游戏中的一种分区方法就是<strong>四叉树</strong>，游戏世界会递归切割成矩形，直到每一个叶子节点只引用一个对象。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/rEJXwSQIgtA4jhm.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 四叉树，字母表示游戏世界中的对象</div></center><p>在进行碰撞检测的时候，程序会先检测最外层的四叉树矩形中的玩家所在象限的对象是否与玩家发生了碰撞，这样就立刻剔除了3/4的对象。然后这个递归算法会不断进行下去，直到找到所有潜在与玩家发生碰撞的对象。在只剩下少数的对象之后，就可以对每个对象进行碰撞体检测了。</p><p>四叉树不是唯一的分区方法。还有很多方法，比如二进制空间分割(BSP)及八叉树(3D版的四叉树)。大多数算法都是基于空间的，还有一些是启发式分组的。</p><h1 id="四、基于物理的移动"><a href="#四、基于物理的移动" class="headerlink" title="四、基于物理的移动"></a>四、基于物理的移动</h1><p>本节聚焦于牛顿物理最基础的部分：<strong>线性力学</strong>。就是没有旋转的运动。</p><h2 id="1-线性力学概览"><a href="#1-线性力学概览" class="headerlink" title="1.线性力学概览"></a>1.线性力学概览</h2><p>线性力学的两个基石是力与质量。<strong>力</strong>是一种相互作用，可以导致物体运动。力有着方向和大小，因此可以用向量表示。<strong>质量</strong>表示物体所含物质的量。对于力学来说，主要的关系是质量越大，物体就越难运动。</p><p>如果一个足够大的力作用到物体身上，理论上它会开始加速。这个想法就是牛顿第二定律:</p><p>$$<br>F=m·a<br>$$</p><p>这里，F是力，m是质量，a是加速度。由于力等于质量点乘加速度，所以加速度可以通过力除以质量得到。给定一个力，这个等式就可以计算出加速度。</p><p>在游戏中，我们希望每一帧都通过加速度算出速度和位置，这意味着要使用<strong>数值积分</strong>，一种可以每帧都使用其计算积分近似值的方法。</p><h2 id="2-可变时间步长带来的问题"><a href="#2-可变时间步长带来的问题" class="headerlink" title="2.可变时间步长带来的问题"></a>2.可变时间步长带来的问题</h2><p>在使用数值积分之后，你就或多或少地不能使用可变的时间帧。这是因为数值积分的准确性取决于时间步长。步长越短就越精确。</p><p>这意味着如果每帧的时间步长都改变，近似值也会每帧变动。如果准确性改变，行为也会有显著的变化。数值积分的百分比误差会在低帧率的时候放大了，所以跳得更高了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/15/WXSZGcom6d895gD.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 不同时间步长带来不同的跳跃轨迹</div></center><p>由于这个原因，任何游戏使用物理计算位置的时候，都不要使用可变的时间步长。物理计算用可变步长当然是可以的，但是这样就会很复杂。</p><h2 id="3-力的计算"><a href="#3-力的计算" class="headerlink" title="3.力的计算"></a>3.力的计算</h2><p>数值积分让我们可以由加速度算出速度，然后由速度算出位置。但是为了算出加速度，我们需要力和质量。这里有多种多样的力需要考虑。有些力，比如重力，一直作用在物体身上。而有些力可以用<strong>冲量</strong>替代，就是那些只在一帧起作用的力。在游戏中最常见的做法就是算出所有的合力，然后除以质量算出加速度：</p><p>$$<br>加速度=合力/质量<br>$$</p><h2 id="4-欧拉和半隐式欧拉积分"><a href="#4-欧拉和半隐式欧拉积分" class="headerlink" title="4.欧拉和半隐式欧拉积分"></a>4.欧拉和半隐式欧拉积分</h2><p>最简单的数值积分就是<strong>欧拉积分</strong>，在欧拉积分中，新的位置是由旧的位置加上速度乘以时间步长得到，然后速度以类似的方式通过加速度算出来</p><pre><code>class PhysicsObject    //物体上所有作用力    List forces    Vector3 acceleration, velocity, position    float mass    function Update(float deltaTime)        Vector3 sumOfForce = sum of forces in forces        acceleration = sumOfForce / mass        //欧拉积分        position += velocity * deltaTime        velocity += acceleration * deltaTime    endend</code></pre><p>虽然欧拉积分很简单，它并没有真正表现得非常准确。一个大问题就是位置是用旧的速度算出来的，而不是时间步长之后的新速度。这样会随着时间的推移让误差不断地积累。</p><p>一个简单的改法就是将欧拉积分的位置和速度更新顺序调换。就是说现在位置是使用新的速度来计算。这就是<strong>半隐式欧拉积分</strong>，会更加合理和稳定。但如果要更加准确，就得使用更复杂的数值积分方法。</p><h2 id="5-Verlet积分法"><a href="#5-Verlet积分法" class="headerlink" title="5.Verlet积分法"></a>5.Verlet积分法</h2><p>在<strong>Verlet积分法中</strong>，首先算出本次时间步长中点的速度值。然后将它看作平均速度计算整个步长的位置。然后，加速度根据力和质量计算出来，最终利用新的加速度在步长结束的时候计算出速度。</p><pre><code>function Update(float deltaTime)    Vector3 sumOfForces = sum of forces in forces    //Verlet积分法    Vector3 avgVelocity = velocity + acceleration * deltaTime / 2.0f    //位置用平均速度算出来    position += avgVelocity * deltaTime    //计算新的加速度和位置    acceleration = sumOfForces / mass    velocity = avgVelocity + acceleration * deltaTime / 2.0fend</code></pre><p>本质上Verlet积分法使用平均速度计算位置。这比起两种欧拉积分都要准确得多，同时也更加昂贵。</p><h2 id="6-其他积分方法"><a href="#6-其他积分方法" class="headerlink" title="6.其他积分方法"></a>6.其他积分方法</h2><p>还有不少其他忽略吧方法会在游戏中用到，但是它们有点复杂。它们当中最受欢迎的方法是四阶Runge-Kutta方法。它本质上是使用泰勒近似求解的结果表示运动的微分方程的近似解。这个方法比上述两种方法都要准确，但也更慢。</p><h2 id="7-角力学"><a href="#7-角力学" class="headerlink" title="7.角力学"></a>7.角力学</h2><p><strong>角力学</strong>是关于旋转的力学研究。就像线性力学有质量、作用力、加速度、速度、位置一样，角力学有转动惯量、力矩、角加速度、角速度和角度。角力学的机制比线性力学还要复杂一点。</p><h1 id="五、物理中间件"><a href="#五、物理中间件" class="headerlink" title="五、物理中间件"></a>五、物理中间件</h1><p>物理问题的复杂度和广度使得大多数游戏都会选择采用中间件而不是自己实现。</p><p>3D游戏最流行的商业屋里引起，毫无疑问就是Havok物理引擎。还有一个可选的工业级别的物理引擎就是PhysX。</p><p>对于2D物理引擎来说，目前最流行的是开源的Box2D。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·声音</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-sheng-yin/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-sheng-yin/</url>
      
        <content type="html"><![CDATA[<p>本章首先讲如何将原始数据转换成代码控制的音效。然后讨论更高级的声音技术，比如多普勒效应、数字信号处理和音效遮挡，它们都会在很多情况下用到。</p><h1 id="一、基本声音"><a href="#一、基本声音" class="headerlink" title="一、基本声音"></a>一、基本声音</h1><p>声音播放最基础的级别就是在游戏某个时刻播放某个音频文件。但是在多数情况下一个事件不是必须对应到一个声音上的。比如角色每次脚碰地设置多种脚步声随机选择播放。</p><p>还有一个要考虑的事情就是只有有限数量的<strong>频道</strong>可以同时播放。假如一个游戏有大量的敌人在玩家附近奔跑，如果全部都播放脚步声，那么有可能将所有的频道用完。有很多声音比敌人的脚步声更重要，因此我们需要将音效进行优先级排序。大多数游戏都存储了一组额外的数据描述了音频文件的优先级。</p><h2 id="1-原始数据"><a href="#1-原始数据" class="headerlink" title="1.原始数据"></a>1.原始数据</h2><p><strong>原始数据</strong>是指音效设计师使用类似Audacity这样的工具来创建的最原始的音频文件。一个常见的方式为将短音效存储为WAV格式或者其他无压缩文件格式，而存储长音效，比如声音或者对话，则会采用压缩格式比如MP3或者OGG。</p><p>当在游戏中需要播放这些声音文件时，通常由两种方法。一种方法是让场景预加载短音效文件到内存中，这样到了播放声音的时刻就不再需要花时间到硬盘加载了。而另一种方法，由于压缩的声音或者对话文件通常会有更大的体积，通常会以<strong>6流</strong> 的方式加载。</p><h2 id="2-声音事件"><a href="#2-声音事件" class="headerlink" title="2.声音事件"></a>2.声音事件</h2><p><strong>声音事件</strong>映射了一个或者多个原始数据文件。声音事件事实上是由代码触发的。所以比起直接播放fs1.wav，可能调用一个叫“footstep”的声音事件会更好。这个想法就是声音事件可以包含多个声音文件同时还能有元数据，将这些声音文件作为整体。</p><h1 id="二、3D声音"><a href="#二、3D声音" class="headerlink" title="二、3D声音"></a>二、3D声音</h1><p>大多数2D音效都是位置无关的。但是对于3D音效和3D游戏来说，音源的位置就特别重要。大多数音效都有自己独特的随着<strong>监听者</strong>距离增大衰减的方式。</p><h2 id="1-监听者和发射者"><a href="#1-监听者和发射者" class="headerlink" title="1.监听者和发射者"></a>1.监听者和发射者</h2><p>不管监听者怎么监听游戏世界中的音效，<strong>发射者</strong>就是发射特定音效的物体。比如说，如果有一堆柴火发出噼里哗啦的声音，就会有一个声音发射器放在哪个位置然后发出噼里啪啦的声音。然后基于监听者和火柴声的发射者之间的距离就可以算出音量的大小。发射者相对于监听者的朝向决定了哪个喇叭有声音。</p><p>由于监听者回监听所有3D世界中的声音，所以摆放监听者的位置和朝向就很重要。如果监听者摆设不对，3D声音系统会有问题——要么声音太小或者太大，要么喇叭出声音的方向不对。</p><p>对于很多种游戏来说，直接使用摄像机的位置和朝向就可以了。但是有些游戏却不适用，比如第三人称动作游戏。</p><p>如果监听者与摄像机在同一个位置，这个声音听起来就像在几米或几十米外。简单的解决方法就是将监听者的位置和朝向设置到角色身上。但会有一个更大的问题，可能会导致喇叭出声音的方向不对。简单来说就是，会发生发射器在玩家的左侧，而在摄像机的右侧的情况，声音就可能会从左边的喇叭出来，这样就会看起来不正确。因为我们看到了爆炸在屏幕的右侧发生就会预期在右侧的喇叭播放爆炸声，而不管玩家的朝向。</p><p>在游戏《指环王:征服》中，开发者做了一定的妥协。首先就是我们让监听者的朝向等于摄像机的朝向，而不是等于角色的朝向。接着，与监听者位置准确地摆放在玩家身上或者摄像机身上不同，他们放在了两者之间。换句话说，监听者的位置就是摄像机位置和角色位置的差值结果。两者间的百分比通常介于33%和66%之间都能有不错的效果。</p><h2 id="2-衰减"><a href="#2-衰减" class="headerlink" title="2.衰减"></a>2.衰减</h2><p><strong>衰减</strong>描述了音效的音量随着远离监听者会如何减小，可以用任何可能的函数去表达衰减。但是，由于音量的单位<strong>分贝</strong>是一个对数刻度，线性衰减会产生对数变换关系。这种线性分贝衰减函数通常都是默认方法，但是显然不是唯一的方法。</p><h2 id="3-环绕声"><a href="#3-环绕声" class="headerlink" title="3.环绕声"></a>3.环绕声</h2><p>不少平台都不支持环绕声的概念——大多数移动设备最多只支持立体声。但是，PC和家用机游戏是可以有两个以上喇叭的。在<strong>5.1环绕系统</strong>中，会有总共5个正式的喇叭和1个用于表现低频效果的低音炮。5.1配置的优点就是会感受到更多方向的声音。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/14/ihmjcQ84PCpXreD.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 一个标准的5.1环绕声配置</div></center><h1 id="三、数字信号处理"><a href="#三、数字信号处理" class="headerlink" title="三、数字信号处理"></a>三、数字信号处理</h1><p>广义上讲，<strong>数字信号处理</strong> (DSP)是计算机中表示的信号。在音频领域中，数字信号处理说的是加载音频文件然后在修改之后得到不同的效果。简单例子就是加载音频文件然后增加或减小它的音高。</p><p>看起来离线处理好这些效果，然后在游戏中播放也许会更好。但是运行时使用数字信号处理理由就是它能够节省大量内存。假如有一款剑击游戏，有20多种在野外开阔场地录制的武器碰撞音效。如果游戏中有多种场地会发出声音，除了野外之外，还有洞穴、大教堂等等其他地方。</p><p>这时候，在洞穴中发出的声音和在野外发出等声音听起来完全不一样。特别是在洞穴中，会有<strong>回声</strong>的效果。不用数字信号处理的话，那就得为20多种刀剑声针对不同场地录制成倍的音效。现在如果需要所有战斗音效，游戏内存很快就会被用尽。但是如果有了数字信号处理效果，就只需要根据场所调整成相应的音效即可。</p><p>实现数字信号处理需要线性系统和高级数学运算的知识，比如傅里叶变换。</p><h2 id="1-常见数字信号处理效果"><a href="#1-常见数字信号处理效果" class="headerlink" title="1. 常见数字信号处理效果"></a>1. 常见数字信号处理效果</h2><p>游戏中常见的数字信号处理效果就是之前提到的回声。一个非常流行的回声效果库叫做Freeverb3。Freeverb3是一个<strong>冲量驱动系统</strong>，就是说为了对任何音效实现回声效果，需要一个音频文件表达在特殊场景播放的数据。</p><p>另一个大量使用的数字信号处理效果就是<strong>音高偏移</strong>，特别是多普勒偏移。音高偏移会通过调整频率增加或者减小音效的音高。多普勒偏移很常用，比如赛车游戏中引擎的音高会随着速度的变化而变化。</p><p>游戏中大多数的数字信号处理效果通常都会修改频率的范围或者输出分贝的级别。举个例子，一个<strong>压缩机</strong>缩小了音量的范围，导致很小的声音得到了增强，同时很大的声音得到了减小。通常用于统一多个音频文件，让它们保持相似的范围。</p><p>另一个例子是<strong>低通滤波器</strong>，通过删减频率的方式减小音量。在游戏中很常见的就是当玩家附近发生爆炸时的嗡鸣声。为了实现效果，时间会拉长，然后应用低通滤波器，接着播放嗡鸣声。</p><h2 id="2-区域标记"><a href="#2-区域标记" class="headerlink" title="2.区域标记"></a>2.区域标记</h2><p>通常只有关卡的一些区域才需要使用某些效果。比如说，如果一关里有野外区域和洞穴，回响效果可能只有在洞穴才会有。最简单的方式就是在地面上标记凸多边形。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/14/k5X3ZsFwbCfVdnv.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 凸多边形和凹多边形</div></center><p>使用凸多边形的原因就是，给定一个凸多边形我们更容易判断一个点在凸多边形内部还是外部。给定角色的位置，就很容易判断角色是在多边形内部还是外部。如果角色在区域内部，回响效果打开，在外部则关闭。</p><p>但是，我们不想玩家已进入区域就马上产生效果，否则效果会比较刺耳。这意味着，玩家进入标记区域之后，我们希望渐渐地开启回响效果，这样效果听上去更加平滑。</p><p>值得注意的是使用凸多边形标记区域会有一个问题。就是如果标记区域在关卡中上下重叠，而这些区域又有不同的数字信号处理效果，这个方法会失效。举例就是，上方有一篇草地，下方由一个隧道，都标记了凸多边形区域。这个问题可以使用绑定盒之类的方式来解决。</p><h1 id="四、其他声音话题"><a href="#四、其他声音话题" class="headerlink" title="四、其他声音话题"></a>四、其他声音话题</h1><h2 id="1-多普勒效应"><a href="#1-多普勒效应" class="headerlink" title="1.多普勒效应"></a>1.多普勒效应</h2><p>在街上，一辆警车打开警报器向你靠近时，随着警车的靠近声音变得尖细(即频率变高，波长变短)，相对的，在警车不断远离时，声音变得低沉(即频率变低，波长变长)。这种现象称为多普勒效应(或者称之为多普勒偏移)，原因是因为声波在空气中传播需要时间。靠近的时候，连续的声波都比前一个要早到，远离时，则是晚到。</p><p>有趣的是多普勒效应不仅在音波中出现，而是所有与波相关的情况中都会出现。例如光波。</p><p>在游戏中，动态多普勒效应只会在高速移动的对象身上应用，比如汽车。技术上来讲，也可以在子弹上应用，但是由于太快，通常只播子弹飞走的声音。可以使用数字信号处理效果来实现多普勒效应。</p><h2 id="2-声音遮挡"><a href="#2-声音遮挡" class="headerlink" title="2.声音遮挡"></a>2.声音遮挡</h2><p><strong>声音遮挡</strong>指的是当声音被障碍物遮挡住的时候，会有低通滤波的效果，意味着高频率声音的音量被移除了。这是因为低频率的音波比起高频率更容易传播。声音遮挡的另一个输出就是整体音量的降低。</p><p>相似但是不同的现象是<strong>声音衍射</strong>。通过声音衍射，声音可能不再是直线传播的了，但是还是有可能穿透障碍物。比如说，如果你朝柱子另一边的人大喊，声波会被柱子衍射，一个有趣现象是分割之后的音波可能会以不同的顺序到达，左边的音波可能比右边的音波早到，那么另一边人可能会听到两次声音。</p><p>检测遮挡和衍射的方法就是发射者构造一系列指向监听者附近的弧形。如果没有一个向量能直接到达，那就是遮挡。如果有一些向量能够到达，那么是衍射。如果全部都能到达，那么是<strong>Fresnel声学衍射</strong>。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/14/wqQ95fSU1yLt6KI.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 声音遮挡(a) 声音衍射(b) Fresnel声学衍射(c)</div></center><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·游戏输入</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-you-xi-shu-ru/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-you-xi-shu-ru/</url>
      
        <content type="html"><![CDATA[<p>没有输入，游戏就成为了一种静止的娱乐形式，就像电影和电视那样。当游戏响应键盘、鼠标、手柄等输入设备的时候，游戏才能够互动。</p><h1 id="一、输入设备"><a href="#一、输入设备" class="headerlink" title="一、输入设备"></a>一、输入设备</h1><p>目前市面上有各种各样的输入设备。绝大多数的输入形式可以分为两种：数字与模拟。<strong>数字</strong>形式的输入就是那些只有两种状态的:“按下”和“没有按”，比如键盘。<strong>模拟</strong>形式的输入就是设备可以返回某个数字的范围。一个常见的模拟设备就是摇杆，它会总是返回二维空间的范围值。</p><p>输入系统在其他方面要考虑的是游戏中对<strong>同时按键</strong>和<strong>序列按键</strong>的支持。这种需求在格斗游戏中很流行，玩家会经常同时使用按键和序列按键来搓招。</p><h2 id="1-数字输入"><a href="#1-数字输入" class="headerlink" title="1.数字输入"></a>1.数字输入</h2><p>通过类似于SDL的库，使得查询数字设备的当前状态成为可能。在一个这样的系统中，通常都会获取一组描述每个按键的布尔数组。所以，如果按下空格键，那么空格键对应的索引就被在数组位置中置为真。通常都会使用<strong>建码</strong>枚举来映射每个索引到按键的名字上。</p><h2 id="2-模拟输入"><a href="#2-模拟输入" class="headerlink" title="2.模拟输入"></a>2.模拟输入</h2><p>因为模拟设备有一组范围值，有输入偏差是很常见的。即一个摇杆有x值和y值来表示，如果放在平面上，玩家不去碰它，理论上x和y应该都为0。但是，实际上该值会在0的附近。</p><p>由于这个原因，很少会让模拟输入直接应用到角色的移动上，这会让角色永远停不下来。为了解决这个问题，大多数游戏都会采用某种<strong>模拟输入过渡</strong>的方式，用于消除输入的偏差值。这种过滤可以采用<strong>无效区域</strong>的方法实现，就是让摇杆输入在中心范围内无效。</p><p>一个简单的无效区域实现就是在x和y值接近0的时候直接设置为0。</p><pre><code>int deadZone = 3000Vector2 joy = get joystick inputif joy.x &gt;= -deadZone &amp;&amp; joy.x &lt;= deadZone    joy.x = 0endif joy.y &gt;= -deadZone &amp;&amp; joy.y &lt;= deadZone    joy.y = 0end</code></pre><p>但是这个方法有两个问题。首先无效区域是一个正方形而不是圆形。也就是说，如果摇杆的x和y都稍微比无效区域小一点，角色还是不会移动，哪怕实际上已经超过了相应的阈值。</p><p>为了解决这个问题，我们不应该将x和y看作独立的分量，而是将摇杆的输入视为一个2D向量。然后就可以通过向量运算来完成无效区域的过滤。</p><pre><code>float deadZone = 3000float maxValue = 32677Vector2 joy = joy joystick inputfloat length = joy.length()//如果长度小于无效区域，那么认为没有输入if length &lt; deadzone    joy.x = 0    joy.y = 0else    //计算无效区域到最大值之间的百分比    float pct = (length - deadZone) / (maxValue - deadZone)    //正规化向量，然后相乘得到最终结果    joy = joy / length    joy = joy * maxValue * pctend</code></pre><h1 id="二、基于事件的输入系统"><a href="#二、基于事件的输入系统" class="headerlink" title="二、基于事件的输入系统"></a>二、基于事件的输入系统</h1><p>输入系统可以设计为基于事件的。可以设计一个接受特定输入事件的系统。当事件发生的时候，系统就通知所有已经注册的代码。要注意的是，基于事件的输入系统还是要轮询输入的。</p><h2 id="1-基础事件系统"><a href="#1-基础事件系统" class="headerlink" title="1.基础事件系统"></a>1.基础事件系统</h2><p>有不少语言，像C#那样，原生就支持事件机制。但是，如果你选择的语言没有内内建支持，实现一个事件系统也不难。几乎所有语言都支持将函数作为变量。还有的可以通过匿名函数、lambda表达式、函数对象或者函数指针来实现。随着函数可以作为变量，就可以得到一个列表关联上具体的事件。每当事件被触发，那些注册了的函数都会被调用。</p><p>假设你想实现一个简单的用于鼠标点击的事件驱动系统。游戏的很多逻辑都希望在鼠标点击时获得通知，并且得到鼠标在屏幕上的位置。在这种情况下，就会有一个“鼠标管理中心”的需求，它能让关心鼠标事件的系统去注册。</p><pre><code>class MouseManager    List functions    //接受那些将传递的参数(int, int)作为信号的函数    function RegisterToMouseClick(function handler(int, int))        functions.Add(handler)    end    function Update(float deltaTime)        bool mouseClicked = false        int mouseX = 0, mouseY = 0        //轮询鼠标点击        ...        if mouseClicked            foreach function f in functions                f(mouseX, mouseY)            end        end    endend</code></pre><p>然后那些对鼠标点击感兴趣的部分都可以通过调用RegisterToMouseClick进行注册</p><pre><code>//为鼠标点击注册myFunctionMouseManager.RegisterToMouseClick(myFunction)</code></pre><p>在注册之后，这个函数就会在事件发生之后自动被调用。让MouseManager可以全局访问的最好方式就是<strong>单例</strong>设计模式，就是整个程序都可以通过一个地方访问得到这个实例。</p><h2 id="2-一个更复杂的系统"><a href="#2-一个更复杂的系统" class="headerlink" title="2.一个更复杂的系统"></a>2.一个更复杂的系统</h2><p>本节讨论的系统不允许直接将函数注册到事件当中。它通过创建一系列输入动作的方式，让感兴趣的系统查询这些动作。</p><p>这个系统依赖于按键映射的字典。在这个系统中，键就是绑定的名字(比如“Fire”)，而值就是按钮的相关信息，包括哪个按钮以及触发的时机(“刚刚按下”、“一直按着”等)。由于我们希望支持绑定多种行为，我们要选中一种能够支持键值重复的字典。</p><p>每一帧，输入系统都检查这个字典的每一个键值并判断哪个键值激活。那些在这帧中激活的绑定会存储到一个激活按键绑定字典中。这个激活的绑定字典首先会提供给UI系统，UI系统就会判断哪些UI会受到这些动作影响。接下来剩下的绑定就会传递到游戏世界中再进一步处理。</p><p>这个系统的代码也不是非常复杂。</p><pre><code>enum KeyState    StillReleased,//上一帧释放 本帧释放 一直释放状态    JustPressed,//上一帧释放 本帧按下 刚刚按下状态    JustReleased,//上一帧按下 本帧释放 刚刚释放状态    StillPressed//上一帧按下 本帧按下 一直按着状态endfunction UpdateKeyboard()    //lastState和CurrentState是在其他地方定义好的数组    //记录了完整的键盘信息    lastState = currentState    currentState = get keyboard stateendfunction GetKeyState(int keyCode)    if lastState(keyCode) == true        if currentState(keyCode) == true            return StillPressed        else            return JustReleased        end    else        if currentState(keyCode) == true            return JustPressed        else            return StillReleased        end    endend//BindInfo就是字典中的值struct BindInfo    int keyCode    keyState stateTypeendclass InputManager    //存储了索引绑定    Map keyBindings;    //只存储那些激活的绑定    Map activeBindings;    //使按键绑定更加方便    function AddBinding(string name, int code, Keystate type)        KeyBindings.Add(name, BindInfo(code, type))    end    //初始化所有绑定    function InitializeBindings()        //可以从文件解析        //然后调用AddBinding进行绑定        //比如说，“Fire”可以映射到刚刚释放的回车键        //AddBinding("Fire", K_ENTER, JustReleased)        ...    end    function Update(float deltaTime)        //清除所有上一帧中的激活绑定        activeBindings.Clear()        //KeyValuePair有key和value成员，分别是来自字典键和值        foreach KeyValuePair k in keyBindings            if GetKeyState(k.value.keyCode) == k.value.stateType                //如果与绑定一直，则认为绑定是被激活的                activeBindings.Add(k.key, k.value)            end        end        //如果有任何的激活绑定，那么优先发生给UI系统        if activeBindings.Count() != 0            //发送激活绑定给UI            ...            //发送激活绑定给游戏的剩余部分            ...        end    endend</code></pre><h1 id="三、移动设备输入"><a href="#三、移动设备输入" class="headerlink" title="三、移动设备输入"></a>三、移动设备输入</h1><p>大多数的智能机和平板设备都有着与传统的键盘、鼠标、手柄不同的输入机制。</p><h2 id="1-触屏和手势"><a href="#1-触屏和手势" class="headerlink" title="1.触屏和手势"></a>1.触屏和手势</h2><p>触屏允许玩家通过手指与屏幕交互。最基本的情形，如果游戏允许玩家只用一根手指点击操作，那么实现起来就和鼠标一样。但是大多数移动设备都支持<strong>多点触摸</strong>，就是说允许用户同时多个手指进行操作。</p><p>一些游戏通过多点触摸实现<strong>虚拟手柄</strong>，这会有一个虚拟摇杆和虚拟按键让玩家交互。有一些操作只有触摸屏才能实现，称之为<strong>手势操作</strong>，就是一系列的触摸引发的行为。</p><p>检测手势有很多种方法，其中一种流行的算法就是<strong>Rubine算法</strong>。为了应用Rubine算法，我们需要先创建手势识别库。这个库的创建方式是通过一个能画出手势的测试程序来完成的。手势的绘制，有14个手势的数学属性，称之为<strong>功能</strong>，是被计算出来的。这些功能的元素包括手势绘制的总时长、总距离、手势的距离、手势的中点、初始点等。</p><p>在某个特定手势的功能计算之后，会存储到库中。在库完成之后，就是可以在程序中加载这些手势并进行识别。然后当用户开始输入手势时，就会计算这个手势对应的数学属性。在用户完成输入后，这个算法就会开始分析然后判断这是哪个手势</p><h2 id="2-加速器和陀螺仪"><a href="#2-加速器和陀螺仪" class="headerlink" title="2.加速器和陀螺仪"></a>2.加速器和陀螺仪</h2><p>加速器检测设备坐标系向上的加速度。而<strong>陀螺仪</strong>可以检测设备关于设备轴向的旋转。</p><h2 id="3-其他移动设备输入"><a href="#3-其他移动设备输入" class="headerlink" title="3.其他移动设备输入"></a>3.其他移动设备输入</h2><p>一些类型的游戏可能会扩展和使用更多移动平台才有的输入。比如摄像机数据、GPS等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·3D图形</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-3d-tu-xing/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-3d-tu-xing/</url>
      
        <content type="html"><![CDATA[<p>3D游戏显示技术的挑战主要是，怎么将3D的游戏世界显示在2D的显示器上。</p><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>第一款3D游戏中的渲染是完全以软件方式实现的(即没有硬件支持)。这意味着即使是画线这种基础功能都要图形程序员去完成。这套将3D模型正确渲染到2D颜色缓冲的算法称为<strong>软件光栅化</strong>，大部分计算机图形学会花费大量时间在这些算法上。但是现代的计算机已经有了称之为<strong>图形处理单元(GPU)</strong>的图形硬件，这些硬件实现了绘制点、线、三角形等功能。</p><p>由此，现代游戏不再需要开发实现软件光栅化了。而焦点则转变为将需要渲染的3D场景数据以正确的方式传递给显卡，一般都通过像OpenGL和DirectX这样的库完成。如果需要进一步自定义这个需求，可以编写<strong>着色器</strong>来应用传入的数据。</p><p>在3D图形中需要注意的是，经常需要计算近似值。这只是因为计算机没有足够的时间去计算真实的光照。由于近似模拟而产生的显示错误称之为<strong>图形失真</strong>，没有游戏可以完全避免失真。</p><h2 id="1-多边形"><a href="#1-多边形" class="headerlink" title="1. 多边形"></a>1. 多边形</h2><p>3D对象在计算机程序中有多种显示方法，在游戏中最广泛应用的就是通过多边形显示，更具体一点来说是三角形。</p><p>为什么是三角形？首先，它们是最简单的多边形，它们可以仅用3个<strong>顶点</strong>表示。第二点就是三角形总是在一个平面上，而多个顶点的多边形则有可能在多个平面上。最后，任何3D对象都可以简单地用细分三角面表示，且不会留下漏洞或者进行变形。</p><p>单个模型，我们称为<strong>网格</strong>，是由多个三角片组成的。一个网格的多边形数量主要由用途决定。</p><p>所有图形库都会输入想要显卡渲染的三角形，并且提供必要的信息，高速显卡这些数据该怎么渲染。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/QGgTnzqA3MKmY1o.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 一个用三角形网格表示的海豚</div></center><h1 id="二、坐标系"><a href="#二、坐标系" class="headerlink" title="二、坐标系"></a>二、坐标系</h1><p>一个坐标系空间有不同的参考系。比如说，在笛卡尔坐标系中，原点在世界的中间，所有坐标都相对于中心点。在3D渲染管线中，渲染3D模型到2D显示器，必须经历4个主要的坐标系空间。</p><ul><li>模型坐标系/局部坐标系</li><li>世界坐标系</li><li>视角坐标系/摄像机坐标系</li><li>投影坐标系</li></ul><h2 id="1-模型坐标系"><a href="#1-模型坐标系" class="headerlink" title="1.模型坐标系"></a>1.模型坐标系</h2><p>当我们在建模的时候，比如像在Maya这样的软件里面，所有模型顶点的表示都是相对于模型原点的。<strong>模型坐标系</strong>就是那个相对于模型自身的坐标系。在模型坐标系中，原点通常就在模型中心。</p><h2 id="2-世界坐标系"><a href="#2-世界坐标系" class="headerlink" title="2.世界坐标系"></a>2.世界坐标系</h2><p>在<strong>世界坐标系</strong>中，所有对象都相对于世界的原点偏移。</p><h2 id="3-齐次坐标系"><a href="#3-齐次坐标系" class="headerlink" title="3.齐次坐标系"></a>3.齐次坐标系</h2><p>经常会有3D游戏使用4D分量，当4D坐标系应用在3D空间中时，它们被称为<strong>齐次坐标系</strong>，而第4个分量被称为<strong>ω分量</strong>。</p><p>在大多数情况下，ω分量要么是0，要么是1。如果ω=0，表示这个齐次坐标是3D向量。而ω=1，则表示齐次坐标是3D的点。</p><h2 id="4-通过矩阵变换4D向量"><a href="#4-通过矩阵变换4D向量" class="headerlink" title="4.通过矩阵变换4D向量"></a>4.通过矩阵变换4D向量</h2><p>用于变换的矩阵通常是4x4矩阵。为了与4x4矩阵相乘，同时也需要4D向量。这是齐次坐标的工作方式。</p><h2 id="5-矩阵变换"><a href="#5-矩阵变换" class="headerlink" title="5.矩阵变换"></a>5.矩阵变换</h2><p><strong>矩阵变换</strong>就是矩阵用某种方法来影响向量或者顶点。矩阵变换使得我们可以将模型坐标系变换为世界坐标系。</p><p><strong>缩放</strong> 在游戏中需要将角色的模型在世界坐标系中变大1倍，可以通过用模型的每个顶点乘以缩放矩阵来完成，它可以将模型在各个轴上进行缩放。</p><p>$$<br>s(s_x,s_y,s_z)= \left[<br> \begin{matrix}<br>   s_x &amp; 0 &amp; 0 &amp; 0\<br>   0 &amp; s_y &amp; 0 &amp; 0\<br>   0 &amp; 0 &amp; s_z &amp; 0 \<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p>如果$s_x=s_y=s_z$，就是<strong>等比缩放</strong>，就是说向量在每个轴上缩放值都一样。所以当所有缩放值等于2时，模型会变为2倍大小。</p><p><strong>平移</strong> 一个<strong>平移矩阵</strong>可以将顶点移动一段距离。它作用在向量上无效，因为向量在哪里绘制都一样。平移矩阵就是将单位矩阵最后一行填上平移的x，y和z值。</p><p>$$<br>T(t_x,t_y,t_z)= \left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; 0 &amp; 0\<br>   0 &amp; 1 &amp; 0 &amp; 0\<br>   0 &amp; 0 &amp; 1 &amp; 0 \<br>   t_x &amp; t_y &amp; t_z &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p><strong>旋转</strong> <strong>旋转矩阵</strong>可以将顶点或者向量相对于某个轴渲染。笛卡尔坐标系下每个轴都有一个矩阵，总共有3种旋转矩阵。因此绕x轴渲染跟绕y轴渲染矩阵时不同的。</p><p>这些旋转称为<strong>欧拉角旋转</strong>，以瑞士数学家名字命名，</p><p>$$<br>RotateX(\theta)=\left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; 0 &amp; 0\<br>   0 &amp; \cos\theta &amp; -\sin\theta &amp; 0\<br>   0 &amp; \sin\theta &amp; \cos\theta &amp; 0 \<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p>$$<br>RotateY(\theta)=\left[<br> \begin{matrix}<br>   \cos\theta &amp; 0 &amp; \sin\theta &amp; 0\<br>   0 &amp; 1 &amp; 0 &amp; 0\<br>   -\sin\theta &amp; 0 &amp; \cos\theta &amp; 0 \<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p>$$<br>RotateZ(\theta)=\left[<br> \begin{matrix}<br>   \cos\theta &amp; -\sin\theta &amp; 0 &amp; 0\<br>   \sin\theta &amp; \cos\theta &amp; 0 &amp; 0\<br>   0 &amp; 0 &amp; 1 &amp; 0 \<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p><strong>应用矩阵变换</strong> 组合多个矩阵的相乘得到最终世界变换矩阵的做法是很常见的。比如说想将角色放在某个特定位置，然后拉长2倍，就需要平移矩阵和缩放矩阵。</p><p>组合多个矩阵，只需将多个矩阵相乘即可。乘积的顺序是非常重要的，因为矩阵相乘不服从交换律。一般来讲，以行为主来表示的话，世界变换矩阵要像下面这样计算：</p><p>$$<br>WorldTransform=Scale \times Rotation \times Translation<br>$$</p><p>要注意旋转是相对于原点而言的。</p><h2 id="6-视角-摄像机坐标系"><a href="#6-视角-摄像机坐标系" class="headerlink" title="6.视角/摄像机坐标系"></a>6.视角/摄像机坐标系</h2><p>在所有对象放置到世界坐标系上正确的位置之后，下一件要考虑的事情就是摄像机的位置。一个场景或者关卡可以完全静止，但是如果摄像机的位置改变，就完全改变了屏幕上的显示。这个称为<strong>视角/摄像机坐标系</strong></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/eLiaqMvChzGKPDH.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 摄像机坐标系</div></center><p>所以还需要另外一个矩阵高速显卡如何将世界坐标系的模型变换到相对于摄像机的位置上。最常见的矩阵时<strong>观察矩阵</strong>。在观察矩阵当中，摄像机的位置通过3个轴的额外分量来表示。</p><p>对于以行为主的左手坐标系来讲，观察矩阵如下:</p><p>$$<br>Look·At=\left[<br> \begin{matrix}<br>   L_x &amp; U_x &amp; F_x &amp; 0\<br>   L_y &amp; U_y &amp; F_y &amp; 0\<br>   L_z &amp; U_z &amp; F_z &amp; 0 \<br>   T_x &amp; T_y &amp; T_z &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p>L表示左边或者x轴，U表示上方或者y轴，F表示前方或者z轴，而T则是摄像机的平移。为了构造这个矩阵，需要计算着4个向量。大部分3D库可以自动计算这个观察矩阵。</p><p>需要3个输入来构造观察矩阵:<strong>眼睛</strong>，也就是摄像机的位置、摄像机正在观察的位置、摄像机向上的方向。虽然一些情况下摄像机向上的方向就是世界坐标系向上的方向，但也有特例。在任何情形下，给定这3个输入，就可以算出第4个向量:</p><pre><code>function CreateLookAt(Vector3 eye, Vector3 target, Vector3 Up)    Vector3 F = Normalize(target - eye)    Vector3 L = Normalize(CrossProduct(Up, F))    Vector3 U = CrossProduct(F, L)    Vector3 T    T.x = -DotProduct(L, eye)    T.y = -DotProduct(U, eye)    T.z = -DotProduct(F, eye)    //通过F、L、U和T创建并返回观察矩阵end</code></pre><p>在应用视角坐标系之后，整个世界都会变换到从摄像机眼睛的位置去观察。但是，3D的世界是需要变换到2D屏幕上的。</p><h2 id="6-投影坐标系"><a href="#6-投影坐标系" class="headerlink" title="6.投影坐标系"></a>6.投影坐标系</h2><p><strong>投影坐标系</strong>有时候也叫作屏幕坐标系，是一种将3D场景平铺到2D平面上得到的坐标系。一个3D场景可以通过多种方式平铺在2D平面上，两种最常见的方法分别是正交投影和透视投影。</p><p>在<strong>正交投影</strong>中，整个世界挤在2D图像中，完全没有深度的感觉。就是说离摄像机远的对象与离摄像机近的对象在视觉上是一样的。任何纯2D的游戏都可以看作使用了正交投影。但是，有些正交投影的游戏会传达3D信息，比如《模拟人生》和《暗黑破坏神 3》。</p><p>另一种常见的投影则是<strong>透视投影</strong>。在这种投影中，对象在摄像机中会显得近大远小。大部分3D游戏都采用这种投影。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/GmznU5bfXC2OQay.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 正交投影和透视投影</div></center><p>两种投影都有近平面和远平面。<strong>近平面</strong>是靠近摄像机的平面，而介于摄像机和近片面之间的物体不参与绘制。游戏中如果某个人物太过于靠近摄像机会突然消失，就是被近平面别除的原因。与之类似，<strong>远平面</strong>就是远离摄像机的平面，任何物体超过这个平面就不参与绘制了。</p><p>正交投影矩阵由4个参数构成，视口的宽和高，还有远平面和近平面到眼睛的最近距离:</p><p>$$<br>Orthographic=\left[<br> \begin{matrix}<br>   \frac{2}{width} &amp; U_x &amp; F_x &amp; 0\<br>   L_y &amp; \frac{2}{height} &amp; F_y &amp; 0\<br>   L_z &amp; U_z &amp; \frac{1}{far-near} &amp; 0 \<br>   T_x &amp; T_y &amp; \frac{near}{far-near} &amp; 1<br>  \end{matrix}<br>\right]<br>$$</p><p>透视投影则多了一个<strong>参数视场(FOV)</strong>。就是摄像机的可见角度。视场决定了你能看到多少内容。加了视场之后就可以计算出透视矩阵:</p><p>$$<br>yScale=\cot fov/2<br>$$</p><p>$$<br>xScale=yScale·\frac{height}{width}<br>$$</p><p>$$<br>Perspective=\left[<br> \begin{matrix}<br>   xScale &amp; 0 &amp; 0 &amp; 0\<br>   0 &amp; yScale &amp; 0 &amp; 0\<br>   0 &amp; 0 &amp; \frac{far}{far-near} &amp; 1 \<br>   0 &amp; 0 &amp; \frac{-near·far}{far-near} &amp; 0<br>  \end{matrix}<br>\right]<br>$$</p><p>需要注意的是，当顶点与矩阵相乘之后，ω分量不再为1。<strong>透视分割</strong>需要让每一个变换后的顶点分量除以ω分量，使得ω分量再一次为1.这个过程真正使得透视变换具有了深度感。</p><h1 id="三、光照与着色"><a href="#三、光照与着色" class="headerlink" title="三、光照与着色"></a>三、光照与着色</h1><p>到这一步为止，就可以在屏幕上将3D场景以线框的方式绘制到2D的颜色缓存中。然后我们希望这些三角形能够得到填充，现代3D游戏也同样需要颜色、纹理和光照。</p><h2 id="1-颜色"><a href="#1-颜色" class="headerlink" title="1.颜色"></a>1.颜色</h2><p>最简单的在3D场景中表示颜色的方式就是使用<strong>RGB颜色空间</strong>，这是因为RGB直接就是显示器的绘图方式。每个屏幕上的像素都是通过红色、蓝色、绿色组成的。</p><p>在选择了RGB表示颜色之后，下一个要决定的就是<strong>色深</strong>，就是每个像素用多少位来存储。如今，大部分游戏中的3颜色分量都用8位来存储，就是说红色、蓝色、绿色都有256种可能的颜色。这就有了大约1600万种不同的颜色。</p><p>因为原色的范围从0到255，有时候会用其他方式表达。在网站图像中，#ff00000表示红色值255，绿色值0，蓝色值0。在3D图形中最常见的表示方法是用0.0到1.0之间的浮点数表示。所以1.0就是原色的最大值，而0.0就是原色不存在。</p><p>根据游戏的不同，有些游戏会有第4个分量，称为<strong>不透明度</strong>。不透明通道决定了一个像素的透明度。不透明度为1.0就是说像素100%不透明的，而0.0则表示看不见。</p><p>所以如果游戏完全支持RGBA，每个分量用8位表示，那么每个像素总共有32位(或者4个字节)。这是游戏很常见的渲染模式。</p><h2 id="2-顶点属性"><a href="#2-顶点属性" class="headerlink" title="2.顶点属性"></a>2.顶点属性</h2><p>为了让模型有颜色，需要在顶点上存储额外的信息。这些信息被称为定点属性，在大多数现代游戏中每个顶点都会带多个属性。当然，额外的内存负担会影响模型的顶点数。</p><p>有很多参数可以做顶点属性。在<strong>纹理映射</strong>中，2D的图片可以映射到3D的三角形中。每个顶点上都有一个<strong>纹理坐标</strong>指定纹理的特定部分与之对应。最常见的纹理坐标系是<strong>UV坐标系</strong>，纹理上的x坐标称为u，而y坐标称为v。</p><p>仅通过纹理，就可以让场景看起来充满色彩，但是会看起来不够真实，因为场景中没有真实的光照。大部分光照模型依赖于另一种顶点模型:<strong>顶点法线</strong>。怎么得到顶点的法线。</p><p>顶点的法线可以通过多种方法得到。一种方法就是对所有拥有该顶点的三角形的法线取平均值。如果你希望你的模型看上去很平滑，那么这种方法很好用。但如果你想用平均法线渲染出一个四方体，会得到一个圆角四方体。为了解决这个问题，四方体的每个角都要有3个不同的顶点，而每个顶点都存储不同的朝向各自所属平面的法线。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/xKoVLW1EualNv24.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 平均顶点法线(a)和四方体的顶点根据所属平面有3个不同的法线方向(b)</div></center><p>要记住，一个三角形从技术角度来讲有两个法线，取决于叉乘的顺序。对于三角形来说，这个顺序取决于<strong>顶点序</strong>，可以是顺时针的，也可以是逆时针的。</p><p>顶点序的一个作用就是用于渲染优化，称为<strong>背面剔除</strong>，就是说没有朝向摄像机的三角片不进行渲染。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/wGIu9shP1xX6mtp.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 一个四方体使用正确的顶点序渲染(a)和同样的四方体使用不正确的顶点序渲染(b)</div></center><h2 id="3-光照"><a href="#3-光照" class="headerlink" title="3.光照"></a>3.光照</h2><p>3D游戏中使用的光照有好几种类型。一些光照会全局作用于整个场景，而一些光照只作用于光照范围内的区域。</p><p><strong>环境光</strong>就是一种添加到场景中每一个物体上的固定光照。在游戏中环境光的值经常会按照不同的关卡需求来设置，取决于关卡所处的时间点。夜间关卡会选用比较阴暗寒冷的环境光，而白天的关卡则会选用比较明亮温暖的。</p><p><strong>方向光</strong>是一种没有位置的光，只指定光照的方向。跟环境光一样，方向光作用与整个场景。但是，由于方向光是带方向的，所以它们会照亮物体的正面，而背面则没有光照。</p><p><strong>点光源</strong>就是某个点向四面八方射出的光照。由于它们从某个点射出，点光源也只会照亮物体的正面。在大多数情况下，不希望点光源无限远。可以增加或减少<strong>衰减半径</strong>来控制光照衰减的方式。</p><p><strong>聚光灯</strong>跟点光源很像，除了点光源向所有方向发射，聚光灯只在追体内有光外。为了计算椎体范围，需要一个角度作为聚光灯的参数。跟点光源一样，聚光灯只会照亮物体的正面。</p><h2 id="4-Phong光照模型"><a href="#4-Phong光照模型" class="headerlink" title="4.Phong光照模型"></a>4.Phong光照模型</h2><p>在光源放入关卡之后，游戏就需要计算光源如何作用于物体上。这些计算都可以通过<strong>双向反射分布函数(BRDF)</strong>来完成。BRDF用于计算光源怎么作用于物体表面。有很多种不同的BRDF，下面只讲最基础的一种：<strong>Phong光照模型</strong>。要注意的是，Phong光照模型与Phong着色模型是不一样的。</p><p>Phong光照模型是一种<strong>局部光照模型</strong>，因为它不考虑光的二次反射。换句话说，每个物体都认为在场景中只有自己被渲染。在物理世界中，如果一个红光打到白色的墙上，红光会有少量反射到房屋里其他地方。但是在局部光照模型中是不会发生的。</p><p>在Phong光照模型中，光被分为几种分量：环境光、漫反射和高光。这3种分量都会影响物体的颜色。<strong>环境光</strong>分量用于整体照亮场景。由于它均匀地作用于整个场景，所以环境光分量与光源的位置和摄像机的位置都无关。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/dqnpfXxWOTJQAG7.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 Phong光照模型</div></center><p><strong>漫反射</strong>分量是光源作用与物体表面的主要反射。它会被所有方向光、点光源和聚光灯影响。为了计算漫反射分量，你同时需要物体表面的法线和物体表面到光源方向的向量。但是跟环境光分量一样，漫反射同样也不被摄像机的位置影响。</p><p>最后一种分量是<strong>高光分量</strong>，表示物体表面上闪亮的高光。一些有强高光的物体，比如光滑的金属，会比涂上暗色涂料的物体光亮得多。类似漫反射分量，高光分量也同时取决于光源的位置和物体表面的法线。但它还取决于摄像机的位置，因为高光会随着视角方向变换而变换。</p><p>总而言之，Phong光照模型的计算并不复杂。这个模型遍历场景中的所有光源，计算表面的颜色，然后以某种方式来决定表面最终的颜色。</p><pre><code>//Vector3 N = 物体表面的法线//Vector3 eye = 摄像机的位置//Vector3 pos = 物体表面的位置//float a = 高光量Vector3 V = Normalize(eye - pos) //从物体表面到摄像机Vecroe3 Phong = AmbientColorforeach Light light in scene    if light affects surface        Vector3 L = Normalize(light.pos - pos)//从物体表面到光源        Phong += DiffuseColor * DotProduct(N, L)        Vector3 R = Normalize(Reflect(-L, N))//计算-L关于N的反射        Phong += SpecularColor * pow(DotProduct(R, V), a)    endend</code></pre><h2 id="5-着色"><a href="#5-着色" class="headerlink" title="5.着色"></a>5.着色</h2><p><strong>着色</strong>就是计算表面的三角片如何填充。最基础的着色类型是<strong>平面着色</strong>，就是整个三角片只有一种颜色。使用平面着色，只需每个三角片进行一次光照计算(通常在三角片的中心)，然后把通过计算得到的颜色赋予整个三角片。这样做基本能实现着色，可是不好看。</p><p><strong>Gouraud着色</strong><br>有一种稍微复杂一点的着色方法，我们称之为<strong>Gouraud着色</strong>。在这种着色方法中，光照模型的计算需要逐个顶点进行一次。这就使得每个顶点有不同的颜色，而三角片的剩余部分则通过顶点颜色插值填充。</p><p>虽然Gouraud着色比较近似自然色了，但还是有不少问题。首先，着色的质量取决于模型的多边形数量。在低多边形模型上，着色结果会有不少有棱角的边。虽然Gouraud着色在高多边形模型上能达到不错的效果，但是会占用不少内存。</p><p>另一个问题是高光用在低多边形模型上效果极差。而在低多边形模型上高光有可能会完全消失，因为只依据顶点来计算光照。虽然Gouraud着色流行了好几年，但是随着GPU性能的提升，就再也没人使用了。</p><p><strong>Phong着色</strong><br><strong>Phong着色</strong>是计算三角片上每个像素的光照模型。为了完成这种效果，顶点的法线需要在三角片表面进行插值，然后利用插值得到的法线进行光照计算。</p><p>Phong着色的计算量比Gouraud着色昂贵得多，特别是在场景中有很多灯光的时候。但是，大多数现代硬件都可以轻松处理这部分额外的计算。Phong着色可以认为是<strong>逐像素光照</strong>，因为光照结果是针对每个像素进行单独计算的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/12/yt2xfvEiuMmlS4L.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 使用Grouraud着色的物体(a)和使用Phong着色的物体(b)</div></center><h1 id="四、可见性"><a href="#四、可见性" class="headerlink" title="四、可见性"></a>四、可见性</h1><p>3D渲染里最重要的最后一点就是可见性判断。</p><h2 id="1-再探画家算法"><a href="#1-再探画家算法" class="headerlink" title="1.再探画家算法"></a>1.再探画家算法</h2><p>画家算法(将场景从后往前绘制)，它在2D游戏中很好用。这是因为2D精灵之间的顺序关系清晰，而且大多数2D引擎都内在支持层级的概念。对于3D游戏而言，这个顺序很少是静止的，因为摄像机的透视可以改变。</p><p>另一个画家算法的问题就是会引起大量的<strong>重绘</strong>，有的像素每帧都会绘制多次。在现代3D游戏中，计算最终光照和贴图的过程是渲染管线最昂贵的部分。像素重绘意味着前一次绘制的花费被浪费了。因此，大多数游戏都尽力避免重绘的发生。而在画家算法中这是不可能完成的任务。</p><p>而且，三角形重叠的时候也有问题。由于各种问题，画家算法在3D游戏中非常少用。</p><h2 id="2-深度缓冲区"><a href="#2-深度缓冲区" class="headerlink" title="2.深度缓冲区"></a>2.深度缓冲区</h2><p>在<strong>深度缓冲区</strong>中，会有一块额外的缓冲区仅在渲染的过程中使用。这块额外的缓冲区称为<strong>深度缓冲区</strong>，为场景中的每个像素存储数据，就像颜色缓冲一样。但是跟颜色缓冲区存储颜色不同，深度缓存区存储的是像素到摄像机的距离(或<strong>深度</strong>)。更准确地讲，每帧用到的缓冲区(包括颜色缓冲区、深度缓冲区、模板缓冲区等)统称为<strong>帧缓冲</strong>。</p><p>在使用深度缓冲区的每一帧渲染开始之前，深度缓冲区都会清空，确保当前深度缓冲区中的所有像素都无限远。然后，在渲染的过程中，像素的深度会在绘制之前先计算出来。如果该像素的深度比当前深度缓冲区存储的深度要小，那么这个像素就进行绘制，然后新的深度值会写入深度缓冲区。</p><p>所以每帧第一个绘制的对象总是能够将它的所有颜色和深度分别写入颜色缓冲区和深度缓冲区。但是当绘制第二个对象的时候，那些比已有像素更远的像素都不会进行绘制。</p><pre><code>//zBuffer[x][y]存储像素深度foreach Object o in scene    foreach Pixel p in o        float depth = calculate depth at p        if zBuffer[p.x][p.y] &gt; depth            draw p            zBuffer[p.x][p.y] = depth        end    endend</code></pre><p>通过深度缓冲，场景可以以任意顺序绘制，如果场景中没有透明的物体，那么绘制结果一定正确。但也不是说深度缓冲可以解决所有可见性问题。比如说，透明对象在深度缓冲中就不太适用。因为如果使用纯深度缓冲的方法先画水体，那么水体会写入深度缓冲，这样就会影响石头的绘制。为了解决这个问题，应用深度缓冲先画所有不透明的物体，然后可以关掉深度缓冲，在渲染所有透明物体。</p><p>像颜色一样，深度缓冲的表示方法也有固定的集中。最小的深度缓冲区为16位，可是在节省内存的同时也带来了一些副作用。在<strong>深度值冲突</strong>的时候，两个来自不同对象的像素挨得非常近，而且离摄像机很远，会产生每帧交替出现前后像素切换的情况。16位浮点数精度不够高导致在第1帧时像素A比像素B的深度要低，而在第2帧比像素B深度要大。为了避免这种情况，大多数现代游戏都会采用24位或者32位的深度缓冲区。</p><p>还有很重要的一点是，仅依靠深度缓冲并不能解决像素重绘的问题。如果你先画了一个像素，然后才发现该像素不该画。那么前一个像素的渲染就纯属浪费。一个解决方案就是采用<strong>先进行深度的pass</strong>。将深度计算与着色分开，在最终的光照计算pass之前完成深度计算。</p><p>深度缓冲的检查是基于像素的，如果有一颗树完全被建筑遮挡，深度缓冲还是会对这棵树的每个像素进行测试。为了解决这类问题，商业游戏经常使用复杂的<strong>剔除</strong>或者<strong>遮挡</strong>算法去消除那些在某些帧完全看不到的对象，类似的算法有二叉树分区算法(BSP)、入口算法和遮挡体积。</p><h1 id="五、再探世界变换"><a href="#五、再探世界变换" class="headerlink" title="五、再探世界变换"></a>五、再探世界变换</h1><p>如果平移、缩放和旋转必须独立修改，那么矩阵就需要分开存储，每个矩阵16个浮点数，3个矩阵就有48个浮点数。要减少平移和缩放相对简单，只要将平移存储为一个标量即可。然后这些值可以在最后的计算阶段才组成矩阵。但是该怎么处理旋转呢？</p><p>一种方法是使用欧拉角来表示，但是欧拉角一是不够灵活，二是会有<strong>万向锁</strong>的问题，三是有关于将两个朝向进行插值的问题，即当游戏有指向下一个目标的箭头。一旦这个目标达成，这个箭头就应该转向下一个节点。由于视觉原因，它应该有个一两秒的过渡。虽然可以通过欧拉角实现，但很难使得这个插值好看。</p><h2 id="1-四元数"><a href="#1-四元数" class="headerlink" title="1.四元数"></a>1.四元数</h2><p><strong>四元数</strong>可以表示关于任意轴旋转。有了四元数，再也不是受限于关于某个轴旋转，而是关于任意你想要的轴旋转。</p><p>四元数的另外一个优点就是很容易在两个四元数之间进行插值。有两种插值方式：线性插值和<strong>球形插值</strong>。球形插值比起线性插值更加准确，同时计算上也可能更加昂贵，取决于系统。</p><p>四元数只需要用4个浮点数来存储信息，这样更加节省内存。所以就像位置和统一缩放可以分别存储为3D向量和浮点标量一样，物体的选择也可以存储为四元数。</p><p>不管哪种用途，游戏中的四元数全部都是<strong>标准四元数</strong>，就像单位向量一样，四元数的长度为1。一个四元数有着一个向量和一个标量，经常都写着$q=|q_v,q_s|$。向量和标量的计算由旋转的轴和旋转的角度决定。</p><p>大多数3D游戏数学库都会内建四元数函数库。对于这些库来说，一个CreateFromAxisAngle或者类似的函数会自动为你构造四元数。还有些数学库可能会使用x、y、z和ω分量的形式来表示四元数。在这种情况下，向量部分就是x、y、z，标量部分就是ω。</p><p>具体可参考<a href="https://zhuanlan.zhihu.com/p/27471300" target="_blank" rel="noopener">四元数——基本概念</a></p><h2 id="2-3D游戏对象的表示"><a href="#2-3D游戏对象的表示" class="headerlink" title="2.3D游戏对象的表示"></a>2.3D游戏对象的表示</h2><p>在有了四元数之后，平移、缩放和旋转都可以用比4x4矩阵小的数据表示。这些就是3D游戏对象的世界变换应该存储的。然后到了需要将世界变换矩阵传递给渲染代码的时候，可以临时构造一个矩阵。这意味着如果代码要更新对象的位置，只要改变位置向量即可，而不是整个矩阵。</p><pre><code>class 3DGameObject    Quaternion rotation    Vector3 position    float scale    function GetWorldTransform()        //先缩放，后旋转，最后平移，顺序很重要        Matrix temp = CreateScale(scale) * CreateFromQuaternion(rotation) * CreateTranslation(position)        return temp    endend</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·2D图形</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-2d-tu-xing/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-2d-tu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="2D图形"><a href="#2D图形" class="headerlink" title="2D图形"></a>2D图形</h1><p>随着Web、移动游戏、独立游戏的爆发式增长，2D图形进入了文艺复兴时期。开发者选择2D通常是因为预算和团队规模。玩家选择2D则是因为游戏简洁而纯粹。</p><h2 id="2D渲染基础"><a href="#2D渲染基础" class="headerlink" title="2D渲染基础"></a>2D渲染基础</h2><p>为了更加全面地认识2D渲染，了解这种技术诞生时显示设备的情况是很有必要的。虽然现在基本都用LCD或者等离子显示器，但是有很多在老设备上诞生的技术到今天仍然使用。</p><h3 id="CRT显示器基础"><a href="#CRT显示器基础" class="headerlink" title="CRT显示器基础"></a>CRT显示器基础</h3><p>在多年前，<strong>阴极射线管(CRT)</strong>显示器是显示器的主流。CRT里图像的元素就是<strong>像素</strong>。对于彩色显示器，每个颜色由红、绿、蓝组成。显示器的分辨率决定了像素的数量。比如一个300x200的显示器有200行像素，叫做<strong>扫描线</strong>，每个扫描线可以有300个像素，所以总共有60000个像素之多。</p><p>CRT内部，绘制图像是通过电子枪发射电子流完成的。这把抢从左上角开始沿第一条扫描线进行绘制。当它完成之后就继续下一条扫描线，然后不断地重复，直到所有扫描线都画完。</p><p>当电子枪刚刚完成一帧的绘制的时候，它的枪头在右下角。喷枪从右下角移动到左上角所花费的时间，我们称为<strong>场消隐期(VBLANK)</strong>。这个间隔以ms计，间隔不是由CRT、计算机或者电视机决定的，而是由用途决定的。</p><h3 id="像素缓冲区和垂直同步"><a href="#像素缓冲区和垂直同步" class="headerlink" title="像素缓冲区和垂直同步"></a>像素缓冲区和垂直同步</h3><p>新的硬件使得有足够的内存将所有颜色保存在<strong>像素缓冲区</strong>。但这不是说游戏循环就可以完全无视CRT喷枪。假设喷枪在屏幕上绘制到一半时，刚好游戏循环到了“generate outputs”阶段。它开始为新的一帧往像素缓冲区写像素时，CRT还在上一帧的绘制过程中。这就导致了<strong>屏幕撕裂</strong>，具体表现就是屏幕上同时显示了不同的两帧的各自一半画面。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/1.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 画面撕裂</div></center><p>一个解决方案就是同步游戏循环，等到场消隐期再开始渲染。这样会消除分裂图像的问题，但是它限制了游戏循环的间隔，只有场消隐期期间才能进行渲染，对于现在的游戏来说是不行的。</p><p>另一个解决方案叫作<strong>双缓冲技术</strong>。双缓冲技术里，有两块像素缓冲区。游戏交替地绘制在这两块缓冲区里。在1帧内，游戏循环可能将颜色写入缓冲区A，而CRT正在显示缓存区B。到了下一帧，CRT显示缓冲区A，而游戏循环写入缓冲区B。由于CRT和游戏循环都在使用不同的缓冲区，所以没有CRT绘制不完整的风险。</p><p>为了完全消灭屏幕撕裂，缓冲区交换必须在场消隐期进行，这就是游戏中常见的垂直同步设置。技术上来讲这是不恰当的，因为垂直同步是显示器在场消隐期刚结束时才告诉你的信号。不管怎样，缓冲区交换是一个相对快速的操作，游戏渲染一帧花费的时间则长得多。所以在场消隐期交换缓冲区完全消除了屏幕撕裂风险。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/2.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 垂直同步</div></center><p>这就是双缓冲区绘制函数的样子:</p><pre><code>function RenderWorld()    //绘制游戏世界中所有对象    ...    wait for VBLANK    swap color buffersend</code></pre><p>当然有些游戏允许缓冲区交换绘制完成前尽快进行，这种情况通常是因为玩家想要获得远比屏幕刷新速度快的帧率。虽然CRT显示器今天几乎不再使用，但是双缓冲技术在正确的时间交换还是能在LCD上消除屏幕撕裂的问题。一些游戏甚至使用了<strong>三缓冲技术</strong>，使用3个缓冲区，能使帧率在一些特殊情况下更加平滑，但也增加了输入延迟。</p><h2 id="精灵"><a href="#精灵" class="headerlink" title="精灵"></a>精灵</h2><p>精灵是使用图片中的一个方块绘制而成的2D图像。通常精灵用来表示角色和其他动态对象。对于简单的游戏来讲，精灵也可能用于背景。大多数2D游戏运用大量的精灵，对于移动端游戏来说，精灵通常就是游戏体积的主要部分。所以，高效利用精灵是非常重要的。</p><p>精灵使用哪种图片格式？这在很大程度上取决于用什么图片在哪些平台比较省内存。PNG格式可能空间占用小，但是通常硬件都不支持以PNG格式直接绘制，因此加载到游戏内存的过程中会被转换成其他格式。TGA格式通常可以直接绘制，可是空间占用比较大。在IOS设备上，比较好的格式时PVR，因为它不仅被压缩过，而且还能够直接绘制。</p><p>加载图片到内存的过程也是很大程度上取决于平台和框架的。对于SDL，XNA和Cocos2D那样的框架，内建了大量图片格式。如果你想从头开始开发2D游戏，可以用一个相对简单的库stb_image.c(<a href="https://github.com/nothings/stb" target="_blank" rel="noopener">https://github.com/nothings/stb</a>)。</p><h3 id="绘制精灵"><a href="#绘制精灵" class="headerlink" title="绘制精灵"></a>绘制精灵</h3><p>假设你需要绘制一个场景，最简单的绘制方式是，先画背景后画角色。这个算法叫作<strong>画家算法</strong>。在画家算法中，所有精灵是从后往前排序的，当它绘制场景时，预先排好序的场景可以直接遍历渲染，得到正确的结果。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/3.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 首先绘制远山，然后绘制较近的草地，最后绘制场景中最近的树木等</div></center><p>这个方法在2D游戏中没有什么问题(在3D环境下，则有很多缺陷)。每个精灵最少由一个绘制顺序，另外还要有图像数据和位置数据。</p><pre><code>class Sprite    ImageFile image    int drawOrder    int x,y    function Draw()        //把图片在正确的(x,y)上绘制出来        ...    endend</code></pre><p>然后，有些世界中的Drawable列表就可以根据绘制顺序排序。这样，在绘制期间，排好序的对象就可以线性遍历下去，然后绘制出正确的结果。</p><pre><code>SortedList spriteList//创建新的精灵······Sprite newSprite = specify image and desired x/ynewSprite.drawOrder = set desired draw order value//根据渲染顺序添加到排序列表spriteList.Add(newSprite.drawOrder, newSprite)//准备绘制foreach Sprite s in spriteList    s.Draw()loop</code></pre><p>一些2D库，比如Cocos2D，允许场景中的层次任意组合，而每个层次都有一个顺序。</p><h3 id="动画精灵"><a href="#动画精灵" class="headerlink" title="动画精灵"></a>动画精灵</h3><p>对于大多数2D游戏，动画原理就跟连环画一样：快速切换静态图片从而产生动画的幻觉。为了保证动画的流畅性，帧率最少要达到24FPS。这就说动画的每1秒，都24张不同的图片。有的游戏类型，比如格斗游戏，可以将动画帧率提高到60FPS。</p><p>一个常见的方法就是用一组图片去表示一个角色的所有状态，而不是某个特定动画。比如说，一个有走动和跑步的角色，每个用10帧表示，总共用了20张图片。为了让问题保持简单，这些图片顺序存储，就是说0-9帧表示走路，10-19帧表示跑步。</p><p>这就意味着需要一些方法配置哪些帧表示哪个动画。一个简单的方法就是将这些动画信息封装为一个AnimFrameData结构体，指定开始帧和帧长度去表示一个动画:</p><pre><code>struct AnimFrameData    //第1帧动画的索引    int startFrame    //动画的所有帧数    int numFramesend</code></pre><p>我们用AnimData结构体去存储所有图片的同时，用FrameData保存所有动画信息:</p><pre><code>struct AnimData    //所有动画用到的图片    ImageFile image[]    //所有动画用到的帧    AnimFrameData frameInfo[]end</code></pre><p>然后需要AnimatedSprite类从Sprite类继承下来。因为它继承了Sprite，它已经有位置和根据绘制顺序进行绘制的功能，简单来讲就是绘制一张图片的能力。当然AnimatedSprite还需要额外的变量来完成功能。</p><p>AnimatedSprite要能够跟踪当前的动画数量，直到当前帧属于哪一个动画及当前动画需要用到多长时间。其中FPS也作为一个成员变量被存储了。这样能够让动画动态加速或者减速。</p><pre><code>class AnimatedSprite inherits Sprite    //所有动画数据(包括ImageFiles和FrameData)    AnimData animData    //当前运行中的动画    int animNum    //当前运行中的动画的帧数    int frameNum    //当前帧播放了多长时间    float frameTime    //动画的FPS(默认24FPS)    float animFPS = 24.0f    function Initialize(AnimData myData, int startingAnimNum)    function UpdateAnim(float deltaTime)    function ChangeAnim(int num)end</code></pre><p>Initialize函数会为这个AnimatedSprite引用AnimData。通过引用传递，多个动画精灵能共享同一份数据，这样大大节省了内存。然后函数要求传入需要传播的动画，而后续初始化工作由ChangeAnim函数完成。</p><pre><code>function AnimatedSprite.Initialize(AnimData myData, int startingAnimNum)    animData = myData    ChangeAnim(startingAnimNum)end</code></pre><p>ChangeAnim函数在AnimatedSprite切换动画的时候调用。它设置帧数和时间都为0，而后设置当前图片为动画的第1帧。在ChangeAnim和UpdateAnim函数中，使用umage去表示图片。这是因为基类Sprite使用image绘制。</p><pre><code>function AnimatedSprite.ChangeAnim(int num)    animNum = num    //当前动画为第0帧的0.0f时间    frameNum = 0    animTime = 0.0f    //设置当前图像，设置为startFrame    int imageNum = animData.frameInfo(animNum).startFrame    image = animData.image[imageNum]end</code></pre><p>UpdateAnim函数是AnimatedSprite最重要的函数。一部分复杂的原因是不能假设动画帧率比游戏帧率满。比如说，一个游戏可以以30FPS的帧率运行，但我们想让动画以48FPS运行，这就是说UpdateAnim得跳过某些动画帧。</p><pre><code>function AnimatedSprite.UpdateAnim(float deltaTime)    //更新当前帧播放时间    frameTime += deltaTime    //根据frameTime判断是否播放下一帧    if frameTime &gt; (1/animFPS)        //更新当前播放到第几帧        //frameTime / (1 / animFPS)就相当于frameTime * animFPS        frameNum += frameTime * animFPS        //检查是否跳过最后一帧        if frameNum &gt;= animData.frameInfo[animNum].numFrames            //取模能保证帧数循环正确            frameNum = frameNum % animData.frameInfo[animNum].numFrames        end        //更新当前显示图片        //(startFrame是相当于所有图片来决定的，而frameNum是相对于某个动画来决定的)        int imageNum = animData.frameInfo[animNum].startFrame + frameNum        image = animData.images[imageNum]        //我们用fmod(浮点数运算)，相当于取模运算        frameTime = fmod(frameTime, 1/animFPS)    endend</code></pre><p>虽然这个AnimatedSprite实现在循环动画下工作正常，但还不支持动画切换。如果需要这样的功能，还是建议用动画状态机来实现。</p><h3 id="精灵表单-图集"><a href="#精灵表单-图集" class="headerlink" title="精灵表单(图集)"></a>精灵表单(图集)</h3><p>为了保证精灵完全对齐，让角色的所有动画用同一个尺寸是尚可接受的。在过去，许多库要求所有图片尺寸为2的幂次方。</p><p>如果把每帧图片都单独称为一张图片文件(或纹理)，通常都会浪费大量资源。一个解决方案就是使用单张图片去存储所有精灵，称之为<strong>精灵表单</strong>或<strong>图集</strong>。在精灵表单中，可以让精灵打包尽可能靠近，从而减少浪费的无用空间。</p><p>精灵表单的另一个优势就是很多GPU要纹理加载后才能绘制。如果绘制过程中频繁地切换纹理，会造成相当多的性能消耗，特别是对于大一点的精灵。但是如果所有精灵都在一张纹理中，是可以消除切换产生的损耗的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/4.png">    <br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/5.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 单独的精灵和打包好的精灵表单</div></center><h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><p>在相对简单的2D游戏里，比如《吃豆人》和《俄罗斯方块》，所有元素都在一个屏幕里。在更复杂的2D游戏里，游戏世界经常比单个屏幕大。对于这些游戏，一个更常见的方法就是关卡随着角色移动而滚动。</p><h3 id="单轴滚屏"><a href="#单轴滚屏" class="headerlink" title="单轴滚屏"></a>单轴滚屏</h3><p>在<strong>单轴滚屏</strong>游戏中，游戏只沿x轴或者y轴滚动。最简单的方法就是把关卡背景按屏幕大小进行切割。一关可能有20-30个片段，绝对比单张图片大得多。加载的时候，图片可以以片段为单位放置游戏世界中。如果背景精灵从左上角开始画，那么每个片段的坐标计算也相当容易。在每个背景放到正确位置后，可以将其加载到一张链表中。水平滚动的初始化代码可以像下面这样:</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/6.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 单轴滚动的Jetpack Joyride</div></center><pre><code>const int screenWidth = 960 //一台iPhone 4/4s屏幕大小为960x640//所有屏幕大小的背景图string backgrounds[] = {"bg1.png", "bg2.png", /*...*/}//所有水平拜访的屏幕大小的背景图数量int hCount = 0foreach string s in backgrounds    Sprite bgSprite    bgSprite.image.Load(s)    //第1个屏幕在x=0处，第2个在x=960处，第3个在x=1920处......    bgSprite.x = hCount * screenWidth    bgSprite.y = 0    bgSpriteList.Add(bgSprite)    screenCount++loop</code></pre><p>在bgSpriteList装载完毕后，需要决定哪些背景需要绘制及绘制在什么地方。如果背景片段屏幕尺寸相同，那么同时最多只有两张背景需要绘制。需要一种方法去跟踪屏幕显示正确的背景。</p><p>一种常见的方法就是让摄像机也在游戏世界中拥有坐标。摄像机最开始放在第一张背景的位置。在水平滚屏的过程中，摄像机的x位置设置为玩家的x位置，只要位置不超过第一张背景和最后一张背景的范围就没问题。</p><p>虽然这样可以通过if判断各种情况，但是随着这样的判断越来越多，游戏会变得很复杂。一个不错的方案就是使用clamp函数，它能让某个值在最大值和最小值之间。在这种情况下，可以设置摄像机x位置等于玩家x位置，然后把x值维护在最大值和最小值之间。</p><pre><code>//camera.x就是player.x在区间中经过clamp的值camera.x = clamp(player.x, screenWidth / 2, bCount * screenWidth - screenWidth / 2)Iterator i = bgSpriteList.begin()while i != bgSpriteList.end()    Sprite s = i.value()    //找到第1张图片来绘制    if (camera.x - s.x) &lt; screenWidth        // 第1张图: s.x = 0, camera.x = 480, screenWidth/2 = 480        draw s at (s.x - camera.x + screenWidth/2, 0)        //绘制第1张背景图后，找第2张        i++        s= i.value()        draw s at (s.x - camera.x + screenWidth/2, 0)        break    end    i++loop</code></pre><p>上面的代码实现了摄像机和玩家在关卡中的前进和后退。如果希望让摄像机只朝前移动，只需在玩家x位置比摄像机x位置大的时候更新即可。</p><h3 id="无限滚屏"><a href="#无限滚屏" class="headerlink" title="无限滚屏"></a>无限滚屏</h3><p><strong>无限滚屏</strong>就是当玩家失败才停止滚屏的游戏。当然，这里不可能有无限多个背景来滚屏。因此游戏中的背景会重复出现。当然，大部分无限滚屏游戏都拥有大量的背景图片和很好的随机性来产生丰富的背景。通常游戏都会用连续的四五张图片组成序列，有了不同系列的图片可选后再打乱重组。</p><h3 id="平行滚屏"><a href="#平行滚屏" class="headerlink" title="平行滚屏"></a>平行滚屏</h3><p>在平行滚屏中，背景拆分成几个不同深度的层级。每一层都用不同的速度来滚动以制造不同深度的假象。</p><p>单轴滚屏中的伪代码可以替换成多个背景同时滚屏。为了实现平行滚屏效果，当计算精灵相对于摄像机偏移时，需要每层都给出一个额外的因子。</p><pre><code>//一个比较靠近的层级以1/5的速度移动float speedFactor = 0.2fdraw s at (s.x - (camera.x - screenWidth/2) * speedFactor, 0)</code></pre><h3 id="四向滚屏"><a href="#四向滚屏" class="headerlink" title="四向滚屏"></a>四向滚屏</h3><p>在四向滚屏中，游戏世界会在水平和垂直方向上滚动。由于两个方向上都滚屏，同一时刻屏幕会显示4个背景片段。</p><p>为了让之前的水平滚屏代码在两个方向上都能动，需要检查摄像机的y位置是否需要更新。但在此之前，需要声明一些变量，记录屏幕高度和关卡垂直方向上有多少个片段:</p><pre><code>const int screenHeight = 640 //iPhone 4/4s的水平方向上的高度int vCount = 2</code></pre><p>我们固定左上角的游戏世界坐标为(0,0)。由于可以垂直滚屏，故需要更新摄像机的y位置:</p><pre><code>camera.y = clamp(player.y, screenHeight / 2, vCount * screenHeight - screenHeight / 2)</code></pre><p>计算精灵相对于摄像机的新位置要考虑y位置:</p><pre><code>draw s at (s.x - camera.x + screenWidth / 2, s.y - camera.y - screenHeight / 2)</code></pre><p>要判定哪些背景片段需要绘制，不能再用水平滚屏的方式去做。那是因为不再是更新单个精灵列表。一个基本的方法就是使用二维数组记录片段，然后判断哪一行哪一列需要在屏幕上显示。一旦片段计算出来，计算其他3个也很简单:</p><h2 id="砖块地图"><a href="#砖块地图" class="headerlink" title="砖块地图"></a>砖块地图</h2><p>如果你想要开发类似《塞尔达传说》那样的2D俯视角色扮演游戏，会有着大量的野外区域和地下城，你可使用<strong>砖块地图</strong>来绘制这些关卡。砖块地图通过把游戏世界分割成等分的方块(或者其他多边形)，每个方块代表的精灵占据着某一块网格位置。这些引用的精灵可以放在多张或者一张<strong>砖块集合</strong>里。所以如果树木在砖块集合中的索引号为0，每个表示树木的方块都可以用0表示。</p><p>虽然正方形是砖块地图的最常见形式，但这不是必需的。一些游戏采用六边形，有的则采用平行四边形。这取决与你希望的视角。</p><h3 id="简单的砖块地图"><a href="#简单的砖块地图" class="headerlink" title="简单的砖块地图"></a>简单的砖块地图</h3><p>首先要确定砖块的尺寸。虽然这在很大程度上取决于设备，但是很多智能手机上的游戏都采用32x32像素，这就意味着在分辨率960x640的手机上，单个屏幕都能显示30x20个砖块。</p><p>设置好砖块的尺寸后，下一步就是创建游戏使用的砖块。所有砖块都放进一张精灵表单中。渲染程序需要通过砖块ID得到真正的图片。一个简单的方法是让左上角的砖块ID为0，往右就加1，以此类推。</p><p>在设计好砖块集合之后，就可以利用砖块集合涉及关卡数据了。虽然关卡数据可以硬编码为二维数组，但是存储在外部文件会更好一些。这个文件最常见的格式就是按照屏幕显示的方式，用砖块ID去表示。因此5x5的砖块关卡会像这样:</p><pre><code>//基本关卡文件格式5,50,0,1,0,00,1,1,1,01,1,2,1,10,1,1,1,00,0,1,0,0</code></pre><p>关卡可以用下面的类表示:</p><pre><code>class Level    const int tileSize = 32    int width, height    int tiles[][]    function Draw()end</code></pre><p>tiles数组存储了关卡的ID，而宽高对应了数组的行列。虽然读取关卡数据的代码是由具体的程序语言决定的，但是解析这个文件非常简单。在完成解析程序之后，下一步就是实现关卡的绘制函数:</p><pre><code>function Draw()    for int row =0, row &lt; height, row++        for int col = 0, col &lt; width, col++            //在(col*tileSize, row*tileSize)绘制tiles[row][col]        end    loopend</code></pre><p>值得注意的是，可以为同一个砖块ID使用不同图片。这就可以实现游戏中常见的季节性的“皮肤”功能。</p><h3 id="斜视等视角砖块地图"><a href="#斜视等视角砖块地图" class="headerlink" title="斜视等视角砖块地图"></a>斜视等视角砖块地图</h3><p>在<strong>斜视等视角</strong>中，视角通过旋转，让场景更具深度感。《暗黑破坏神》和《辐射》都应用了这种视角。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="./assets/7.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 斜视视角场景</div></center><p>实现斜视等视角与普通视角有一些不同。与正方形不同的是，这些砖块要么是六边形要么是平行四边形。运用斜视等视角砖块地图时，会使用多个层次把相邻的砖块作为一组。为了支持多层次，需要更新数据，使其能够表达多个层次。即，渲染代码也需要支持正确的顺序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法和技巧·游戏编程概述</title>
      <link href="/you-xi-bian-cheng-suan-fa-he-ji-qiao-you-xi-bian-cheng-gai-shu/"/>
      <url>/you-xi-bian-cheng-suan-fa-he-ji-qiao-you-xi-bian-cheng-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏编程概述"><a href="#游戏编程概述" class="headerlink" title="游戏编程概述"></a>游戏编程概述</h1><h2 id="一、游戏编程的发展"><a href="#一、游戏编程的发展" class="headerlink" title="一、游戏编程的发展"></a>一、游戏编程的发展</h2><p>世界上第一款商业游戏Computer Space在1971年推出，是后来Atari的创办人Nolan Bushnell和Ted Dabney开发的。这款游戏当时并不是运行在传统计算机上的。它的硬件甚至没有处理器和内存。它只是一个简单的状态机，在多个状态中转换。Computer Space的所有逻辑必须在硬件上完成。</p><p>随着“Atari 2600”在1977年推出，开发者们有了一个开发游戏的平台。这正是游戏开发变得更加软件化的时候，再也不用涉及复杂的硬件了。虽然这一节的焦点在于家用机开发，但是在PC机上也仍然适用。在PC机上不同之处在于，PC技术通常都会领先家用机几年。这是因为家用机推出的时候，它的硬件就会被锁定5年多，称为一个“世代”，而PC机则是以惊人的速度发展着。可是家用机的优点也在于其锁定了硬件，使得程序员可以有效利用机能。这就是为什么新时代的The Last of Us与PC机上的游戏相比仍然有着惊人的画质表现。</p><p>不管如何，家用机自Atari在1977年推出Atari 2600之后并没有大的变化。在此之前，已经有好几种家用游戏系统，但是这些系统都是很受限的。它们的游戏都是只能预装的，而且这些游戏只能在特定平台下玩。在游戏基于卡带后，游戏市场才开始真正地打开。</p><h3 id="Atari时期-1977-1985年"><a href="#Atari时期-1977-1985年" class="headerlink" title="Atari时期(1977-1985年)"></a>Atari时期(1977-1985年)</h3><p>虽然Atari 2600不是第一个通用的游戏系统，但只有它成功了。大多数Atari游戏开发周期短，也基本只靠一个人完成。</p><p>这个时期的程序员需要对底层硬件有一定的理解。CPU运行在1.1MHz，内存也只有128字节。因此大多数游戏都是完全用汇编语言开发的。更糟糕的是，调试是完全看个人能力的。没有任何开发工具和SDK(开发代码库)。</p><p>虽然有着这些技术限制，Atari仍然很成功。其中一个作品Pitfall，卖出了400万份。这款由David Crane在1982年设计的游戏，是Atari早期的游戏之一，以人类奔跑动画为特色。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/08/Ufe37nVXKQvhPol.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 @《Pitfall》</div></center><h3 id="NES和SNES时期-1985-1995年"><a href="#NES和SNES时期-1985-1995年" class="headerlink" title="NES和SNES时期(1985-1995年)"></a>NES和SNES时期(1985-1995年)</h3><p>然而到了1983年，北美游戏市场崩溃了。主要原因在于，市场上充斥着大量质量低下的游戏。比如Atari版的Pac-Man及名声不佳的E.T.。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/08/BCr4Kn6AcpXkQtY.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 著名的E.T.</div></center><p>直到1985年推出的红白机(NES)才把产业带回正轨。NES比Atari强大得多，这需要更多的“人时”去开发游戏。很多NES时期的游戏都需要不少程序员去开发。比如初代《塞尔达传说》需要3位著名程序员去开发。</p><p>到了超级任天堂(SNES)时代，开发人员进一步扩大，程序员会分工专门为某个游戏的某个功能进行深度开发。</p><p>NES和SNES的游戏仍然完全用汇编语言开发，因为内存依然不足。幸运的是任天堂有提供SDK(开发代码库)和开发工具，开发者不再像Atari时期那么痛苦。</p><h3 id="PS和PS2时期-1995-2005年"><a href="#PS和PS2时期-1995-2005年" class="headerlink" title="PS和PS2时期(1995-2005年)"></a>PS和PS2时期(1995-2005年)</h3><p>在20世纪90年代中期推出的PS和N64终于可以用高级语言去开发游戏了。两大平台的游戏开发语言以C语言为主，但仍然有一些性能敏感的功能得用汇编语言完成。</p><p>由于高级语言带来了生产力提升，开发团队规模的增长在这个时期有所减缓。</p><h3 id="Xbox360、PS3和Wii时期-2005-2013年"><a href="#Xbox360、PS3和Wii时期-2005-2013年" class="headerlink" title="Xbox360、PS3和Wii时期(2005-2013年)"></a>Xbox360、PS3和Wii时期(2005-2013年)</h3><p>家用机的高画质表现导致游戏开发进入了两种境地。AAA游戏变得更加庞大，也有着相应庞大的团队和费用。而独立游戏则跟过去的小团队开发规模相仿。</p><p>对于AAA游戏，开发团队的规模增长让人震惊。《刺客信条：启示录》(Assassin’s Creed: Revelations)参与开发的程序员总人数达75人。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://i.loli.net/2019/08/08/pQ5enXiCIubFmKY.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    font-size: 12px;    padding: 2px;">图 @《刺客信条：启示录》</div></center><p>对于独立游戏开发者来说，数字分发平台拯救了他们。随着XBLA、PSN、Steam及App store等平台的出现，使得游戏不再需要走传统发布渠道。独立游戏的规模也远比AAA游戏要小。</p><p>游戏编程的另一个大的开发趋势就是<strong>中间件</strong>及开源的出现。有的中间件是完整的游戏引擎，比如Unreal、Unity。有的则是专门地做某个系统，比如物理引擎Havok Physics。这样就节省了大量的人力、财力。但是缺点就是某个策划功能可能会受到中间件的限制。</p><h3 id="游戏的未来"><a href="#游戏的未来" class="headerlink" title="游戏的未来"></a>游戏的未来</h3><p>脱离移动和Web平台去讨论游戏的未来，是不完整的，因为它们的重要性越来越明显。移动设备的性能提升得飞快，这就导致了越来越多的3D游戏在移动平台开发。</p><p>但这不是说传统的家用机平台就没有进展了。索尼以及微软也早已开始了新一代主机项目，任天堂的switch也已经推出。AAA游戏仍然会扩展它们的团队，团队成员会更加专业。游戏产业的未来真是让人激动和期待。</p><p>尽管游戏开发多年来有许多变迁，有趣的是，许多早期概念到现在仍然使用。</p><h2 id="二、游戏循环"><a href="#二、游戏循环" class="headerlink" title="二、游戏循环"></a>二、游戏循环</h2><p>整个游戏程序的核心流程控制称为<strong>游戏循环</strong>。之所以是一个循环，是因为游戏总是不断地执行一系列动作直到玩家退出。每迭代一次游戏循环为1<strong>帧</strong>。大部分实时游戏每秒钟更新30-60帧。如果一个游戏跑60FPS（<strong>帧/秒</strong>），那么这个游戏循环每秒要执行60次。</p><p>游戏开发中有着各种各样的游戏循环，选择上需要考虑许多因素，其中以硬件因素为主。</p><h3 id="传统的游戏循环"><a href="#传统的游戏循环" class="headerlink" title="传统的游戏循环"></a>传统的游戏循环</h3><p>一个传统的游戏循环可以分成3部分：处理输入、更新游戏世界、生成输出。一个基本的游戏循环可能是这样的:</p><pre><code>while game is running    process inputs    update game world    generate outputsloop</code></pre><p>比起字面含义，每一个阶段都会有更深层次的含义。例如<strong>process inputs</strong>会检查各种输入设备，比如键盘、鼠标、手柄。但是这些输入设备并不只输入已经想到的，任何外部的输入在这一阶段都要处理完成。</p><p>比如，多人在线游戏，一个重要的输入就是网络数据，因为游戏状态会直接被这些信息所影响。又比如支持重新播放的游戏，当要重新看之前玩的录像时，就会将录像数据输入。还有一些游戏，输入可能是摄像机、GPS等。所以会有很多中可能的输入数据，取决于游戏的特殊性及所用到的硬件。</p><p><strong>update game world</strong>会执行所有激活并且需要更新的对象。这可能会有成千上万个游戏对象。</p><p>对于<strong>generate outputs</strong>，最耗费计算量的输出通常就是将图形渲染成2D或3D。另外还有其他一些输出，比如音频，涵盖了音效、背景音乐、对话，跟图形输出同样重要。还有，家用机手柄通常会有振动效果，随着游戏进程振动，它也是一个需要输出的效果，也叫作<strong>力回馈</strong>。对于多人游戏，游戏中需要输出数据给其他玩家。</p><h3 id="多线程下的游戏循环"><a href="#多线程下的游戏循环" class="headerlink" title="多线程下的游戏循环"></a>多线程下的游戏循环</h3><p>虽然很多移动和独立游戏仍然使用传统的游戏循环，但是大部分AAA家用机和PC机游戏都已经不用了，因为现在CPU都有多个核。这意味着CPU可以在物理上同时执行多指令或者多<strong>线程</strong>。</p><p>图形渲染对于AAA级别游戏来说是非常耗时的。在渲染管线的过程中有多个步骤，而且还有大量的数据需要处理。假设对于某个游戏来说，渲染整个场景需要30毫秒，它还需要额外的20毫秒去更新游戏世界。如果这些都在同一个线程执行，每帧将耗时50毫秒，最终导致低帧率——20FPS。但如果渲染和更新逻辑同步执行，每帧只要30ms，30FPS的目标就可以完成。</p><p>为了完成以上想法，主线程必须处理所有输入、更新游戏世界、处理所有图形以外的输出。它必须提交相关数据给第二条线程，那么第二条线程就可以渲染所有图像。</p><p>但是，当渲染线程绘制的时候，主线程该干什么？我们不想它简单地等着渲染结束，因为这样比单线程还慢。解决的办法是让渲染线程比主线程慢1帧。这个方法的缺点就是会增加<strong>输入延迟</strong>，玩家的输入要更久才能在画面上有所反馈。假设跳跃键在第2帧就按下。在多线程游戏循环下，输入直到第3帧才开始处理。图形要到第4帧结束才能看到。</p><h2 id="三、时间和游戏"><a href="#三、时间和游戏" class="headerlink" title="三、时间和游戏"></a>三、时间和游戏</h2><p>大多数游戏都有关于时间进展(progression of time)的概念。对于实时游戏，时间进展通常都很快。比如30FPS(Frame Per Second)的游戏，每帧大约用时33ms。即使是回合制游戏也是通过时间进展来完成功能的，只不过它们使用回合来计数。</p><h3 id="真实时间和游戏时间"><a href="#真实时间和游戏时间" class="headerlink" title="真实时间和游戏时间"></a>真实时间和游戏时间</h3><p><strong>真实时间</strong>，就是从真实世界流逝的时间；<strong>游戏时间</strong>，就是从游戏世界流逝的时间。区分它们很重要，虽然通常都是1:1，但不总是这样。</p><h3 id="通过处理时间增量来表示游戏逻辑"><a href="#通过处理时间增量来表示游戏逻辑" class="headerlink" title="通过处理时间增量来表示游戏逻辑"></a>通过处理时间增量来表示游戏逻辑</h3><p>早期的游戏经常以特定处理器速度来处理逻辑。例如，处理敌人位置的代码可能如下:</p><pre><code>// 更新x位置5个像素enemy.position.x += 5</code></pre><p>在这种情况下，敌人一定伪代码每秒执行30次(30FPS)，敌人在1秒就移动150个像素。可是在60FPS的帧率下，敌人在同样的1秒会移动300个像素。为了解决这样的问题，需要引入<strong>增量时间</strong>的概念：从上一帧起流逝的时间。</p><p>为了应用增量时间，先前的伪代码中的移动不能再使用每帧移动的像素来表示，而是应该使用每秒移动的像素。如果理想的移动速度是每秒150像素，那么代码可以改成这样:</p><pre><code>// 更新x位置150像素/每秒enemy.position.x += 150 * deltaTime</code></pre><p>现在代码不管帧率如何都能正常工作。在30FPS的帧率下，敌人会每帧移动5个像素，总共每秒150个像素。在60FPS的帧率下，敌人每秒只会移动2.5个像素，但总共还是每秒150个像素。虽然在60FPS下的移动更加平滑，但是总体上每秒的移动速度是一致的。</p><p>如何计算每帧的增量时间呢?首先，上一帧所流逝的真实时间是可以得到的。一旦得到流逝的真实时间，我们就可以算出游戏时间。取决于游戏的状态，有可能与真实时间一致也有可能被乘上一个因子。</p><p>改进后的游戏循环如下。</p><pre><code>while game is running    realDeltaTime = time since last frame    gameDeltaTime = realDeltaTime * gameTimeFactor    //进程输入    ···    update game world with gameDeltaTime    //渲染输出    ···loop</code></pre><p>虽然能够在不同帧率下都正确执行，但还是会有一些问题。首先是任何与物理相关的游戏(比如平台跳跃类)在帧率的表现上都会很不一样。这是数值积分的原因。这会导致奇怪的角色行为，比如在低帧率下跳得更高。还有就是那些支持多人互动的游戏，可能在不同帧率下导致行为异常。</p><p>这个问题最简单的解决方法就是限制帧率，强制游戏循环等待到指定帧率才继续。比如一个目标帧率为30FPS的游戏，如果游戏循环本身只用了30ms，那么还要等待额外的3.3ms才能开始执行下一次的游戏循环。</p><pre><code>//30FPS每帧33.3mstargetFrameTime = 33.3fwhile game is running    realDeltaTime = time since last frame    gameDeltaTime = realDeltaTime * gameTimeFactor    //处理输入    ···    update game world with gameDeltaTime    //渲染输出    ···    while (time spent this frame) &lt; targetFrameTime        //做一些事情将多出的时间用完        ···    looploop</code></pre><p>还有一种情况需要考虑：如果游戏突然遇上复杂情形，导致某帧比目标帧率的时长长怎么办？有很多解决办法，最常见的就是为了跟上目标帧率，而丢弃这一帧的渲染。这就是有名的<strong>卡帧</strong>，这么做会引起视觉上的卡顿。你可能会注意到有时候玩游戏的时候，做某些事情就会卡一下。</p><h2 id="四、游戏对象"><a href="#四、游戏对象" class="headerlink" title="四、游戏对象"></a>四、游戏对象</h2><p>广义上的<strong>游戏对象</strong>是每一帧都需要更新或者绘制的对象。虽然叫做“游戏对象”，但不意味着就必须用传统的面向对象。有的游戏采用传统的对象，也有的用组合或者其他复杂的方法。不管如何实现，游戏都需要跟踪管理这些对象，在游戏循环中把它们整合起来。在处理整合游戏对象之前，先看3种游戏对象。</p><h3 id="游戏对象的类型"><a href="#游戏对象的类型" class="headerlink" title="游戏对象的类型"></a>游戏对象的类型</h3><p>在3种游戏对象中，最常见的就是更新和绘制都需要的对象。任何角色、生物或者可以移动的物体都需要在游戏循环中的update game world阶段更新，还要在generate outputs阶段渲染。</p><p>只绘制不更新的对象，称为<strong>静态对象</strong>。这些对象就是那些玩家可以看到，但是永远不需要更新的对象。它可以是游戏背景中的建筑。一栋建筑不会移动也不会攻击玩家，但是需要绘制。</p><p>第三种游戏对象，就是那些需要更新，但不需要绘制的对象。例如，摄像机和<strong>触发器</strong>。</p><h3 id="游戏循环中的游戏对象"><a href="#游戏循环中的游戏对象" class="headerlink" title="游戏循环中的游戏对象"></a>游戏循环中的游戏对象</h3><p>有很多方法来表示游戏对象。其中一种就是面向对象中的接口。<strong>接口</strong>更像是一种契约。如果一个类实现了这个接口，那么就相当于要按照契约去实现这个接口中所有的函数。</p><p>首先，需要由一个基础的游戏对象类，使得3种游戏对象都可以从这里继承:</p><pre><code>class GameObject    //成员变量/函数    ...end</code></pre><p>任何游戏对象公用的功能，不管什么对象类型，都应该放在基类里。这样就可以声明两个接口，一个是Drawable对象，一个是Updateable对象:</p><pre><code>interface Drawable    function Draw()endinterface Updateable    function Update(float deltaTime)end</code></pre><p>一旦有了这两个接口，就可以通过两个接口和一个基类来表示3种游戏对象：</p><pre><code>//只更新的游戏对象class UGameObject inherits GameObject, implements Drawable    //重载绘制函数    ...end//只渲染的游戏对象class DGameObject inherits GameObject, implements Drawable    //重载绘制函数    ...end//更新且绘制的游戏对象class DUGameObject inherits UGameObject, implements Drawable    //重载绘制和更新函数    ...end</code></pre><p>在实现这3种对象后，把它们整合在游戏循环中是很简单的。GameWorld类拥有两个列表，分别在游戏世界中管理Updateable对象和Drawable对象:</p><pre><code>class GameWorld    List updateableObjects    List drawableObjectsend</code></pre><p>游戏对象被创建出来后，必须添加到相应的列表中。相应的，删除游戏对象也要讲其从列表移除。在存储了所有游戏对象之后，就可以将游戏循环中的update game world部分完成。</p><pre><code>while game is running    realDeltaTime = time since last frame    gameDeltaTime = realDeltaTime * gameTimeFactor    //处理输入    ...    //更新游戏世界    foreach Updateable  o in GameWorld.updateableObjects        o.Update(gameDeltaTime)    loop    //渲染输出    foreach Drawable o in GameWorld.drawableObejcts        o.Draw()    loop    //帧数限制代码    ...</code></pre><h2 id="四、相关资料"><a href="#四、相关资料" class="headerlink" title="四、相关资料"></a>四、相关资料</h2><h3 id="游戏编程的发展"><a href="#游戏编程的发展" class="headerlink" title="游戏编程的发展"></a>游戏编程的发展</h3><p><strong>Crane David. “GDC 2011 Classic Postmortem on Pitfall!”</strong><a href="http://tinyurl.com/6kwpfee" target="_blank" rel="noopener">http://tinyurl.com/6kwpfee</a>.Pitfall!的作者David Crane的1小时演讲，关于在Atari上开发的心得</p><h3 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h3><p><strong>Gregory, Json. Game Engine Architecture. Boca Raton: A K Peters, 2009.</strong> 这本书用了几节篇幅讲了多种多线程下的游戏循环，包括在PS3的非对称CPU架构上使用的情况</p><p><strong>West,Mick. “Programming Responsiveness”和”Measuring Responsiveness”</strong> (<a href="http://tinyurl.com/594f6r" target="_blank" rel="noopener">http://tinyurl.com/594f6r</a> 和 <a href="">http://tinyurl.com/5qv5zt</a>).这些是Mick West在Gamasutra上写的文章，讨论了那些导致输入延迟的因素，同时也对游戏中的输入延迟进行了测量</p><h3 id="游戏对象"><a href="#游戏对象" class="headerlink" title="游戏对象"></a>游戏对象</h3><p><strong>Dickheiser,Michael.Ed.Game Programning Gems 6. Boston:Charles River Media, 2006.</strong> 这卷书中的一篇文章“Game Object Component System”讲了一种与传统面向对象模型所不同的方法。虽然实现上有点复杂，但是越来越多的商业游戏中的游戏对象通过组合的形式来实现</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深切哀悼为抗击疫情牺牲的同胞</title>
      <link href="/shen-qie-ai-dao-wei-kang-ji-yi-qing-xi-sheng-de-tong-bao/"/>
      <url>/shen-qie-ai-dao-wei-kang-ji-yi-qing-xi-sheng-de-tong-bao/</url>
      
        <content type="html"><![CDATA[<p>我仅代表自己和我的家人深深感恩在这场抗疫中逝去的医务工作者，志愿者以及一群又一群平凡的人，在危难中挺身而出，在重压下义无反顾。我们不会忘记，他们平凡而又伟大的人生，愿逝者安息！</p><p><img src="maxresdefault.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表5-函数</title>
      <link href="/c-primer-zhu-yu-biao-5-han-shu/"/>
      <url>/c-primer-zhu-yu-biao-5-han-shu/</url>
      
        <content type="html"><![CDATA[<p>函数是一个命名了的代码库，我们通过调用函数执行相应的代码。</p><h1 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1.函数基础"></a>1.函数基础</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>函数（function）</strong></td><td>可调用的计算单元</td></tr><tr><td><strong>函数体（function body）</strong></td><td>是一个块，用于定义函数所执行的操作</td></tr><tr><td><strong>()运算符（()operator）</strong></td><td>调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）</td></tr><tr><td><strong>对象生命周期（object lifetime）</strong></td><td>每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象</td></tr><tr><td><strong>局部变量（local variable）</strong></td><td>定义在块中的变量</td></tr><tr><td><strong>隐藏名字（hidden name）</strong></td><td>某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体</td></tr><tr><td><strong>自动对象（automatic object）</strong></td><td>仅存在于函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象：当到达了定义所在的块的末尾时，销毁该对象</td></tr><tr><td><strong>局部静态对象（local static object）</strong></td><td>它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁</td></tr><tr><td><strong>函数原型（function prototype）</strong></td><td>函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型</td></tr><tr><td><strong>分离式编译（separate compliation）</strong></td><td>把一个程序分割成多个独立源文件的能力</td></tr><tr><td><strong>链接（link）</strong></td><td>是一个编译过程，负责把若干对象文件链接起来形成可执行程序</td></tr><tr><td><strong>可执行文件（executable file）</strong></td><td>是操作系统能够执行的文件，包含着与程序有关的代码</td></tr><tr><td><strong>对象文件（object file）</strong></td><td>编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件</td></tr><tr><td><strong>对象代码（object code）</strong></td><td>编译器将我们的源代码转换成对象代码格式</td></tr></tbody></table><pre><code>//函数的形参列表void f1(){ /*...*/ }        //隐式地定义空形参列表void f2(void){ /*...*/ }    //显式地定义空形参列表//局部静态对象size_t count_calls(){    static size_t ctr = 0;      //调用结束后，这个值仍然有效    return ++ctr;}int main(){    //输出从1到10的数字    for(size_t i = 0; i != 10; ++i)        cout &lt;&lt; count_calls() &lt;&lt; endl;    return 0;}</code></pre><h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2.参数传递"></a>2.参数传递</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>形参（parameter）</strong></td><td>在函数的形参列表中声明的局部变量。用实参初始化形参。</td></tr><tr><td><strong>实参（argument）</strong></td><td>函数调用时提供的值，用于初始化函数的形参</td></tr><tr><td><strong>引用传递（pass by reference）</strong></td><td>描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上</td></tr><tr><td><strong>值传递（pass by value）</strong></td><td>描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本</td></tr><tr><td><strong>传引用调用（call by reference）</strong></td><td>参见引用传递</td></tr><tr><td><strong>传值调用（call by value）</strong></td><td>参见值传递</td></tr><tr><td><strong>initializer_list</strong></td><td>是一个标准类，表示的是一个组花括号包围的类型相同的对象，对象之间以逗号隔开</td></tr></tbody></table><pre><code>//指针形参void reset(int *ip){    *ip = 0;    //改变指针ip所指对象的值    ip = 0;     //只改变了ip的局部拷贝，实参未被改变}//const形参void fcn(const int i){/* fcn能够读取i，但是不能向i写值 */}  //既可以传入const int也可以传入intvoid fcn(int i){}   //错误：重复定义了fcn(int)/* 数组形参 *///尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);    //可以看出来，函数的意图是作用于一个数组void print(const int[10]);  //这里的维度表示我们期望数组含有多少元素，实际不一定//多维数组//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组void print(int (*matrix)[10], int rowSize){}//等价定义void print(int matrix[][10], int rowSize){}/* 可变形参 */void error_msg(initializer_list&lt;string&gt; il){    for(auto beg = il.begin(); beg != il.end(); ++beg)        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;}//调用//expected和actual是string对象if(expected != actual)    error_msg({&quot;funxtionX&quot;, expected, actual});else    error_msg({&quot;functionX&quot;, &quot;okay&quot;});</code></pre><h1 id="3-返回类型"><a href="#3-返回类型" class="headerlink" title="3.返回类型"></a>3.返回类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>返回类型（return type）</strong></td><td>是函数声明的一部分，用于指定函数返回值的类型</td></tr><tr><td><strong>递归函数（recursive function）</strong></td><td>直接或间接调用自身的函数</td></tr><tr><td><strong>递归循环（recursion loop）</strong></td><td>描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程</td></tr><tr><td><strong>尾置返回类型（trailing return type）</strong></td><td>把参数列表后面指定的返回类型</td></tr></tbody></table><pre><code>//不要返回局部对象的引用或指针，因为函数完成后，它所占用的存储空间也随之被释放掉//严重错误：这个函数试图返回局部对象的引用const string &amp;manip(){    string ret;    //以某种方式改变一下ret    if(!ret.empty())        return ret;         //错误：返回局部对象的引用    else        return &quot;Empty&quot;;     //错误：&quot;Empty&quot;是一个局部临时量}//调用一个返回引用的函数得到左值，其他返回类型得到右值char &amp;get_val(string &amp;str, string::size_type ix){    return str[ix];}int main(){    string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl;    get_val(s, 0) = &#39;A&#39;;        //将s[0]的值改为A    cout &lt;&lt; s &lt;&lt; endl;    return 0;}//列表初始化返回值vector&lt;string&gt; process(){    //...    //expected和actual是string对象    if(expected.empty())        return {};              //返回一个空vector对象    else if(expected == actual)        return {&quot;functionX&quot;, &quot;okay&quot;};   //返回列表初始化的vector对象    else        return {&quot;functionX&quot;, expected, actual};}//使用尾置返回类型//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10];//使用decltypeint odd[] = {1, 3, 5, 7, 9};int even[] = {0, 2, 4, 6, 8};//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i){    return (i % 2) ? &amp;odd : &amp;even;  //返回一个指向数组的指针}</code></pre><h1 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>重载函数（overloaded function）</strong></td><td>函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别</td></tr><tr><td><strong>函数匹配（function matching）</strong></td><td>编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较</td></tr><tr><td><strong>重载确定（overload resolution）</strong></td><td>参见函数匹配</td></tr><tr><td><strong>最佳匹配（best match）</strong></td><td>从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差</td></tr><tr><td><strong>无匹配（no match）</strong></td><td>是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配</td></tr><tr><td><strong>二义性调用（ambiguous call）</strong></td><td>是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</td></tr><tr><td><strong>候选函数（candidate function）</strong></td><td>解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内</td></tr><tr><td><strong>可行函数（viable function）</strong></td><td>是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型</td></tr></tbody></table><pre><code>Record lookup(const Account&amp;);      //根据Account查找记录Record lookup(const Phone&amp;);        //根据Phone查找记录Record lookup(const Name&amp;);         //根据Name查找记录Account acct;Phone phone;Record r1 = lookup(acct);Record r2 = lookup(phone);//顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来Record lookup(Phone);Record lookup(const Phone);     //重复声明了Record lookup(Phone*);Record lookup(Phone* const);    //重复声明//如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的Record lookup(Account&amp;);        //函数作用于Account的引用Record lookup(const Account&amp;);  //新函数，作用于常量引用Record lookup(Account*);        //新函数，作用于指向Account的指针Record lookup(const Account*);  //新函数，作用于指向常量的指针</code></pre><h1 id="5-默认实参、内联函数和预处理宏"><a href="#5-默认实参、内联函数和预处理宏" class="headerlink" title="5.默认实参、内联函数和预处理宏"></a>5.默认实参、内联函数和预处理宏</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>默认实参（default argument）</strong></td><td>当调用缺少了某个实参时，为该实参指定的默认值</td></tr><tr><td><strong>内联函数（inline function）</strong></td><td>请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销</td></tr><tr><td><strong>constexpr</strong></td><td>可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数</td></tr><tr><td><strong>预处理宏（preprocessor marco）</strong></td><td>类似于内联函数的一种预处理功能。除了assert之外，现在C++程序很少再使用预处理宏</td></tr><tr><td><strong>Assert</strong></td><td>是一个预处理宏，作用于一条表示条件的表达式。当未定义预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条错误信息并终止当前程序的执行</td></tr></tbody></table><pre><code>//默认实参string screen(sz, sz, char = &#39; &#39;);string screen(sz, sz, char = &#39;*&#39;);      //错误：重复声明string screen(sz = 24, sz = 80. char);  //正确：添加默认实参//内联版本：寻找两个string对象中较短的那个inline const string &amp;shorterString(const string &amp;s1, const string &amp;s2){    return s1.size() &lt;= s2.size() ? s1 : s2;}//constexpr函数，函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句constexpr int new_sz() {return 42;}constexpr int foo = new_sz();   //正确：foo是一个常量表达式</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表4-语句</title>
      <link href="/c-primer-zhu-yu-biao-4-yu-ju/"/>
      <url>/c-primer-zhu-yu-biao-4-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>C++提供了条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。</p><h1 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1.简单语句"></a>1.简单语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>控制流（flow of control）</strong></td><td>程序的执行路径</td></tr><tr><td><strong>表达式语句（expression statement）</strong></td><td>即一条表达式后面跟上一个分号，令表达式执行求值过程</td></tr><tr><td><strong>空语句（null statement）</strong></td><td>只含有一个分号的语句</td></tr><tr><td><strong>块（block）</strong></td><td>包围在花括号内的由0条或多条语句组成的序列。块也是一条语句，所以只要是能使用语句的地方，就可以使用块</td></tr><tr><td><strong>复合语句（compound statement）</strong></td><td>和块是同义词</td></tr></tbody></table><pre><code>ival + 5;       //一条没什么实际用处的表达式语句cout &lt;&lt; ival;   //一条有用的表达式语句//重复读入数据直至到达文件末尾或某次输入的值等于soughtwhile(cin &gt;&gt; s &amp;&amp; s != sought)    ;   //空语句</code></pre><h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>if语句（if statement）</strong></td><td>判断条件，根据其结果有选择地执行语句。如果条件为真，执行if分支的代码；如果条件为假，控制权转移到if结构之后的第一条语句</td></tr><tr><td><strong>if else语句（if else statement）</strong></td><td>判断条件，根据其结果分别执行if分支或else分支的语句</td></tr><tr><td><strong>悬垂else（dangling else）</strong></td><td>是一个俗语，指的是如何处理嵌套if语句中if分支多于else分支的情况</td></tr><tr><td><strong>switch语句（switch statement）</strong></td><td>一种条件语句</td></tr><tr><td><strong>带标签语句（lebeled statement）</strong></td><td>前面带有标签的语句。所谓标签是指一个标识符以及紧跟着的一个冒号。对于同一个标识符来说，用作标签的同时还能用于其他目的，互不干扰</td></tr><tr><td><strong>case标签（case label）</strong></td><td>在switch语句中紧跟在case关键字之后的常量表达式（参见2.4.4节）。在同一个switch语句中任意两个case标签的值不能相同</td></tr><tr><td><strong>default标签（default label）</strong></td><td>是一种特殊的case标签，当switch表达式的值与所有case标签都无法匹配时，程序执行default标签下的内容</td></tr></tbody></table><pre><code>//注意case true:    //因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法    string file_name;       //错误：控制流绕过一个隐式初始化的变量    int ival = 0;           //错误：控制流绕过一个显式初始化的变量    int jval;               //正确：因为jval没有初始化    break;case false:    //正确：jval虽然在作用域内，但是它没有被初始化    jval = next_num();      //正确：给jval赋一个值    if(file_name.empty())   //file_name在作用域内，但是没有被初始化        //...</code></pre><h1 id="3-迭代语句"><a href="#3-迭代语句" class="headerlink" title="3.迭代语句"></a>3.迭代语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>while语句（while statement）</strong></td><td>只要指定的条件为真，就一直迭代执行目标语句</td></tr><tr><td><strong>for语句（for statement）</strong></td><td>替换迭代执行的迭代语句。常常用于遍历一个容器或者重复计算若干次</td></tr><tr><td><strong>范围for语句（range for statement）</strong></td><td>在一个序列中进行迭代的语句</td></tr><tr><td><strong>do while语句（do while statement）</strong></td><td>与while语句类似，区别是do while语句先执行循环体，再判断条件。循环体代码至少会执行一次</td></tr></tbody></table><h1 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4.跳转语句"></a>4.跳转语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>break语句（break statement）</strong></td><td>终止离它最近的循环或switch语句。控制权转移到循环或switch之后的第一条语句</td></tr><tr><td><strong>continue语句（continue statement）</strong></td><td>终止离它最近的循环的当前迭代。控制权转移到while或do while语句的条件部分、或者范围for循环的下一次迭代、或者传统for循环头部的表达式</td></tr><tr><td><strong>goto语句（goto statement）</strong></td><td>令控制权无条件转移到同一函数中一个指定的带标签语句。goto语句容易造成程序的控制流混乱，应禁止使用</td></tr></tbody></table><h1 id="5-try语句块和异常处理"><a href="#5-try语句块和异常处理" class="headerlink" title="5.try语句块和异常处理"></a>5.try语句块和异常处理</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>异常安全（exception safe）</strong></td><td>是一个术语，表示的含义是当抛出异常后，程序能执行正确的行为</td></tr><tr><td><strong>throw表达式（throw expression）</strong></td><td>一种中断当前执行路径的表达式</td></tr><tr><td><strong>引发（raise）</strong></td><td>含义类似于throw。在C++语言中既可以说抛出异常，也可以说引发异常</td></tr><tr><td><strong>try语句块（try block）</strong></td><td>跟在try关键字后面的块，以及一个或多个catch子句</td></tr><tr><td><strong>catch子句（catch clause）</strong></td><td>由三部分组成：catch关键字、括号里的异常声明以及一个语句块。catch子句的代码负责处理在异常声明中定义的异常</td></tr><tr><td><strong>异常处理代码（exception handler）</strong></td><td>程序某处引发异常后，用于处理该异常的另一处代码。和catch子句是同义词</td></tr><tr><td><strong>异常声明（exception declaration）</strong></td><td>位于catch子句中的声明，指明了该catch子句能处理的异常类型</td></tr><tr><td><strong>terminate</strong></td><td>是一个标准库函数，当异常没有被捕捉到时调用。terminate终止当前程序的执行</td></tr><tr><td><strong>异常类（exception class）</strong></td><td>是标准库定义的一组类，用于表示程序发生的错误</td></tr></tbody></table><pre><code>/* throw表达式 *///首先检查两条数据是否是关于同一种书籍的if(item1.isbn() != item2.isbn())    throw runtime_error(&quot;Data must refer to same ISBN&quot;);//如果程序执行到了这里，表示两个ISBN是相同的cout &lt;&lt; item1 + item2 &lt;&lt; endl;/* try语句块 */try{    program-statements}catch(exception-declaration){    handler-statements}catch(exception-declaration){    handler-statements}   //...</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表6-类</title>
      <link href="/c-primer-zhu-yu-biao-6-lei/"/>
      <url>/c-primer-zhu-yu-biao-6-lei/</url>
      
        <content type="html"><![CDATA[<p>类的基本思想是数据抽象和封装。</p><h1 id="1-定义抽象数据类型"><a href="#1-定义抽象数据类型" class="headerlink" title="1.定义抽象数据类型"></a>1.定义抽象数据类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类（class）</strong></td><td>C++提供的自定义数据类型的机制。类可以包含数据、函数和类型成员。一个类定义一种新的类型和一个新的作用域</td></tr><tr><td><strong>数据抽象（data abstraction）</strong></td><td>着重关注类型接口的一种编程技术。数据抽象令程序员可以忽略类型的实现细节，只关注类型执行的操作即可。数据抽象是面向对象编程和泛型编程的基础</td></tr><tr><td><strong>封装（encapsulation）</strong></td><td>分离类的实现与接口，从而隐藏了类的实现细节。在C++语言中，通过把实现部分设为private完成封装的任务</td></tr><tr><td><strong>接口（interface）</strong></td><td>类型提供的（公有）操作。通常情况下，接口不包含数据成员</td></tr><tr><td><strong>实现（implementation）</strong></td><td>类的成员（通常是私有的），定义了不希望为使用类类型的代码所用的数据及任何操作</td></tr><tr><td><strong>抽象数据类型（abstract data type）</strong></td><td>封装（隐藏）了实现细节的数据结构</td></tr><tr><td><strong>this指针（this pointer）</strong></td><td>是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数。this指针指向代表函数调用者的对象</td></tr><tr><td><strong>成员函数（member function）</strong></td><td>类的函数成员。普通的成员函数通过隐式的this指针与类的对象绑定在一起；静态成员函数不与对象绑定在一起也没有this指针。成员函数可以重载，此时隐式的this指针参与函数匹配的过程</td></tr><tr><td><strong>常量成员函数（const member function）</strong></td><td>一个成员函数，在其中不能修改对象的普通（即既不是static也不是mutable）数据成员。const成员的this指针是指向常量的指针，通过区分函数是否是const可以进行重载</td></tr><tr><td><strong>构造函数（constructor）</strong></td><td>用于初始化对象的一种特殊的成员函数。构造函数应该给每个数据成员都赋一个合适的初始值</td></tr><tr><td><strong>默认构造函数（default constructor）</strong></td><td>当没有提供任何实参时使用的构造函数</td></tr><tr><td><strong>合成默认构造函数（synthesized default constructor）</strong></td><td>对于没有显式地定义任何构造函数的类，编译器为其创建（合成）的默认构造函数。该构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作：否则就对数据成员执行默认初始化</td></tr><tr><td><strong>=default</strong></td><td>一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数</td></tr><tr><td><strong>构造函数初始值列表（constructor initializer list）</strong></td><td>说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表中的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化</td></tr></tbody></table><pre><code>//Sales_data.hstruct Sales_data{    Sales_data() =default;  //默认构造函数    Sales_data(const std::string &amp;a) : bookNo(s){}  //构造函数初始值列表    Sales_data(const std::string &amp;a, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){}   //构造函数初始值列表    Sales_data(std::istream &amp;);    std::string isbn() const{ return this-&gt;bookNo; }  //常量成员函数和this指针    Sales_data&amp; combine(const Sales_data&amp;);    double avg_price() const;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;}//Sales_data的非成员接口函数Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);</code></pre><pre><code>//Sales_data.cpp//在类的外部定义成员函数double Sales_data::avg_price() const{    if(units_sold)        return revenue/units_sold;    else        return 0;}//定义类相关的非成员函数istream &amp;read(istream &amp;is, Sales_data &amp;item){    double price = 0;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    item.revenue = price * item.units_sold;    return is;}ostream &amp;print(ostream &amp;os, const Sales_data &amp;item){    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();}Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs){    Sales_data sum = lhs;       //把lhs的数据成员拷贝给sum    sum.combine(rhs);           //把rhs的数据成员加到sum当中    return sum;}</code></pre><h1 id="2-访问控制与封装"><a href="#2-访问控制与封装" class="headerlink" title="2.访问控制与封装"></a>2.访问控制与封装</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>访问说明符（access specifier）</strong></td><td>包括关键字public和private。用于定义成员对类的用户可见还是只对类的友元和成员可见。在类中说明符可以出现多次，每个说明符的有效范围从它自身开始，到下一个说明符为止</td></tr><tr><td><strong>公有成员（public member）</strong></td><td>定义在public访问说明符之后的成员，可以被类的所有用户访问。通常情况下，只有实现类的接口的函数才被设为public</td></tr><tr><td><strong>私有成员（private member）</strong></td><td>定义在private访问说明符之后的成员，只能被类的友元或类的其他成员访问。数据成员以及仅供类的其他成员访问。数据成员以及仅供类本身使用而不作为接口的功能函数一般设为private</td></tr><tr><td><strong>class关键字（class keyword）</strong></td><td>用于定义类的关键字，默认情况下成员是private的</td></tr><tr><td><strong>struct关键字（struct keyword）</strong></td><td>用于定义类的关键字，默认情况下成员是public的</td></tr><tr><td><strong>友元（friend）</strong></td><td>类向外部提供其非公有成员访问权限的一种机制。友元的访问权限与成员函数一样。友元可以是类，也可以是函数</td></tr></tbody></table><pre><code>class Sales_data{public:             //添加了访问说明符    Sales_data() = default;    Sales_data(const std::string &amp;a) : bookNo(s){}    Sales_data(const std::string &amp;a, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){}    Sales_data(std::istream &amp;);    std::string isbn() const{ return bookNo; }    Sales_data&amp; combine(const Sales_data&amp;);private:            //添加了访问说明符    double avg_price() const;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><pre><code>/* 友元函数 */class Sales_data{//为Sales_data的非成员函数所做的友元声明friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;);friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);//其他成员及访问说明符与之前一致...};//Sales_data接口的非成员组成部分的声明Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);</code></pre><h1 id="3-可变数据成员和类类型"><a href="#3-可变数据成员和类类型" class="headerlink" title="3.可变数据成员和类类型"></a>3.可变数据成员和类类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>可变数据成员（mutable data member）</strong></td><td>这种成员永远不是const，即使它属于const对象。在const函数内可以修改可变数据成员。可以通过在变量的声明中加入mutable关键字做到这一点</td></tr><tr><td><strong>类的声明（class declaration）</strong></td><td>首先是关键字class（或者struct），随后是类名以及分号。如果类已经声明而尚未定义，则它是一个不完全类型</td></tr><tr><td><strong>不完全类型（incomplete type）</strong></td><td>已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是用不完全类型定义指针或者引用是合法的</td></tr><tr><td><strong>前向声明（forward declaration）</strong></td><td>对尚未定义的名字的声明，通常用于表示位于类定义之前的类声明。参见”不完全类型”</td></tr></tbody></table><pre><code>class Screen{public:    void some_member() const;private:    mutable size_t access_ctr;      //可变数据成员，即使在一个const对象内也能被修改};void Screen::some_member() const{    ++access_ctr;       //保存一个计数值，用于记录成员函数被调用的次数}</code></pre><pre><code>class Screen;                   //Screen类的前向声明，对于类型Screen来说，在它声明之后定义之前是一个不完全类型//一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针class Link_screen{    Screen window;    Link_screen *next;    Link_screen *prev;};</code></pre><h1 id="4-类的作用域"><a href="#4-类的作用域" class="headerlink" title="4.类的作用域"></a>4.类的作用域</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类的作用域（class scope）</strong></td><td>每个类定义一个作用域。类作用域比其他作用域更加复杂，类中定义的成员函数甚至有可能使用定义语句之后的名字</td></tr><tr><td><strong>名字查找（name lookup）</strong></td><td>根据名字的使用寻找匹配的声明的过程</td></tr></tbody></table><h1 id="5-构造函数扩展"><a href="#5-构造函数扩展" class="headerlink" title="5.构造函数扩展"></a>5.构造函数扩展</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>委托构造函数（delegating constructor）</strong></td><td>委托构造函数的初始值列表只有一个入口，指定类的另一个构造函数执行初始化操作</td></tr><tr><td><strong>转换构造函数（converting constructor）</strong></td><td>可以用一个实参调用的非显式构造函数。这样的函数隐式地将参数类型转换成类类型</td></tr><tr><td><strong>显式构造函数（explicit constructor）</strong></td><td>可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上explicit关键字就可以将其声明成显式构造函数</td></tr><tr><td><strong>聚合类（aggregate class）</strong></td><td>只含有公有成员的类，并且没有类内初始值或者构造函数。聚合类的成员可以用花括号括起来的初始值列表进行初始化</td></tr></tbody></table><pre><code>/* 委托构造函数 */class Sales_data{public:    //非委托构造函数使用对应的实参初始化成员    Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt*price){ }    //其余构造函数全部委托给另一个构造函数    Sales_data() : Sales_data(&quot;&quot;, 0, 0) {}    Sales_data(std::string s) : Sales_data(s, 0, 0) {}    Sales_data(std::istream &amp;is) : Sales_data() { read(is, *this); }    //其他成员与之前的版本一致};</code></pre><pre><code>/* 转换构造函数 */string null_book = &quot;9-999-99999-9&quot;;//构造一个临时的Sales_data对象//该对象的units_sold和revenue等于0，bookNo等于null_bookitem.combine(null_book);//正确：显式地转换成string，隐式地转换成Sales_dataitem.combine(string(&quot;9-999-99999-9&quot;));//正确：隐式地转换成string，显式地转换成Sales_dataitem.combine(Sales_data(&quot;9-999-99999-9&quot;));/* 显式构造函数 */class Sales_data{public:    Sales_data() = default;    Sales_data(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n) { }    explicit Sales_data(const std::string &amp;s) : bookNo(s){ }    explicit Sales_data(std::istream&amp;);    //其他成员与之前的版本一致};item.combine(null_book);        //错误：string构造函数是explicit的item.combine(cin);              //错误：istream构造函数是explicit的</code></pre><pre><code>/* 聚合类 *///struct成员默认是public的struct Data{    int ival;    string s;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表3-表达式</title>
      <link href="/c-primer-zhu-yu-biao-3-biao-da-shi/"/>
      <url>/c-primer-zhu-yu-biao-3-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>表达式（expression）</strong></td><td>C++程序中最低级别的计算。表达式将运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象，这时就得到了对多个运算符求值的复合表达式</td></tr><tr><td><strong>运算对象（operand）</strong></td><td>表达式在某些值上执行运算，这些值就是运算对象。一个运算符有一个或多个相关的运算对象</td></tr><tr><td><strong>运算符（operator）</strong></td><td>决定表达式所做操作的符号。C++语言定义了一套运算符并说明了这些运算符作用于内置类型时的含义</td></tr><tr><td><strong>结果（result）</strong></td><td>计算表达式得到的值或对象</td></tr><tr><td><strong><a href="https://zh.cppreference.com/w/cpp/language/operator_precedence" target="_blank" rel="noopener">优先级（precedence）</a></strong></td><td>规定了复合表达式中不同运算符的执行顺序。与低优先级的运算符相比，高优先级的运算符组合得更紧密</td></tr><tr><td><strong>结合律（associativity）</strong></td><td>规定具有相同优先级的运算符如何组合在一起。结合律分为左结合律（运算符从左向右组合）和右结合律（运算符从右向左组合）</td></tr><tr><td><strong>求值顺序（order of evaluation）</strong></td><td>是某个运算符的运算对象的求值顺序。大多数情况下，编译器可以选择运算对象求值的顺序。不过运算对象一定要在运算符之前得到求值结果</td></tr><tr><td><strong>一元运算符（unary operators）</strong></td><td>只有一个运算对象参与运算的运算符</td></tr><tr><td><strong>二元运算符（binary operator）</strong></td><td>有两个运算对象参与运算的运算符</td></tr><tr><td><strong>重载运算符（overloaded operator）</strong></td><td>针对某种运算符重新定义的适用于类类型的版本</td></tr><tr><td><strong>左值（lvalue）</strong></td><td>是指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象</td></tr><tr><td><strong>右值（rvalue）</strong></td><td>是指一种表达式，其结果是指而非值所在的位置</td></tr><tr><td><strong>复合表达式（compound expression）</strong></td><td>含有多于一个运算符的表达式</td></tr></tbody></table><h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>&amp;&amp;运算符（&amp;&amp;operator）</strong></td><td>逻辑与运算符，如果两个运算对象都是真，结果才为真。只有当左侧运算对象为真时才会检查右侧对象</td></tr><tr><td><strong>&#124;&#124;运算符（&#124;&#124; operator）</strong></td><td>逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</td></tr><tr><td><strong>!运算符（!operator）</strong></td><td>逻辑非运算符，将它的运算对象的布尔值取反</td></tr><tr><td><strong>短路求值（short-circuit evaluation）</strong></td><td>是一个专有名词，描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值</td></tr><tr><td><strong>++运算符（++operator）</strong></td><td>递增运算符。包括两种形式：前置版本和后置版本</td></tr><tr><td><strong>–运算符（–operator）</strong></td><td>递减运算符。包括两种形式：前置版本和后置版本</td></tr><tr><td><strong>?:运算符（?:operator）</strong></td><td>条件运算符</td></tr><tr><td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td><td>左移运算符，将左侧运算对象的值的（可能是提升后的）副本向左移位，移动的位数由右侧运算对象确定</td></tr><tr><td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td><td>右移运算符，除了移动方向相反，其他性质都和左移运算符类似</td></tr><tr><td><strong>&amp;运算符（&amp;operator）</strong></td><td>位与运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位都是1，所得结果中该位为1；否则所得结果中该位为0</td></tr><tr><td><strong>&#124;运算符（&#124; operator）</strong></td><td>位或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位至少有一个是1，所得结果中该位为1；否则所得结果中该位为0</td></tr><tr><td><strong><del>运算符（</del>operator）</strong></td><td>位求反运算符，生成一个新的整数值。该值的每一位恰好与（可能是提升后的）运算对象的对应位相反</td></tr><tr><td><strong>sizeof</strong></td><td>是一个运算符，返回存储对象所需的字节数，该对象的类型可能是某个给定的类型名字，也可鞥由表达式的返回结果确定</td></tr><tr><td><strong>,运算符（,operator）</strong></td><td>逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，当且仅当右侧运算对象是左值时逗号运算符的结果是左值</td></tr></tbody></table><pre><code>//条件运算符cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;);   //输出pass或者failcout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;     //输出1或者0cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;;       //错误：试图比较cout和60，因为小于运算符的优先级低于移位运算符，所以先输出了grade再进行比较//sizeof运算符Sales_data data, *p;sizeof(Sales_data);         //存储Sales_data类型的对象所占的空间大小sizeof data;                //data的类型的大小，即sizeof(Sales_data)sizeof p;                   //指针所占的空间大小sizeof *p;                  //p所指类型的空间大小，即sizeof(Sales_data)sizeof data.revenue;        //Sales_data的revenue成员对应类型的大小sizeof Sales_data::revenue; //另一种获取revenue大小的方式</code></pre><h1 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>转换（conversion）</strong></td><td>一种类型的值改变成另一种类型的值的过程。C++语言定义了内置类型的转换规则。类类型同样可以转换</td></tr><tr><td><strong>隐式转换（implicit conversion）</strong></td><td>由编译器自动执行的类型转换。假如表达式需要某种特定的类型而运算对象是另外一种类型，此时只要规则允许，编译器就会自动地将运算对象转换成所需的类型</td></tr><tr><td><strong>算术转换（arithmetic conversion）</strong></td><td>从一种算术类型转换成另一种算术类型。在二元运算符的上下文中，为了保留精度，算术转换通常把较小的类型转换成较大的类型</td></tr><tr><td><strong>整型提升（integral promotion）</strong></td><td>把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即short、char等）总是会得到提升</td></tr><tr><td><strong>强制类型转换（cast）</strong></td><td>一种显式的类型转换</td></tr><tr><td><strong>static_cast</strong></td><td>显式地执行某种定义明确的类型转换，常用于替代由编译器隐式执行的类型转换</td></tr><tr><td><strong>const_cast</strong></td><td>一种涉及const的强制类型转换。将底层const对象转换成对应的非常量类型，或者执行相反的转换</td></tr><tr><td><strong>reinterpret_cast</strong></td><td>把运算对象的内容解释成另外一种类型。这种强制类型转换本质上依赖于机器而且非常危险</td></tr><tr><td><strong>dynamic_cast</strong></td><td>和继承及运行时类型识别一起使用</td></tr></tbody></table><pre><code>/* 隐式转换 */int ival = 3.541 + 3;   //结果为6，编译器可能会警告该运算损失了精度int ia[10];     //含有10个整数的数组int* ip = ia;   //ia转换成指向数组首元素的指针//转换成布尔类型char *cp = get_string();if(cp) /*...*/      //如果指针cp不是0，条件为真while(*cp) /*...*/  //如果*cp不是空字符，条件为真//转换成常量int i;const int &amp;j = i;   //非常量转换成const int的引用const int *p = &amp;i;  //非常量的地址转换成const的地址int &amp;r = j, *q = p; //错误：不允许const转换成非常量//类类型转换string s;while(cin &gt;&gt; s)     //while的条件部分把cin转换成布尔值/* 显式转换 *///static_castdouble slope = static_cast&lt;double&gt;(j) / i;  //进行强制类型转换以便执行浮点数除法void *p = &amp;d;                               //正确：任何非常量对象的地址都能存入void*double *dp = static_cast&lt;double*&gt;(p);       //正确：将void*转换回初始的指针类型//const_castconst char *pc;char *p = const_cast&lt;char*&gt;(pc);//正确：但是通过p写值是未定义的行为const char *cp;char *q = static_cast&lt;char*&gt;(cp);       //错误：static_cast不能转换掉const性质static_cast&lt;string&gt;(cp);                //正确：字符串字面值转换成string类型const_cast&lt;string&gt;(cp);                 //错误：const_cast只改变常量属性//reinterpret_castint *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip);string str(pc);                         //错误：可能导致异常的运行时行为，必须牢记pc所指的真实对象是一个int而非字符</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表2-字符串、向量和数组</title>
      <link href="/c-primer-zhu-yu-biao-2-zi-fu-chuan-xiang-liang-he-shu-zu/"/>
      <url>/c-primer-zhu-yu-biao-2-zi-fu-chuan-xiang-liang-he-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>C++语言定义了一个内容丰富的抽象数据类型库。其中，string和vector是两种最重要的标准库类型。内置数组是一种更基础的类型，string和vector都是对它的某种抽象。</p><h1 id="1-命名空间的using声明"><a href="#1-命名空间的using声明" class="headerlink" title="1.命名空间的using声明"></a>1.命名空间的using声明</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>using声明（using declaration）</strong></td><td>令命名空间中的某个名字可被程序直接使用</td></tr></tbody></table><pre><code>#include &lt;iostream&gt;//using声明，当我们使用名字cin时，从命名空间std中获取它using std::cinint main(){    int i;    cin &gt;&gt; i;           //正确    cout &lt;&lt; i;          //错误：没有对应的using声明，必须使用完整的名字    std::cout &lt;&lt; i;     //正确：显式地从std中使用cout    return 0;}</code></pre><h1 id="2-标准库类型string"><a href="#2-标准库类型string" class="headerlink" title="2.标准库类型string"></a>2.标准库类型string</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>容器（container）</strong></td><td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型</td></tr><tr><td><strong>缓冲区溢出（buffer overflow）</strong></td><td>一种严重的程序故障，主要的原因是视图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td></tr><tr><td><strong>string</strong></td><td>是一种标准库类型，表示字符的序列</td></tr><tr><td><strong>拷贝初始化（copy initialization）</strong></td><td>使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本</td></tr><tr><td><strong>直接初始化（direct initialization）</strong></td><td>不使用赋值号（=）的初始化形式</td></tr></tbody></table><pre><code>string s1;                          //默认初始化，s1是一个空字符串string s2 = s1;                     //s2是s1的副本string s3 = &quot;hiya&quot;;                 //s3是该字符串字面值的副本string s4(10, &#39;c&#39;);                 //s4的内容是ccccccccccstring s5 = &quot;hiya&quot;;                 //拷贝初始化string s6(&quot;hiya&quot;);                  //直接初始化string s7(10, &#39;c&#39;);                 //直接初始化，s7的内容是ccccccccccstring s8 = string(10, &#39;c&#39;);        //拷贝初始化，s8的内容是cccccccccc</code></pre><pre><code>//字面值和string对象相加string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;string s3 = s1 + &quot;, &quot; + s2  + &#39;\n&#39;;string s4 = s1 + &quot;, &quot;;              //正确：把一个string对象和一个字面值相加string s5 = &quot;hello&quot; + &quot;, &quot;;         //错误，两个运算对象都不是stringstring s6 = s1 + &quot;, &quot; + &quot;world&quot;;    //正确string s7 = &quot;hello&quot; + &quot;, &quot; + s2;    //错误：不能把字面值直接相加</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>getline</strong></td><td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留</td></tr><tr><td><strong>empty</strong></td><td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假</td></tr><tr><td><strong>size</strong></td><td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type</td></tr><tr><td><strong>size_type</strong></td><td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型</td></tr><tr><td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td><td>标准库类型string定义的输出运算符，负责输出string对象中的字符</td></tr><tr><td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td><td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象</td></tr></tbody></table><pre><code>int main(){    string line;    //每次读入一整行，直至到达文件末尾    while(getline(cin, line))        cout &lt;&lt; line &lt;&lt; endl;    return 0;}</code></pre><pre><code>//每次读入一整行，遇到空行直接跳过while(getline(cin, line))    if(!line.empty())        cout &lt;&lt; line &lt;&lt; endl;string line;//每次读入一整行，输出其中超过80个字符的行while(getline(cin, line))    if(line.size() &gt; 80)        cout &lt;&lt; line &lt;&lt; endl;</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>范围for语句（range for）</strong></td><td>一种控制语句，可以在值的一个特定集合内迭代</td></tr><tr><td><strong>索引（index）</strong></td><td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置</td></tr><tr><td><strong>[]运算符 （[]operator）</strong></td><td>下标运算符</td></tr></tbody></table><pre><code>//范围for语句string s(&quot;Hellow World!!!&quot;);//转换成大写形式for(auto &amp;c : s)        //对于s中的每个字符（注意：c是引用）    c = toupper(c);     //c是一个引用，因此赋值语句将改变s中字符的值cout &lt;&lt; s &lt;&lt; endl;</code></pre><pre><code>//[]运算符//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白for(decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index)    s[index] = toupper(s[index]);   //将当前字符改成大写形式</code></pre><h1 id="3-标准库类型vector"><a href="#3-标准库类型vector" class="headerlink" title="3.标准库类型vector"></a>3.标准库类型vector</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>vector</strong></td><td>是一种标准库类型，容纳某指定类型的一组元素</td></tr><tr><td><strong>类模板（class template）</strong></td><td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息</td></tr><tr><td><strong>实例化（instantiation）</strong></td><td>编译器生成一个指定的模板类或函数的过程</td></tr><tr><td><strong>push_back</strong></td><td>是vector的成员，向vector对象的末尾添加元素</td></tr></tbody></table><pre><code>vector&lt;int&gt; ivec;               //ivec保存int类型的对象vector&lt;Sales_item&gt; Sales_vec;   //保存Sales_item类型的对象vector&lt;vector&lt;string&gt;&gt; file;    //该向量的元素是vector对象//初始化vector&lt;string&gt; v1{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};    //列表初始化vector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);    //错误vector&lt;int&gt; ivec(10, -1);   //10个int类型的元素，每个元素都初始化为-1vector&lt;string&gt; svec(10, &quot;hi!&quot;); //10个string类型的元素，每个都被初始化为&quot;hi!&quot;vector&lt;int&gt; ivec(10);       //10个元素，每个都初始化为0vector&lt;string&gt; svec(10);    //10个元素，每个都是空string对象//从标准输入中读取单词，将其作为vector对象的元素存储string word;vector&lt;string&gt; text;        //空vector对象while(cin &gt;&gt; word){    text.push_back(word);   //把word添加到text后面}//不能用下标形式添加元素vector&lt;int&gt; ivec;   //空vector对象for(decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec[ix] = ix;  //严重错误：ivec不包含任何元素for(decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec.push_back(ix); //正确：添加一个新元素，该元素的值是ix</code></pre><h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4.迭代器"></a>4.迭代器</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>迭代器（iterator）</strong></td><td>是一种类型，用于访问容器中的元素或者在元素之间移动</td></tr><tr><td><strong>迭代器运算（iterator arithmetic）</strong></td><td>是string或vector的迭代器的运算</td></tr><tr><td><strong>begin</strong></td><td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针</td></tr><tr><td><strong>end</strong></td><td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</td></tr><tr><td><strong>尾后迭代器（off-the-end iterator）</strong></td><td>end函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置</td></tr><tr><td><strong>difference_type</strong></td><td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离</td></tr><tr><td><strong>++运算符（++operator）</strong></td><td>是迭代器和指针定义的递增运算符</td></tr><tr><td><strong>-&gt;运算符（-&gt;operator）</strong></td><td>箭头运算符</td></tr></tbody></table><pre><code>string s(&quot;some string&quot;);if(s.begin() != s.end()){   //确保s非空    auto it = s.begin();    //it表示s的第一个字符    *it = toupper(*it);     //将当前字符改成大写形式}vector&lt;int&gt;::iterator it;       //it能读写vector&lt;int&gt;的元素string::iterator it2;           //it2能读写string对象中的字符vector&lt;int&gt;::const_iterator it3;    //it3只能读元素，不能写字符string:const_iterator it4;          //it3只能读字符，不能写字符</code></pre><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>size_t</strong></td><td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小</td></tr><tr><td><strong>指针运算（pointer arithmetic）</strong></td><td>是指针类型支持的算术运算中。指向数组的指针所支持的运算种类与迭代器运算一样</td></tr><tr><td><strong>prtdiff_t</strong></td><td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离</td></tr><tr><td><strong>C风格字符串（C-style string）</strong></td><td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td></tr><tr><td><strong>以空字符结束的字符串（null-terminated string）</strong></td><td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\0’）</td></tr></tbody></table><pre><code>//指针和数组string nums[] = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};    //数组的元素是string对象string *p = &amp;nums[0];                       //p指向nums的第一个元素string *p2 = nums;  //等价于p2 = &amp;nums[0]int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};int *beg = begin(ia);       //指向ia首元素的指针int *last = end(ia);        //指向arr尾元素的下一位置的指针ptrdiff_t n = end(ia) - begin(ia);     //n的类型是ptrdiff_t，值是10，也就是ia中元素的数量//C风格字符串char ca[] = {&#39;C&#39;, &#39;+&#39;, &#39;+&#39;};        //不以空字符结束cout &lt;&lt; strlen(ca) &lt;&lt; endl;         //严重错误：ca没有以空字符结束//比较两个C风格字符串const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different string&quot;;if(ca1 &lt; ca2)           //未定义的：视图比较两个无关地址if(strcmp(ca1, ca2) &lt; 0)    //正确//混用string对象和C风格字符串string s = ca1;char *str = s;      //错误：不能用string对象初始化char*const char *str = s.c_str();    //正确</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表 1-变量和基本类型</title>
      <link href="/c-primer-zhu-yu-biao-1-bian-liang-he-ji-ben-lei-xing/"/>
      <url>/c-primer-zhu-yu-biao-1-bian-liang-he-ji-ben-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>C++语言支持广泛的数据类型。它定义了几种基本内置类型（如字符、整型、浮点数等），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一些更加复杂的数据类型，比如可变长字符串和向量等。</p><h1 id="1-基本内置类型"><a href="#1-基本内置类型" class="headerlink" title="1 基本内置类型"></a>1 基本内置类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>基本类型（base type）</strong></td><td>是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符</td></tr><tr><td><strong>算术类型（arithmetic type）</strong></td><td>布尔值、字符、整数、浮点数等内置类型</td></tr><tr><td><strong>void类型</strong></td><td>是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量</td></tr><tr><td><strong>字节（byte）</strong></td><td>内存中可寻址的最小单元，大多数机器的字节占8位</td></tr><tr><td><strong>字（word）</strong></td><td>在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节</td></tr></tbody></table><pre><code>bool bIsOK = true;          //布尔类型，最下小尺寸未定义char chChar = &#39;a&#39;;          //字符，最小尺寸8位wchar_t chChar2 = L&#39;a&#39;;     //宽字符，最小尺寸16位char16_t chChar3 = u&#39;a&#39;;    //Unicode字符，最下尺寸16位char32_t chChar4 = U&#39;a&#39;;    //Unicode字符，最下尺寸32位short sId = 0;              //短整型，最小尺寸16位int nId = 0;                //整型，最小尺寸16位long lId = 0;               //长整型，最小尺寸32位long long llId = 0;         //长整型，最小尺寸64位float fValue = 1.23f;       //单精度浮点数，最小尺寸6位有效数字double dValue = 1.23;       //双精度浮点数，最小尺寸10位有效数字long double ldValue = 1.23L;//扩展精度浮点数，最小尺寸10位有效数字</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>带符号类型（signed）</strong></td><td>保存正数、负数或0的整型</td></tr><tr><td><strong>无符号类型（unsigned）</strong></td><td>保存大于等于0的整型</td></tr><tr><td><strong>转换（conversion）</strong></td><td>一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换</td></tr><tr><td><strong>定义（definition）</strong></td><td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td></tr><tr><td><strong>未定义（undefined）</strong></td><td>即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题</td></tr></tbody></table><pre><code>unsigned u = 10;int i = -42;std::cout &lt;&lt; i + i &lt;&lt; std::endl;    //输出-84std::cout &lt;&lt; u + i &lt;&lt; std::endl;    //如果int占32位，输出4294967264unsigned u1 = 42, u2 = 10;std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl;  //正确：输出32std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl;  //正确：不过，结果是取模后的值</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>字面值（literal）</strong></td><td>是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值</td></tr><tr><td><strong>字符串（string）</strong></td><td>是一种库类型，表示可变长字符序列</td></tr><tr><td><strong>不可打印字符（noprintable character）</strong></td><td>不具有可见形式的字符，如控制符、退格、换行符等</td></tr><tr><td><strong>转义序列（escape sequence）</strong></td><td>字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数</td></tr></tbody></table><pre><code>L&#39;a&#39;        //宽字符型字面值，类型是wchar_tu8&quot;hi!&quot;     //utf-8字符串字面值42ULL       //无符号整型字面值，类型是unsigned long long1E-3F       //单精度浮点型字面值，类型是float3.14159L    //扩展精度浮点型字面值，类型是long double</code></pre><pre><code>    换行符      \n      横向制表符      \t      报警（响铃）符      \a    纵向制表符  \v      退格符          \b      双引号              \&quot;    反斜线      \\      问号            \?      单引号              \&#39;    回车符      \r      进纸符          \f</code></pre><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>变量（variable）</strong></td><td>命名的对象或引用。C++语言要求变量要先声明后使用</td></tr><tr><td><strong>对象（object）</strong></td><td>是内存的一块区域，具有某种类型，变量是命名了的对象</td></tr><tr><td><strong>类型说明符（type specifier）</strong></td><td>类型的名字</td></tr><tr><td><strong>被初始化（initialized）</strong></td><td>变量在定义的同时被赋予初始值，变量一般都应该被初始化</td></tr><tr><td><strong>列表初始化（list initialization）</strong></td><td>利用花括号把一个或多个初始值放在一起的初始化形式</td></tr><tr><td><strong>默认初始化（default initialization）</strong></td><td>当对象未被显式地附于初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值</td></tr></tbody></table><pre><code>int sum = 0, value,                                 //sum、value和units_sold都是int        units_sold = 0                              //sum和units_sold初值为0Sales_item item;                                    //item的类型是Sales_item，Sales_item是一个自定义类std::string book(&quot;0-201-78345-X&quot;);                  //book通过一个string字面值初始化double price = 109.99, discount = price * 0.16;     //price先被定义并赋值，随后被用于初始化discountdouble salePrice = applyDiscount(price, discount);  //调用函数applyDiscound，然后用函数的返回值初始化salePriceint units_sold{0};              //列表初始化long double ld = 3.1415926536;int a{ld}, b = {ld};            //错误：使用列表初始化且初始值存在丢失信息的危险，则编译器将报错int c(ld), d = ld;              //正确：转换执行，且确实丢失了部分值std::string empty;              //empty默认初始化为一个空串Sales_item item;                //被默认初始化的Sales_item对象</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>分离式编译（separate compilation）</strong></td><td>把程序分割为多个单独文件的能力</td></tr><tr><td><strong>声明（declaration）</strong></td><td>声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用</td></tr><tr><td><strong>声明符（declarator）</strong></td><td>是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有</td></tr><tr><td><strong>定义（definition）</strong></td><td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td></tr></tbody></table><pre><code>extern int i;                   //声明i而非定义iint j;                          //声明并定义jextern double pi = 3.1416;      //定义</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>标识符（identifier）</strong></td><td>标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++保留了一些名字供<a href="https://devdocs.io/cpp-keywords/" target="_blank" rel="noopener">语言</a>本身使用，这些名字不能被用作标识符。</td></tr></tbody></table><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>作用域（scope）</strong></td><td>是程序的一部分，在其中某些名字有意义。C++有几级作用域：<br>- <strong>全局（global）</strong>——名字定义在所有其他作用域之外<br>- <strong>类（class）</strong>——名字定义在类内部<br>- <strong>命名空间（namespace）</strong>——名字定义在命名空间内部<br>- <strong>块（block）</strong>——名字定义在块内部</td></tr><tr><td><strong>在作用域内（in scope）</strong></td><td>名字在当前作用域内可见</td></tr><tr><td><strong>内层作用域（inner scope）</strong></td><td>嵌套（包含）在其他作用域之内的作用域</td></tr><tr><td><strong>外层作用域（outer scope）</strong></td><td>嵌套（包含）着别的作用域的作用域</td></tr></tbody></table><h1 id="3-复合类型"><a href="#3-复合类型" class="headerlink" title="3.复合类型"></a>3.复合类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>复合类型（compound type）</strong></td><td>是一种类型，它的定义以其他类型为基础</td></tr><tr><td><strong>引用（reference）</strong></td><td>是某个对象的别名</td></tr><tr><td><strong>绑定（bind）</strong></td><td>令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起</td></tr></tbody></table><pre><code>int ival = 1024;int &amp;refVal = ival;         //refVal指向ival（是ival的另一个名字）int &amp;refVal2;               //报错：引用必须被初始化refVal = 2;                 //把2赋给refVal指向的对象，此处即是赋给了ivalint ii = refVal;            //与ii = ival执行结果一样int i = 1024, i2 = 2048;    //i和i2都是intint &amp;r = i, r2 = i2;        //r是一个引用，与i绑定在一起，r2是intint i3 = 1024, &amp;ri = i3;    //i3是int，ri是一个引用，与i3绑定在一起int &amp;r3 = i3, &amp;r4 = i2;     //r3和r4都是引用</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>指针（pointer）</strong></td><td>是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0</td></tr><tr><td><strong>&amp;运算符（&amp; operator）</strong></td><td>取地址运算符</td></tr><tr><td><strong>*运算符（ * operator ）</strong></td><td>解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值</td></tr><tr><td><strong>空指针（null pointer）</strong></td><td>值为0的指针，空指针合法但是不指向任何对象</td></tr><tr><td><strong>nullptr</strong></td><td>是表示空指针的字面值常量</td></tr><tr><td><strong>void*</strong></td><td>可以指向任意非常量的指针类型，不能执行解引用操作</td></tr></tbody></table><pre><code>//指针int *ip1, *ip2;     //ip1和ip2都是指向int型对象的指针double dp, *dp2;    //dp2是指向double型对象的指针，dp是double型对象int ival = 42;int *p = &amp;ival;     //p存放变量ival的地址，或者说p是指向变量ival的指针cout &lt;&lt; *p;         //由符号*得到指针p所指的对象，输出42*p = 0;             //由符号*得到指针p所指的对象，即可经由p为变量ival赋值cout &lt;&lt; *p;         //输出0//指向指针的指针int ival = 1024;int *pi = &amp;ival;        //pi指向一个int型的数int **ppi = &amp;pi;        //ppi指向一个int型的指针//指向指针的引用int i = 42;int *pn;            //pn是一个int型指针int *&amp;r = pn;       //r是一个对指针pn的引用r = &amp;i;             //r引用了一个指针，因此给r赋值&amp;i就是令pn指向i*r = 0;             //解引用r得到i，也就是pn指向的对象，将i的值改为0//空指针int *p1 = nullptr;      //等价于int *p1 = 0;int *p2 = 0;            //直接将p2初始化为字面常量0//需要首先#include cstdlibint *p3 = NULL;         //等价于int *p3 = 0;//指针作为判断条件int *pi = 0;        //pi合法，是一个空指针int *pi2 = &amp;ival;   //pi2是一个合法的指针，存放着ival的地址if(pi)              //pi的值是0，因此条件的值为false    //...if(pi2)             //pi2指向ival，因此它的值不是0，条件的值是true    //...//void*指针double obj = 3.14, *pd = &amp;obj;  //正确：void*能存放任意类型对象的地址void *pv = &amp;obj;                //obj可以是任意类型的对象pv = pd;                        //pv可以存放任意类型的指针</code></pre><h1 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4.const限定符"></a>4.const限定符</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>const</strong></td><td>是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化</td></tr></tbody></table><pre><code>const int bufSize = 512;        //输入缓冲区大小bufSize = 1024;                 //错误：试图向const对象写值const int i = get_size();   //正确：运行时初始化const int j = 42;           //正确：编译时初始化const int k;                //错误：k是一个未经初始化的常量const int ci = i;           //正确：i的值被拷贝给了cij = ci;                 //正确：ci的值被拷贝给了j</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>对常量的引用（reference to const）</strong></td><td>是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果</td></tr><tr><td><strong>常量引用（const reference）</strong></td><td>是一种习惯叫法，含义是指向常量的引用</td></tr></tbody></table><pre><code>const int ci = 1024;const int &amp;r1 = ci;     //正确：引用及其对应的对象都是常量r1 - 42;                //错误：r1是对常量的引用int &amp;r2 = ci;           //错误：视图让一个非常量引用指向一个常量对象</code></pre><pre><code>int i = 42;const int &amp;r1 = i;      //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42;     //正确：r1是一个常量引用const int &amp;r3 = r1 * 2; //正确：r3是一个常量引用int &amp;r4 = r1 * 2;       //错误：r4是一个普通的非常量引用</code></pre><pre><code>int i = 42;int &amp;r1 = i;            //引用ri绑定对象iconst int &amp;r2 = i;      //r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0;                 //r1并非常量，i的值修改为0r2 = 0;                 //错误：r2是一个常量引用</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>指向常量的指针（pointer to const）</strong></td><td>是一个指针，存放着某个常量对象的指针。指向常量的指针不能用来改变它所指对象的值</td></tr><tr><td><strong>常量指针（const pointer）</strong></td><td>是一种指针，它的值永不改变</td></tr></tbody></table><pre><code>//指向常量的指针const double pi = 3.14;     //pi是个常量，值不能改变double *ptr = &amp;pi;          //错误：ptr是一个普通指针const double *cptr = &amp;pi;   //正确：cptr可以指向一个双精度常量*cptr = 42;                 //错误：不能给*cptr赋值double dval = 3.14;         //dval是非常量cptr = &amp;dval;               //正确：但是不能通过cptr改变dval的值//常量指针int errNumb = 0;int *const curErr = &amp;errNumnb;      //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi;      //pip是一个指向常量对象的常量指针</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>顶层const（top-level const）</strong></td><td>是一个const，规定某对象的值不能改变</td></tr><tr><td><strong>底层const（low-level const）</strong></td><td>一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略</td></tr></tbody></table><pre><code>int i = 0;int *const p1 = &amp;i;         //不能改变p1的值，这是一个顶层constconst int ci = 42;          //不能改变c1的值，这是一个顶层constconst int *p2 = &amp;ci;        //允许改变p2的值，这是一个底层constconst int *const p3 = p2;   //靠右的const是顶层const，靠左的是底层constconst int &amp;r = ci;          //用于声明引用的const都是底层consti = ci;                     //正确：ci是一个顶层const，对此操作无影响p2 = p3;                    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响int *p = p3;                //错误：p3包含底层const的定义，而p没有p2 = p3;                    //正确：p2和p3都是底层constp2 = &amp;i;                    //正确：int*能转换成const int*int &amp;r = ci;                //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2 = i;          //正确：const int&amp;可以绑定到一个普通int上</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>常量表达式（const expression）</strong></td><td>能在编译时计算并获取结果的表达式</td></tr><tr><td><strong>constexpr</strong></td><td>是一种函数，用于代表一条常量表达式</td></tr></tbody></table><pre><code>//常量表达式const int max_files = 20;           //max_files是常量表达式const int limit = max_files + 1;    //limit是常量表达式int staff_size = 27;                //staff_size不是常量表达式const int sz = get_size();          //sz不是常量表达式//constexprconstexpr int mf = 20;          //20是常量表达式constexpr int limit = mf + 1;   //mf + 1是常量表达式constexpr int sz = size();      //只有当size是一个constexpr函数时                                //才是一条正确的声明语句const int *p = nullptr;     //p是一个指向整型常量的指针constexpr int *np = nullptr;    //np是一个指向整数的常量指针，其值为空int j = 0;constexpr int i = 42;           //i的类型是整型常量//i和j都必须定义在函数体之外constexpr const int *p = &amp;i;    //p是常量指针，指向整型常量iconstexpr int *pl = &amp;j;         //p1是常量指针，指向整数j</code></pre><h1 id="5-处理类型"><a href="#5-处理类型" class="headerlink" title="5.处理类型"></a>5.处理类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类型别名（type alias）</strong></td><td>是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义</td></tr><tr><td><strong>typedef</strong></td><td>为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名</td></tr><tr><td><strong>别名声明（alias declaration）</strong></td><td>为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词</td></tr></tbody></table><pre><code>//类型别名typedef double wages;       //wages是double的同义词typedef wages base, *p;     //base是double的同义词，p是double*的同义词//别名声明using SI = Sales_item;      //SI是Sales_item的同义词，Sales_item是自定义类wages hourly, weekly;       //等价于double hourly、weekly;SI item;                    //等价于Sales_item itemtypedef char *pstring;const pstring cstr = 0;     //cstr是指向char的常量指针，而不是一个指向const char的指针，因为pstring基本类型是指针const pstring *ps;          //ps是一个指针，它的对象是指向char的常量指针</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>auto</strong></td><td>是一个类型说明符，通过变量的初始值来推断变量的类型</td></tr></tbody></table><pre><code>auto i = 0, *p = &amp;i;    //正确：i是整数、p是整形指针auto sz = 0, pi = 3.14; //错误：sz和pi的类型不一致int i = 0, &amp;r = i;auto a = r;         //a是一个整数（r是i的别名，而i是一个整数）//auto一般会忽略掉顶层const，同时底层const则会保留下来const int ci = i, &amp;cr = ci;auto b = ci;        //b是一个整数（ci的顶层const特性被忽略掉了）auto c = cr;        //c是一个整数（cr是ci的别名，ci本身是一个顶层const）auto d = &amp;i;        //d是一个整型指针（整数的地址就是指向整数的指针）auto e = &amp;ci;       //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）//如果希望推断出的auto类型是一个顶层const，需要明确指出const auto f = ci;  //ci的扮演类型是int，f是const int//可以将引用的类型设为auto，此时原来的初始化规则仍然适用auto &amp;g = ci;       //g是一个整型常量引用，绑定到ciauto &amp;h = 42;       //错误：不能为非常量引用绑定字面值const auto &amp;j = 42; //正确：可以为常量引用绑定字面值//切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型auto k = ci, &amp;l = i;    //k是整数，l是整型引用auto &amp;m = ci, *p = &amp;ci; //m是对整型常量的引用，p是指向整型常量的指针//错误：i的类型是int而&amp;ci的类型是const intauto &amp;n = i, *p2 = &amp;ci;</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>decltype</strong></td><td>是一个类型说明符，从变量或表达式推断得到类型</td></tr></tbody></table><pre><code>decltype(f()) sum = x;  //sum的类型就是函数f的返回类型const int ci = 0, &amp;cj = ci;decltype(ci) x = 0;     //x的类型是const intdecltype(cj) y = x;     //y的类型是const int&amp;， y绑定到变量xdecltype(cj) z;         //错误：z是一个引用，必须初始化//decltype的结果可以是引用类型int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;      //正确：加法的结果是int，因此b是一个（未初始化的）intdecltype(*p) c;         //错误：c是int&amp;，必须初始化//decltype的表达式如果是加上了括号的变量，结果将是引用decltype((i)) d;        //错误：d是int&amp;，必须初始化decltype(i) e;          //正确：e是一个（未初始化的）int</code></pre><h1 id="6-以类的形式自定义数据结构"><a href="#6-以类的形式自定义数据结构" class="headerlink" title="6.以类的形式自定义数据结构"></a>6.以类的形式自定义数据结构</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类（class）</strong></td><td>名字定义在类内部</td></tr><tr><td><strong>struct</strong></td><td>是一个关键字，用于定义类</td></tr><tr><td><strong>数据成员（data memeber）</strong></td><td>组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化</td></tr><tr><td><strong>类内初始值（in-class initializer）</strong></td><td>在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内</td></tr><tr><td><strong>头文件保护符（header guard）</strong></td><td>使用预处理变量以防止头文件被某个文件重复包含</td></tr><tr><td><strong>预处理变量（preprocessor variable）</strong></td><td>由预处理管理的变量。在程序编译之前，预处理器负责将程序中的预处变量替换成它的真实值</td></tr><tr><td><strong>预处理器（preprocessor）</strong></td><td>在C++编译过程中执行的一段程序</td></tr><tr><td><strong>#define</strong></td><td>是一条预处理指令，用于定义一个预处理变量</td></tr><tr><td><strong>#endif</strong></td><td>是一条预处理指令，用于结束一个#ifdef或#ifndef区域</td></tr><tr><td><strong>#ifdef</strong></td><td>是一条预处理指令，用于判断给定的变量是否已经定义</td></tr><tr><td><strong>ifndef</strong></td><td>是一条预处理指令，用于判断给定的变量是否尚未定义</td></tr></tbody></table><pre><code>//类struct Sales_data{    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><pre><code>//头文件保护符#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;struct Sales_data{    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
