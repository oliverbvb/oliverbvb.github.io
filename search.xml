<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深切哀悼为抗击疫情牺牲的同胞</title>
      <link href="/shen-qie-ai-dao-wei-kang-ji-yi-qing-xi-sheng-de-tong-bao/"/>
      <url>/shen-qie-ai-dao-wei-kang-ji-yi-qing-xi-sheng-de-tong-bao/</url>
      
        <content type="html"><![CDATA[<p>我仅代表自己和我的家人深深感恩在这场抗疫中逝去的医务工作者，志愿者以及一群又一群平凡的人，在危难中挺身而出，在重压下义无反顾。我们不会忘记，他们平凡而又伟大的人生，愿逝者安息！</p><p><img src="maxresdefault.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表5-函数</title>
      <link href="/c-primer-zhu-yu-biao-5-han-shu/"/>
      <url>/c-primer-zhu-yu-biao-5-han-shu/</url>
      
        <content type="html"><![CDATA[<p>函数是一个命名了的代码库，我们通过调用函数执行相应的代码。</p><h1 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1.函数基础"></a>1.函数基础</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>函数（function）</strong></td><td>可调用的计算单元</td></tr><tr><td><strong>函数体（function body）</strong></td><td>是一个块，用于定义函数所执行的操作</td></tr><tr><td><strong>()运算符（()operator）</strong></td><td>调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）</td></tr><tr><td><strong>对象生命周期（object lifetime）</strong></td><td>每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象</td></tr><tr><td><strong>局部变量（local variable）</strong></td><td>定义在块中的变量</td></tr><tr><td><strong>隐藏名字（hidden name）</strong></td><td>某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体</td></tr><tr><td><strong>自动对象（automatic object）</strong></td><td>仅存在于函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象：当到达了定义所在的块的末尾时，销毁该对象</td></tr><tr><td><strong>局部静态对象（local static object）</strong></td><td>它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁</td></tr><tr><td><strong>函数原型（function prototype）</strong></td><td>函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型</td></tr><tr><td><strong>分离式编译（separate compliation）</strong></td><td>把一个程序分割成多个独立源文件的能力</td></tr><tr><td><strong>链接（link）</strong></td><td>是一个编译过程，负责把若干对象文件链接起来形成可执行程序</td></tr><tr><td><strong>可执行文件（executable file）</strong></td><td>是操作系统能够执行的文件，包含着与程序有关的代码</td></tr><tr><td><strong>对象文件（object file）</strong></td><td>编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件</td></tr><tr><td><strong>对象代码（object code）</strong></td><td>编译器将我们的源代码转换成对象代码格式</td></tr></tbody></table><pre><code>//函数的形参列表void f1(){ /*...*/ }        //隐式地定义空形参列表void f2(void){ /*...*/ }    //显式地定义空形参列表//局部静态对象size_t count_calls(){    static size_t ctr = 0;      //调用结束后，这个值仍然有效    return ++ctr;}int main(){    //输出从1到10的数字    for(size_t i = 0; i != 10; ++i)        cout &lt;&lt; count_calls() &lt;&lt; endl;    return 0;}</code></pre><h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2.参数传递"></a>2.参数传递</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>形参（parameter）</strong></td><td>在函数的形参列表中声明的局部变量。用实参初始化形参。</td></tr><tr><td><strong>实参（argument）</strong></td><td>函数调用时提供的值，用于初始化函数的形参</td></tr><tr><td><strong>引用传递（pass by reference）</strong></td><td>描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上</td></tr><tr><td><strong>值传递（pass by value）</strong></td><td>描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本</td></tr><tr><td><strong>传引用调用（call by reference）</strong></td><td>参见引用传递</td></tr><tr><td><strong>传值调用（call by value）</strong></td><td>参见值传递</td></tr><tr><td><strong>initializer_list</strong></td><td>是一个标准类，表示的是一个组花括号包围的类型相同的对象，对象之间以逗号隔开</td></tr></tbody></table><pre><code>//指针形参void reset(int *ip){    *ip = 0;    //改变指针ip所指对象的值    ip = 0;     //只改变了ip的局部拷贝，实参未被改变}//const形参void fcn(const int i){/* fcn能够读取i，但是不能向i写值 */}  //既可以传入const int也可以传入intvoid fcn(int i){}   //错误：重复定义了fcn(int)/* 数组形参 *///尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);    //可以看出来，函数的意图是作用于一个数组void print(const int[10]);  //这里的维度表示我们期望数组含有多少元素，实际不一定//多维数组//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组void print(int (*matrix)[10], int rowSize){}//等价定义void print(int matrix[][10], int rowSize){}/* 可变形参 */void error_msg(initializer_list&lt;string&gt; il){    for(auto beg = il.begin(); beg != il.end(); ++beg)        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;}//调用//expected和actual是string对象if(expected != actual)    error_msg({&quot;funxtionX&quot;, expected, actual});else    error_msg({&quot;functionX&quot;, &quot;okay&quot;});</code></pre><h1 id="3-返回类型"><a href="#3-返回类型" class="headerlink" title="3.返回类型"></a>3.返回类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>返回类型（return type）</strong></td><td>是函数声明的一部分，用于指定函数返回值的类型</td></tr><tr><td><strong>递归函数（recursive function）</strong></td><td>直接或间接调用自身的函数</td></tr><tr><td><strong>递归循环（recursion loop）</strong></td><td>描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程</td></tr><tr><td><strong>尾置返回类型（trailing return type）</strong></td><td>把参数列表后面指定的返回类型</td></tr></tbody></table><pre><code>//不要返回局部对象的引用或指针，因为函数完成后，它所占用的存储空间也随之被释放掉//严重错误：这个函数试图返回局部对象的引用const string &amp;manip(){    string ret;    //以某种方式改变一下ret    if(!ret.empty())        return ret;         //错误：返回局部对象的引用    else        return &quot;Empty&quot;;     //错误：&quot;Empty&quot;是一个局部临时量}//调用一个返回引用的函数得到左值，其他返回类型得到右值char &amp;get_val(string &amp;str, string::size_type ix){    return str[ix];}int main(){    string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl;    get_val(s, 0) = &#39;A&#39;;        //将s[0]的值改为A    cout &lt;&lt; s &lt;&lt; endl;    return 0;}//列表初始化返回值vector&lt;string&gt; process(){    //...    //expected和actual是string对象    if(expected.empty())        return {};              //返回一个空vector对象    else if(expected == actual)        return {&quot;functionX&quot;, &quot;okay&quot;};   //返回列表初始化的vector对象    else        return {&quot;functionX&quot;, expected, actual};}//使用尾置返回类型//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10];//使用decltypeint odd[] = {1, 3, 5, 7, 9};int even[] = {0, 2, 4, 6, 8};//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i){    return (i % 2) ? &amp;odd : &amp;even;  //返回一个指向数组的指针}</code></pre><h1 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>重载函数（overloaded function）</strong></td><td>函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别</td></tr><tr><td><strong>函数匹配（function matching）</strong></td><td>编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较</td></tr><tr><td><strong>重载确定（overload resolution）</strong></td><td>参见函数匹配</td></tr><tr><td><strong>最佳匹配（best match）</strong></td><td>从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差</td></tr><tr><td><strong>无匹配（no match）</strong></td><td>是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配</td></tr><tr><td><strong>二义性调用（ambiguous call）</strong></td><td>是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</td></tr><tr><td><strong>候选函数（candidate function）</strong></td><td>解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内</td></tr><tr><td><strong>可行函数（viable function）</strong></td><td>是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型</td></tr></tbody></table><pre><code>Record lookup(const Account&amp;);      //根据Account查找记录Record lookup(const Phone&amp;);        //根据Phone查找记录Record lookup(const Name&amp;);         //根据Name查找记录Account acct;Phone phone;Record r1 = lookup(acct);Record r2 = lookup(phone);//顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来Record lookup(Phone);Record lookup(const Phone);     //重复声明了Record lookup(Phone*);Record lookup(Phone* const);    //重复声明//如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的Record lookup(Account&amp;);        //函数作用于Account的引用Record lookup(const Account&amp;);  //新函数，作用于常量引用Record lookup(Account*);        //新函数，作用于指向Account的指针Record lookup(const Account*);  //新函数，作用于指向常量的指针</code></pre><h1 id="5-默认实参、内联函数和预处理宏"><a href="#5-默认实参、内联函数和预处理宏" class="headerlink" title="5.默认实参、内联函数和预处理宏"></a>5.默认实参、内联函数和预处理宏</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>默认实参（default argument）</strong></td><td>当调用缺少了某个实参时，为该实参指定的默认值</td></tr><tr><td><strong>内联函数（inline function）</strong></td><td>请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销</td></tr><tr><td><strong>constexpr</strong></td><td>可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数</td></tr><tr><td><strong>预处理宏（preprocessor marco）</strong></td><td>类似于内联函数的一种预处理功能。除了assert之外，现在C++程序很少再使用预处理宏</td></tr><tr><td><strong>Assert</strong></td><td>是一个预处理宏，作用于一条表示条件的表达式。当未定义预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条错误信息并终止当前程序的执行</td></tr></tbody></table><pre><code>//默认实参string screen(sz, sz, char = &#39; &#39;);string screen(sz, sz, char = &#39;*&#39;);      //错误：重复声明string screen(sz = 24, sz = 80. char);  //正确：添加默认实参//内联版本：寻找两个string对象中较短的那个inline const string &amp;shorterString(const string &amp;s1, const string &amp;s2){    return s1.size() &lt;= s2.size() ? s1 : s2;}//constexpr函数，函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句constexpr int new_sz() {return 42;}constexpr int foo = new_sz();   //正确：foo是一个常量表达式</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表4-语句</title>
      <link href="/c-primer-zhu-yu-biao-4-yu-ju/"/>
      <url>/c-primer-zhu-yu-biao-4-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>C++提供了条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。</p><h1 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1.简单语句"></a>1.简单语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>控制流（flow of control）</strong></td><td>程序的执行路径</td></tr><tr><td><strong>表达式语句（expression statement）</strong></td><td>即一条表达式后面跟上一个分号，令表达式执行求值过程</td></tr><tr><td><strong>空语句（null statement）</strong></td><td>只含有一个分号的语句</td></tr><tr><td><strong>块（block）</strong></td><td>包围在花括号内的由0条或多条语句组成的序列。块也是一条语句，所以只要是能使用语句的地方，就可以使用块</td></tr><tr><td><strong>复合语句（compound statement）</strong></td><td>和块是同义词</td></tr></tbody></table><pre><code>ival + 5;       //一条没什么实际用处的表达式语句cout &lt;&lt; ival;   //一条有用的表达式语句//重复读入数据直至到达文件末尾或某次输入的值等于soughtwhile(cin &gt;&gt; s &amp;&amp; s != sought)    ;   //空语句</code></pre><h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>if语句（if statement）</strong></td><td>判断条件，根据其结果有选择地执行语句。如果条件为真，执行if分支的代码；如果条件为假，控制权转移到if结构之后的第一条语句</td></tr><tr><td><strong>if else语句（if else statement）</strong></td><td>判断条件，根据其结果分别执行if分支或else分支的语句</td></tr><tr><td><strong>悬垂else（dangling else）</strong></td><td>是一个俗语，指的是如何处理嵌套if语句中if分支多于else分支的情况</td></tr><tr><td><strong>switch语句（switch statement）</strong></td><td>一种条件语句</td></tr><tr><td><strong>带标签语句（lebeled statement）</strong></td><td>前面带有标签的语句。所谓标签是指一个标识符以及紧跟着的一个冒号。对于同一个标识符来说，用作标签的同时还能用于其他目的，互不干扰</td></tr><tr><td><strong>case标签（case label）</strong></td><td>在switch语句中紧跟在case关键字之后的常量表达式（参见2.4.4节）。在同一个switch语句中任意两个case标签的值不能相同</td></tr><tr><td><strong>default标签（default label）</strong></td><td>是一种特殊的case标签，当switch表达式的值与所有case标签都无法匹配时，程序执行default标签下的内容</td></tr></tbody></table><pre><code>//注意case true:    //因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法    string file_name;       //错误：控制流绕过一个隐式初始化的变量    int ival = 0;           //错误：控制流绕过一个显式初始化的变量    int jval;               //正确：因为jval没有初始化    break;case false:    //正确：jval虽然在作用域内，但是它没有被初始化    jval = next_num();      //正确：给jval赋一个值    if(file_name.empty())   //file_name在作用域内，但是没有被初始化        //...</code></pre><h1 id="3-迭代语句"><a href="#3-迭代语句" class="headerlink" title="3.迭代语句"></a>3.迭代语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>while语句（while statement）</strong></td><td>只要指定的条件为真，就一直迭代执行目标语句</td></tr><tr><td><strong>for语句（for statement）</strong></td><td>替换迭代执行的迭代语句。常常用于遍历一个容器或者重复计算若干次</td></tr><tr><td><strong>范围for语句（range for statement）</strong></td><td>在一个序列中进行迭代的语句</td></tr><tr><td><strong>do while语句（do while statement）</strong></td><td>与while语句类似，区别是do while语句先执行循环体，再判断条件。循环体代码至少会执行一次</td></tr></tbody></table><h1 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4.跳转语句"></a>4.跳转语句</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>break语句（break statement）</strong></td><td>终止离它最近的循环或switch语句。控制权转移到循环或switch之后的第一条语句</td></tr><tr><td><strong>continue语句（continue statement）</strong></td><td>终止离它最近的循环的当前迭代。控制权转移到while或do while语句的条件部分、或者范围for循环的下一次迭代、或者传统for循环头部的表达式</td></tr><tr><td><strong>goto语句（goto statement）</strong></td><td>令控制权无条件转移到同一函数中一个指定的带标签语句。goto语句容易造成程序的控制流混乱，应禁止使用</td></tr></tbody></table><h1 id="5-try语句块和异常处理"><a href="#5-try语句块和异常处理" class="headerlink" title="5.try语句块和异常处理"></a>5.try语句块和异常处理</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>异常安全（exception safe）</strong></td><td>是一个术语，表示的含义是当抛出异常后，程序能执行正确的行为</td></tr><tr><td><strong>throw表达式（throw expression）</strong></td><td>一种中断当前执行路径的表达式</td></tr><tr><td><strong>引发（raise）</strong></td><td>含义类似于throw。在C++语言中既可以说抛出异常，也可以说引发异常</td></tr><tr><td><strong>try语句块（try block）</strong></td><td>跟在try关键字后面的块，以及一个或多个catch子句</td></tr><tr><td><strong>catch子句（catch clause）</strong></td><td>由三部分组成：catch关键字、括号里的异常声明以及一个语句块。catch子句的代码负责处理在异常声明中定义的异常</td></tr><tr><td><strong>异常处理代码（exception handler）</strong></td><td>程序某处引发异常后，用于处理该异常的另一处代码。和catch子句是同义词</td></tr><tr><td><strong>异常声明（exception declaration）</strong></td><td>位于catch子句中的声明，指明了该catch子句能处理的异常类型</td></tr><tr><td><strong>terminate</strong></td><td>是一个标准库函数，当异常没有被捕捉到时调用。terminate终止当前程序的执行</td></tr><tr><td><strong>异常类（exception class）</strong></td><td>是标准库定义的一组类，用于表示程序发生的错误</td></tr></tbody></table><pre><code>/* throw表达式 *///首先检查两条数据是否是关于同一种书籍的if(item1.isbn() != item2.isbn())    throw runtime_error(&quot;Data must refer to same ISBN&quot;);//如果程序执行到了这里，表示两个ISBN是相同的cout &lt;&lt; item1 + item2 &lt;&lt; endl;/* try语句块 */try{    program-statements}catch(exception-declaration){    handler-statements}catch(exception-declaration){    handler-statements}   //...</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表6-类</title>
      <link href="/c-primer-zhu-yu-biao-6-lei/"/>
      <url>/c-primer-zhu-yu-biao-6-lei/</url>
      
        <content type="html"><![CDATA[<p>类的基本思想是数据抽象和封装。</p><h1 id="1-定义抽象数据类型"><a href="#1-定义抽象数据类型" class="headerlink" title="1.定义抽象数据类型"></a>1.定义抽象数据类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类（class）</strong></td><td>C++提供的自定义数据类型的机制。类可以包含数据、函数和类型成员。一个类定义一种新的类型和一个新的作用域</td></tr><tr><td><strong>数据抽象（data abstraction）</strong></td><td>着重关注类型接口的一种编程技术。数据抽象令程序员可以忽略类型的实现细节，只关注类型执行的操作即可。数据抽象是面向对象编程和泛型编程的基础</td></tr><tr><td><strong>封装（encapsulation）</strong></td><td>分离类的实现与接口，从而隐藏了类的实现细节。在C++语言中，通过把实现部分设为private完成封装的任务</td></tr><tr><td><strong>接口（interface）</strong></td><td>类型提供的（公有）操作。通常情况下，接口不包含数据成员</td></tr><tr><td><strong>实现（implementation）</strong></td><td>类的成员（通常是私有的），定义了不希望为使用类类型的代码所用的数据及任何操作</td></tr><tr><td><strong>抽象数据类型（abstract data type）</strong></td><td>封装（隐藏）了实现细节的数据结构</td></tr><tr><td><strong>this指针（this pointer）</strong></td><td>是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数。this指针指向代表函数调用者的对象</td></tr><tr><td><strong>成员函数（member function）</strong></td><td>类的函数成员。普通的成员函数通过隐式的this指针与类的对象绑定在一起；静态成员函数不与对象绑定在一起也没有this指针。成员函数可以重载，此时隐式的this指针参与函数匹配的过程</td></tr><tr><td><strong>常量成员函数（const member function）</strong></td><td>一个成员函数，在其中不能修改对象的普通（即既不是static也不是mutable）数据成员。const成员的this指针是指向常量的指针，通过区分函数是否是const可以进行重载</td></tr><tr><td><strong>构造函数（constructor）</strong></td><td>用于初始化对象的一种特殊的成员函数。构造函数应该给每个数据成员都赋一个合适的初始值</td></tr><tr><td><strong>默认构造函数（default constructor）</strong></td><td>当没有提供任何实参时使用的构造函数</td></tr><tr><td><strong>合成默认构造函数（synthesized default constructor）</strong></td><td>对于没有显式地定义任何构造函数的类，编译器为其创建（合成）的默认构造函数。该构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作：否则就对数据成员执行默认初始化</td></tr><tr><td><strong>=default</strong></td><td>一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数</td></tr><tr><td><strong>构造函数初始值列表（constructor initializer list）</strong></td><td>说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表中的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化</td></tr></tbody></table><pre><code>//Sales_data.hstruct Sales_data{    Sales_data() =default;  //默认构造函数    Sales_data(const std::string &amp;a) : bookNo(s){}  //构造函数初始值列表    Sales_data(const std::string &amp;a, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){}   //构造函数初始值列表    Sales_data(std::istream &amp;);    std::string isbn() const{ return this-&gt;bookNo; }  //常量成员函数和this指针    Sales_data&amp; combine(const Sales_data&amp;);    double avg_price() const;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;}//Sales_data的非成员接口函数Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);</code></pre><pre><code>//Sales_data.cpp//在类的外部定义成员函数double Sales_data::avg_price() const{    if(units_sold)        return revenue/units_sold;    else        return 0;}//定义类相关的非成员函数istream &amp;read(istream &amp;is, Sales_data &amp;item){    double price = 0;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    item.revenue = price * item.units_sold;    return is;}ostream &amp;print(ostream &amp;os, const Sales_data &amp;item){    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();}Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs){    Sales_data sum = lhs;       //把lhs的数据成员拷贝给sum    sum.combine(rhs);           //把rhs的数据成员加到sum当中    return sum;}</code></pre><h1 id="2-访问控制与封装"><a href="#2-访问控制与封装" class="headerlink" title="2.访问控制与封装"></a>2.访问控制与封装</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>访问说明符（access specifier）</strong></td><td>包括关键字public和private。用于定义成员对类的用户可见还是只对类的友元和成员可见。在类中说明符可以出现多次，每个说明符的有效范围从它自身开始，到下一个说明符为止</td></tr><tr><td><strong>公有成员（public member）</strong></td><td>定义在public访问说明符之后的成员，可以被类的所有用户访问。通常情况下，只有实现类的接口的函数才被设为public</td></tr><tr><td><strong>私有成员（private member）</strong></td><td>定义在private访问说明符之后的成员，只能被类的友元或类的其他成员访问。数据成员以及仅供类的其他成员访问。数据成员以及仅供类本身使用而不作为接口的功能函数一般设为private</td></tr><tr><td><strong>class关键字（class keyword）</strong></td><td>用于定义类的关键字，默认情况下成员是private的</td></tr><tr><td><strong>struct关键字（struct keyword）</strong></td><td>用于定义类的关键字，默认情况下成员是public的</td></tr><tr><td><strong>友元（friend）</strong></td><td>类向外部提供其非公有成员访问权限的一种机制。友元的访问权限与成员函数一样。友元可以是类，也可以是函数</td></tr></tbody></table><pre><code>class Sales_data{public:             //添加了访问说明符    Sales_data() = default;    Sales_data(const std::string &amp;a) : bookNo(s){}    Sales_data(const std::string &amp;a, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){}    Sales_data(std::istream &amp;);    std::string isbn() const{ return bookNo; }    Sales_data&amp; combine(const Sales_data&amp;);private:            //添加了访问说明符    double avg_price() const;    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><pre><code>/* 友元函数 */class Sales_data{//为Sales_data的非成员函数所做的友元声明friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;);friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);//其他成员及访问说明符与之前一致...};//Sales_data接口的非成员组成部分的声明Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);</code></pre><h1 id="3-可变数据成员和类类型"><a href="#3-可变数据成员和类类型" class="headerlink" title="3.可变数据成员和类类型"></a>3.可变数据成员和类类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>可变数据成员（mutable data member）</strong></td><td>这种成员永远不是const，即使它属于const对象。在const函数内可以修改可变数据成员。可以通过在变量的声明中加入mutable关键字做到这一点</td></tr><tr><td><strong>类的声明（class declaration）</strong></td><td>首先是关键字class（或者struct），随后是类名以及分号。如果类已经声明而尚未定义，则它是一个不完全类型</td></tr><tr><td><strong>不完全类型（incomplete type）</strong></td><td>已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是用不完全类型定义指针或者引用是合法的</td></tr><tr><td><strong>前向声明（forward declaration）</strong></td><td>对尚未定义的名字的声明，通常用于表示位于类定义之前的类声明。参见”不完全类型”</td></tr></tbody></table><pre><code>class Screen{public:    void some_member() const;private:    mutable size_t access_ctr;      //可变数据成员，即使在一个const对象内也能被修改};void Screen::some_member() const{    ++access_ctr;       //保存一个计数值，用于记录成员函数被调用的次数}</code></pre><pre><code>class Screen;                   //Screen类的前向声明，对于类型Screen来说，在它声明之后定义之前是一个不完全类型//一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针class Link_screen{    Screen window;    Link_screen *next;    Link_screen *prev;};</code></pre><h1 id="4-类的作用域"><a href="#4-类的作用域" class="headerlink" title="4.类的作用域"></a>4.类的作用域</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类的作用域（class scope）</strong></td><td>每个类定义一个作用域。类作用域比其他作用域更加复杂，类中定义的成员函数甚至有可能使用定义语句之后的名字</td></tr><tr><td><strong>名字查找（name lookup）</strong></td><td>根据名字的使用寻找匹配的声明的过程</td></tr></tbody></table><h1 id="5-构造函数扩展"><a href="#5-构造函数扩展" class="headerlink" title="5.构造函数扩展"></a>5.构造函数扩展</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>委托构造函数（delegating constructor）</strong></td><td>委托构造函数的初始值列表只有一个入口，指定类的另一个构造函数执行初始化操作</td></tr><tr><td><strong>转换构造函数（converting constructor）</strong></td><td>可以用一个实参调用的非显式构造函数。这样的函数隐式地将参数类型转换成类类型</td></tr><tr><td><strong>显式构造函数（explicit constructor）</strong></td><td>可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上explicit关键字就可以将其声明成显式构造函数</td></tr><tr><td><strong>聚合类（aggregate class）</strong></td><td>只含有公有成员的类，并且没有类内初始值或者构造函数。聚合类的成员可以用花括号括起来的初始值列表进行初始化</td></tr></tbody></table><pre><code>/* 委托构造函数 */class Sales_data{public:    //非委托构造函数使用对应的实参初始化成员    Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt*price){ }    //其余构造函数全部委托给另一个构造函数    Sales_data() : Sales_data(&quot;&quot;, 0, 0) {}    Sales_data(std::string s) : Sales_data(s, 0, 0) {}    Sales_data(std::istream &amp;is) : Sales_data() { read(is, *this); }    //其他成员与之前的版本一致};</code></pre><pre><code>/* 转换构造函数 */string null_book = &quot;9-999-99999-9&quot;;//构造一个临时的Sales_data对象//该对象的units_sold和revenue等于0，bookNo等于null_bookitem.combine(null_book);//正确：显式地转换成string，隐式地转换成Sales_dataitem.combine(string(&quot;9-999-99999-9&quot;));//正确：隐式地转换成string，显式地转换成Sales_dataitem.combine(Sales_data(&quot;9-999-99999-9&quot;));/* 显式构造函数 */class Sales_data{public:    Sales_data() = default;    Sales_data(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n) { }    explicit Sales_data(const std::string &amp;s) : bookNo(s){ }    explicit Sales_data(std::istream&amp;);    //其他成员与之前的版本一致};item.combine(null_book);        //错误：string构造函数是explicit的item.combine(cin);              //错误：istream构造函数是explicit的</code></pre><pre><code>/* 聚合类 *///struct成员默认是public的struct Data{    int ival;    string s;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表3-表达式</title>
      <link href="/c-primer-zhu-yu-biao-3-biao-da-shi/"/>
      <url>/c-primer-zhu-yu-biao-3-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>表达式（expression）</strong></td><td>C++程序中最低级别的计算。表达式将运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象，这时就得到了对多个运算符求值的复合表达式</td></tr><tr><td><strong>运算对象（operand）</strong></td><td>表达式在某些值上执行运算，这些值就是运算对象。一个运算符有一个或多个相关的运算对象</td></tr><tr><td><strong>运算符（operator）</strong></td><td>决定表达式所做操作的符号。C++语言定义了一套运算符并说明了这些运算符作用于内置类型时的含义</td></tr><tr><td><strong>结果（result）</strong></td><td>计算表达式得到的值或对象</td></tr><tr><td><strong><a href="https://zh.cppreference.com/w/cpp/language/operator_precedence" target="_blank" rel="noopener">优先级（precedence）</a></strong></td><td>规定了复合表达式中不同运算符的执行顺序。与低优先级的运算符相比，高优先级的运算符组合得更紧密</td></tr><tr><td><strong>结合律（associativity）</strong></td><td>规定具有相同优先级的运算符如何组合在一起。结合律分为左结合律（运算符从左向右组合）和右结合律（运算符从右向左组合）</td></tr><tr><td><strong>求值顺序（order of evaluation）</strong></td><td>是某个运算符的运算对象的求值顺序。大多数情况下，编译器可以选择运算对象求值的顺序。不过运算对象一定要在运算符之前得到求值结果</td></tr><tr><td><strong>一元运算符（unary operators）</strong></td><td>只有一个运算对象参与运算的运算符</td></tr><tr><td><strong>二元运算符（binary operator）</strong></td><td>有两个运算对象参与运算的运算符</td></tr><tr><td><strong>重载运算符（overloaded operator）</strong></td><td>针对某种运算符重新定义的适用于类类型的版本</td></tr><tr><td><strong>左值（lvalue）</strong></td><td>是指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象</td></tr><tr><td><strong>右值（rvalue）</strong></td><td>是指一种表达式，其结果是指而非值所在的位置</td></tr><tr><td><strong>复合表达式（compound expression）</strong></td><td>含有多于一个运算符的表达式</td></tr></tbody></table><h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>&amp;&amp;运算符（&amp;&amp;operator）</strong></td><td>逻辑与运算符，如果两个运算对象都是真，结果才为真。只有当左侧运算对象为真时才会检查右侧对象</td></tr><tr><td><strong>&#124;&#124;运算符（&#124;&#124; operator）</strong></td><td>逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</td></tr><tr><td><strong>!运算符（!operator）</strong></td><td>逻辑非运算符，将它的运算对象的布尔值取反</td></tr><tr><td><strong>短路求值（short-circuit evaluation）</strong></td><td>是一个专有名词，描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值</td></tr><tr><td><strong>++运算符（++operator）</strong></td><td>递增运算符。包括两种形式：前置版本和后置版本</td></tr><tr><td><strong>–运算符（–operator）</strong></td><td>递减运算符。包括两种形式：前置版本和后置版本</td></tr><tr><td><strong>?:运算符（?:operator）</strong></td><td>条件运算符</td></tr><tr><td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td><td>左移运算符，将左侧运算对象的值的（可能是提升后的）副本向左移位，移动的位数由右侧运算对象确定</td></tr><tr><td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td><td>右移运算符，除了移动方向相反，其他性质都和左移运算符类似</td></tr><tr><td><strong>&amp;运算符（&amp;operator）</strong></td><td>位与运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位都是1，所得结果中该位为1；否则所得结果中该位为0</td></tr><tr><td><strong>&#124;运算符（&#124; operator）</strong></td><td>位或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位至少有一个是1，所得结果中该位为1；否则所得结果中该位为0</td></tr><tr><td><strong><del>运算符（</del>operator）</strong></td><td>位求反运算符，生成一个新的整数值。该值的每一位恰好与（可能是提升后的）运算对象的对应位相反</td></tr><tr><td><strong>sizeof</strong></td><td>是一个运算符，返回存储对象所需的字节数，该对象的类型可能是某个给定的类型名字，也可鞥由表达式的返回结果确定</td></tr><tr><td><strong>,运算符（,operator）</strong></td><td>逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，当且仅当右侧运算对象是左值时逗号运算符的结果是左值</td></tr></tbody></table><pre><code>//条件运算符cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;);   //输出pass或者failcout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;     //输出1或者0cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;;       //错误：试图比较cout和60，因为小于运算符的优先级低于移位运算符，所以先输出了grade再进行比较//sizeof运算符Sales_data data, *p;sizeof(Sales_data);         //存储Sales_data类型的对象所占的空间大小sizeof data;                //data的类型的大小，即sizeof(Sales_data)sizeof p;                   //指针所占的空间大小sizeof *p;                  //p所指类型的空间大小，即sizeof(Sales_data)sizeof data.revenue;        //Sales_data的revenue成员对应类型的大小sizeof Sales_data::revenue; //另一种获取revenue大小的方式</code></pre><h1 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>转换（conversion）</strong></td><td>一种类型的值改变成另一种类型的值的过程。C++语言定义了内置类型的转换规则。类类型同样可以转换</td></tr><tr><td><strong>隐式转换（implicit conversion）</strong></td><td>由编译器自动执行的类型转换。假如表达式需要某种特定的类型而运算对象是另外一种类型，此时只要规则允许，编译器就会自动地将运算对象转换成所需的类型</td></tr><tr><td><strong>算术转换（arithmetic conversion）</strong></td><td>从一种算术类型转换成另一种算术类型。在二元运算符的上下文中，为了保留精度，算术转换通常把较小的类型转换成较大的类型</td></tr><tr><td><strong>整型提升（integral promotion）</strong></td><td>把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即short、char等）总是会得到提升</td></tr><tr><td><strong>强制类型转换（cast）</strong></td><td>一种显式的类型转换</td></tr><tr><td><strong>static_cast</strong></td><td>显式地执行某种定义明确的类型转换，常用于替代由编译器隐式执行的类型转换</td></tr><tr><td><strong>const_cast</strong></td><td>一种涉及const的强制类型转换。将底层const对象转换成对应的非常量类型，或者执行相反的转换</td></tr><tr><td><strong>reinterpret_cast</strong></td><td>把运算对象的内容解释成另外一种类型。这种强制类型转换本质上依赖于机器而且非常危险</td></tr><tr><td><strong>dynamic_cast</strong></td><td>和继承及运行时类型识别一起使用</td></tr></tbody></table><pre><code>/* 隐式转换 */int ival = 3.541 + 3;   //结果为6，编译器可能会警告该运算损失了精度int ia[10];     //含有10个整数的数组int* ip = ia;   //ia转换成指向数组首元素的指针//转换成布尔类型char *cp = get_string();if(cp) /*...*/      //如果指针cp不是0，条件为真while(*cp) /*...*/  //如果*cp不是空字符，条件为真//转换成常量int i;const int &amp;j = i;   //非常量转换成const int的引用const int *p = &amp;i;  //非常量的地址转换成const的地址int &amp;r = j, *q = p; //错误：不允许const转换成非常量//类类型转换string s;while(cin &gt;&gt; s)     //while的条件部分把cin转换成布尔值/* 显式转换 *///static_castdouble slope = static_cast&lt;double&gt;(j) / i;  //进行强制类型转换以便执行浮点数除法void *p = &amp;d;                               //正确：任何非常量对象的地址都能存入void*double *dp = static_cast&lt;double*&gt;(p);       //正确：将void*转换回初始的指针类型//const_castconst char *pc;char *p = const_cast&lt;char*&gt;(pc);//正确：但是通过p写值是未定义的行为const char *cp;char *q = static_cast&lt;char*&gt;(cp);       //错误：static_cast不能转换掉const性质static_cast&lt;string&gt;(cp);                //正确：字符串字面值转换成string类型const_cast&lt;string&gt;(cp);                 //错误：const_cast只改变常量属性//reinterpret_castint *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip);string str(pc);                         //错误：可能导致异常的运行时行为，必须牢记pc所指的真实对象是一个int而非字符</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表2-字符串、向量和数组</title>
      <link href="/c-primer-zhu-yu-biao-2-zi-fu-chuan-xiang-liang-he-shu-zu/"/>
      <url>/c-primer-zhu-yu-biao-2-zi-fu-chuan-xiang-liang-he-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>C++语言定义了一个内容丰富的抽象数据类型库。其中，string和vector是两种最重要的标准库类型。内置数组是一种更基础的类型，string和vector都是对它的某种抽象。</p><h1 id="1-命名空间的using声明"><a href="#1-命名空间的using声明" class="headerlink" title="1.命名空间的using声明"></a>1.命名空间的using声明</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>using声明（using declaration）</strong></td><td>令命名空间中的某个名字可被程序直接使用</td></tr></tbody></table><pre><code>#include &lt;iostream&gt;//using声明，当我们使用名字cin时，从命名空间std中获取它using std::cinint main(){    int i;    cin &gt;&gt; i;           //正确    cout &lt;&lt; i;          //错误：没有对应的using声明，必须使用完整的名字    std::cout &lt;&lt; i;     //正确：显式地从std中使用cout    return 0;}</code></pre><h1 id="2-标准库类型string"><a href="#2-标准库类型string" class="headerlink" title="2.标准库类型string"></a>2.标准库类型string</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>容器（container）</strong></td><td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型</td></tr><tr><td><strong>缓冲区溢出（buffer overflow）</strong></td><td>一种严重的程序故障，主要的原因是视图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td></tr><tr><td><strong>string</strong></td><td>是一种标准库类型，表示字符的序列</td></tr><tr><td><strong>拷贝初始化（copy initialization）</strong></td><td>使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本</td></tr><tr><td><strong>直接初始化（direct initialization）</strong></td><td>不使用赋值号（=）的初始化形式</td></tr></tbody></table><pre><code>string s1;                          //默认初始化，s1是一个空字符串string s2 = s1;                     //s2是s1的副本string s3 = &quot;hiya&quot;;                 //s3是该字符串字面值的副本string s4(10, &#39;c&#39;);                 //s4的内容是ccccccccccstring s5 = &quot;hiya&quot;;                 //拷贝初始化string s6(&quot;hiya&quot;);                  //直接初始化string s7(10, &#39;c&#39;);                 //直接初始化，s7的内容是ccccccccccstring s8 = string(10, &#39;c&#39;);        //拷贝初始化，s8的内容是cccccccccc</code></pre><pre><code>//字面值和string对象相加string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;string s3 = s1 + &quot;, &quot; + s2  + &#39;\n&#39;;string s4 = s1 + &quot;, &quot;;              //正确：把一个string对象和一个字面值相加string s5 = &quot;hello&quot; + &quot;, &quot;;         //错误，两个运算对象都不是stringstring s6 = s1 + &quot;, &quot; + &quot;world&quot;;    //正确string s7 = &quot;hello&quot; + &quot;, &quot; + s2;    //错误：不能把字面值直接相加</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>getline</strong></td><td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留</td></tr><tr><td><strong>empty</strong></td><td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假</td></tr><tr><td><strong>size</strong></td><td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type</td></tr><tr><td><strong>size_type</strong></td><td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型</td></tr><tr><td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td><td>标准库类型string定义的输出运算符，负责输出string对象中的字符</td></tr><tr><td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td><td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象</td></tr></tbody></table><pre><code>int main(){    string line;    //每次读入一整行，直至到达文件末尾    while(getline(cin, line))        cout &lt;&lt; line &lt;&lt; endl;    return 0;}</code></pre><pre><code>//每次读入一整行，遇到空行直接跳过while(getline(cin, line))    if(!line.empty())        cout &lt;&lt; line &lt;&lt; endl;string line;//每次读入一整行，输出其中超过80个字符的行while(getline(cin, line))    if(line.size() &gt; 80)        cout &lt;&lt; line &lt;&lt; endl;</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>范围for语句（range for）</strong></td><td>一种控制语句，可以在值的一个特定集合内迭代</td></tr><tr><td><strong>索引（index）</strong></td><td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置</td></tr><tr><td><strong>[]运算符 （[]operator）</strong></td><td>下标运算符</td></tr></tbody></table><pre><code>//范围for语句string s(&quot;Hellow World!!!&quot;);//转换成大写形式for(auto &amp;c : s)        //对于s中的每个字符（注意：c是引用）    c = toupper(c);     //c是一个引用，因此赋值语句将改变s中字符的值cout &lt;&lt; s &lt;&lt; endl;</code></pre><pre><code>//[]运算符//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白for(decltype(s.size()) index = 0; index != s.size() &amp;&amp; !isspace(s[index]); ++index)    s[index] = toupper(s[index]);   //将当前字符改成大写形式</code></pre><h1 id="3-标准库类型vector"><a href="#3-标准库类型vector" class="headerlink" title="3.标准库类型vector"></a>3.标准库类型vector</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>vector</strong></td><td>是一种标准库类型，容纳某指定类型的一组元素</td></tr><tr><td><strong>类模板（class template）</strong></td><td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息</td></tr><tr><td><strong>实例化（instantiation）</strong></td><td>编译器生成一个指定的模板类或函数的过程</td></tr><tr><td><strong>push_back</strong></td><td>是vector的成员，向vector对象的末尾添加元素</td></tr></tbody></table><pre><code>vector&lt;int&gt; ivec;               //ivec保存int类型的对象vector&lt;Sales_item&gt; Sales_vec;   //保存Sales_item类型的对象vector&lt;vector&lt;string&gt;&gt; file;    //该向量的元素是vector对象//初始化vector&lt;string&gt; v1{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};    //列表初始化vector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);    //错误vector&lt;int&gt; ivec(10, -1);   //10个int类型的元素，每个元素都初始化为-1vector&lt;string&gt; svec(10, &quot;hi!&quot;); //10个string类型的元素，每个都被初始化为&quot;hi!&quot;vector&lt;int&gt; ivec(10);       //10个元素，每个都初始化为0vector&lt;string&gt; svec(10);    //10个元素，每个都是空string对象//从标准输入中读取单词，将其作为vector对象的元素存储string word;vector&lt;string&gt; text;        //空vector对象while(cin &gt;&gt; word){    text.push_back(word);   //把word添加到text后面}//不能用下标形式添加元素vector&lt;int&gt; ivec;   //空vector对象for(decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec[ix] = ix;  //严重错误：ivec不包含任何元素for(decltype(ivec.size()) ix = 0; ix != 10; ++ix)    ivec.push_back(ix); //正确：添加一个新元素，该元素的值是ix</code></pre><h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4.迭代器"></a>4.迭代器</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>迭代器（iterator）</strong></td><td>是一种类型，用于访问容器中的元素或者在元素之间移动</td></tr><tr><td><strong>迭代器运算（iterator arithmetic）</strong></td><td>是string或vector的迭代器的运算</td></tr><tr><td><strong>begin</strong></td><td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针</td></tr><tr><td><strong>end</strong></td><td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</td></tr><tr><td><strong>尾后迭代器（off-the-end iterator）</strong></td><td>end函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置</td></tr><tr><td><strong>difference_type</strong></td><td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离</td></tr><tr><td><strong>++运算符（++operator）</strong></td><td>是迭代器和指针定义的递增运算符</td></tr><tr><td><strong>-&gt;运算符（-&gt;operator）</strong></td><td>箭头运算符</td></tr></tbody></table><pre><code>string s(&quot;some string&quot;);if(s.begin() != s.end()){   //确保s非空    auto it = s.begin();    //it表示s的第一个字符    *it = toupper(*it);     //将当前字符改成大写形式}vector&lt;int&gt;::iterator it;       //it能读写vector&lt;int&gt;的元素string::iterator it2;           //it2能读写string对象中的字符vector&lt;int&gt;::const_iterator it3;    //it3只能读元素，不能写字符string:const_iterator it4;          //it3只能读字符，不能写字符</code></pre><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>size_t</strong></td><td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小</td></tr><tr><td><strong>指针运算（pointer arithmetic）</strong></td><td>是指针类型支持的算术运算中。指向数组的指针所支持的运算种类与迭代器运算一样</td></tr><tr><td><strong>prtdiff_t</strong></td><td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离</td></tr><tr><td><strong>C风格字符串（C-style string）</strong></td><td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td></tr><tr><td><strong>以空字符结束的字符串（null-terminated string）</strong></td><td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\0’）</td></tr></tbody></table><pre><code>//指针和数组string nums[] = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};    //数组的元素是string对象string *p = &amp;nums[0];                       //p指向nums的第一个元素string *p2 = nums;  //等价于p2 = &amp;nums[0]int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};int *beg = begin(ia);       //指向ia首元素的指针int *last = end(ia);        //指向arr尾元素的下一位置的指针ptrdiff_t n = end(ia) - begin(ia);     //n的类型是ptrdiff_t，值是10，也就是ia中元素的数量//C风格字符串char ca[] = {&#39;C&#39;, &#39;+&#39;, &#39;+&#39;};        //不以空字符结束cout &lt;&lt; strlen(ca) &lt;&lt; endl;         //严重错误：ca没有以空字符结束//比较两个C风格字符串const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different string&quot;;if(ca1 &lt; ca2)           //未定义的：视图比较两个无关地址if(strcmp(ca1, ca2) &lt; 0)    //正确//混用string对象和C风格字符串string s = ca1;char *str = s;      //错误：不能用string对象初始化char*const char *str = s.c_str();    //正确</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer术语表 1-变量和基本类型</title>
      <link href="/c-primer-zhu-yu-biao-1-bian-liang-he-ji-ben-lei-xing/"/>
      <url>/c-primer-zhu-yu-biao-1-bian-liang-he-ji-ben-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>C++语言支持广泛的数据类型。它定义了几种基本内置类型（如字符、整型、浮点数等），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一些更加复杂的数据类型，比如可变长字符串和向量等。</p><h1 id="1-基本内置类型"><a href="#1-基本内置类型" class="headerlink" title="1 基本内置类型"></a>1 基本内置类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>基本类型（base type）</strong></td><td>是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符</td></tr><tr><td><strong>算术类型（arithmetic type）</strong></td><td>布尔值、字符、整数、浮点数等内置类型</td></tr><tr><td><strong>void类型</strong></td><td>是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量</td></tr><tr><td><strong>字节（byte）</strong></td><td>内存中可寻址的最小单元，大多数机器的字节占8位</td></tr><tr><td><strong>字（word）</strong></td><td>在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节</td></tr></tbody></table><pre><code>bool bIsOK = true;          //布尔类型，最下小尺寸未定义char chChar = &#39;a&#39;;          //字符，最小尺寸8位wchar_t chChar2 = L&#39;a&#39;;     //宽字符，最小尺寸16位char16_t chChar3 = u&#39;a&#39;;    //Unicode字符，最下尺寸16位char32_t chChar4 = U&#39;a&#39;;    //Unicode字符，最下尺寸32位short sId = 0;              //短整型，最小尺寸16位int nId = 0;                //整型，最小尺寸16位long lId = 0;               //长整型，最小尺寸32位long long llId = 0;         //长整型，最小尺寸64位float fValue = 1.23f;       //单精度浮点数，最小尺寸6位有效数字double dValue = 1.23;       //双精度浮点数，最小尺寸10位有效数字long double ldValue = 1.23L;//扩展精度浮点数，最小尺寸10位有效数字</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>带符号类型（signed）</strong></td><td>保存正数、负数或0的整型</td></tr><tr><td><strong>无符号类型（unsigned）</strong></td><td>保存大于等于0的整型</td></tr><tr><td><strong>转换（conversion）</strong></td><td>一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换</td></tr><tr><td><strong>定义（definition）</strong></td><td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td></tr><tr><td><strong>未定义（undefined）</strong></td><td>即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题</td></tr></tbody></table><pre><code>unsigned u = 10;int i = -42;std::cout &lt;&lt; i + i &lt;&lt; std::endl;    //输出-84std::cout &lt;&lt; u + i &lt;&lt; std::endl;    //如果int占32位，输出4294967264unsigned u1 = 42, u2 = 10;std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl;  //正确：输出32std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl;  //正确：不过，结果是取模后的值</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>字面值（literal）</strong></td><td>是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值</td></tr><tr><td><strong>字符串（string）</strong></td><td>是一种库类型，表示可变长字符序列</td></tr><tr><td><strong>不可打印字符（noprintable character）</strong></td><td>不具有可见形式的字符，如控制符、退格、换行符等</td></tr><tr><td><strong>转义序列（escape sequence）</strong></td><td>字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数</td></tr></tbody></table><pre><code>L&#39;a&#39;        //宽字符型字面值，类型是wchar_tu8&quot;hi!&quot;     //utf-8字符串字面值42ULL       //无符号整型字面值，类型是unsigned long long1E-3F       //单精度浮点型字面值，类型是float3.14159L    //扩展精度浮点型字面值，类型是long double</code></pre><pre><code>    换行符      \n      横向制表符      \t      报警（响铃）符      \a    纵向制表符  \v      退格符          \b      双引号              \&quot;    反斜线      \\      问号            \?      单引号              \&#39;    回车符      \r      进纸符          \f</code></pre><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>变量（variable）</strong></td><td>命名的对象或引用。C++语言要求变量要先声明后使用</td></tr><tr><td><strong>对象（object）</strong></td><td>是内存的一块区域，具有某种类型，变量是命名了的对象</td></tr><tr><td><strong>类型说明符（type specifier）</strong></td><td>类型的名字</td></tr><tr><td><strong>被初始化（initialized）</strong></td><td>变量在定义的同时被赋予初始值，变量一般都应该被初始化</td></tr><tr><td><strong>列表初始化（list initialization）</strong></td><td>利用花括号把一个或多个初始值放在一起的初始化形式</td></tr><tr><td><strong>默认初始化（default initialization）</strong></td><td>当对象未被显式地附于初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值</td></tr></tbody></table><pre><code>int sum = 0, value,                                 //sum、value和units_sold都是int        units_sold = 0                              //sum和units_sold初值为0Sales_item item;                                    //item的类型是Sales_item，Sales_item是一个自定义类std::string book(&quot;0-201-78345-X&quot;);                  //book通过一个string字面值初始化double price = 109.99, discount = price * 0.16;     //price先被定义并赋值，随后被用于初始化discountdouble salePrice = applyDiscount(price, discount);  //调用函数applyDiscound，然后用函数的返回值初始化salePriceint units_sold{0};              //列表初始化long double ld = 3.1415926536;int a{ld}, b = {ld};            //错误：使用列表初始化且初始值存在丢失信息的危险，则编译器将报错int c(ld), d = ld;              //正确：转换执行，且确实丢失了部分值std::string empty;              //empty默认初始化为一个空串Sales_item item;                //被默认初始化的Sales_item对象</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>分离式编译（separate compilation）</strong></td><td>把程序分割为多个单独文件的能力</td></tr><tr><td><strong>声明（declaration）</strong></td><td>声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用</td></tr><tr><td><strong>声明符（declarator）</strong></td><td>是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有</td></tr><tr><td><strong>定义（definition）</strong></td><td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td></tr></tbody></table><pre><code>extern int i;                   //声明i而非定义iint j;                          //声明并定义jextern double pi = 3.1416;      //定义</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>标识符（identifier）</strong></td><td>标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++保留了一些名字供<a href="https://devdocs.io/cpp-keywords/" target="_blank" rel="noopener">语言</a>本身使用，这些名字不能被用作标识符。</td></tr></tbody></table><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>作用域（scope）</strong></td><td>是程序的一部分，在其中某些名字有意义。C++有几级作用域：<br>- <strong>全局（global）</strong>——名字定义在所有其他作用域之外<br>- <strong>类（class）</strong>——名字定义在类内部<br>- <strong>命名空间（namespace）</strong>——名字定义在命名空间内部<br>- <strong>块（block）</strong>——名字定义在块内部</td></tr><tr><td><strong>在作用域内（in scope）</strong></td><td>名字在当前作用域内可见</td></tr><tr><td><strong>内层作用域（inner scope）</strong></td><td>嵌套（包含）在其他作用域之内的作用域</td></tr><tr><td><strong>外层作用域（outer scope）</strong></td><td>嵌套（包含）着别的作用域的作用域</td></tr></tbody></table><h1 id="3-复合类型"><a href="#3-复合类型" class="headerlink" title="3.复合类型"></a>3.复合类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>复合类型（compound type）</strong></td><td>是一种类型，它的定义以其他类型为基础</td></tr><tr><td><strong>引用（reference）</strong></td><td>是某个对象的别名</td></tr><tr><td><strong>绑定（bind）</strong></td><td>令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起</td></tr></tbody></table><pre><code>int ival = 1024;int &amp;refVal = ival;         //refVal指向ival（是ival的另一个名字）int &amp;refVal2;               //报错：引用必须被初始化refVal = 2;                 //把2赋给refVal指向的对象，此处即是赋给了ivalint ii = refVal;            //与ii = ival执行结果一样int i = 1024, i2 = 2048;    //i和i2都是intint &amp;r = i, r2 = i2;        //r是一个引用，与i绑定在一起，r2是intint i3 = 1024, &amp;ri = i3;    //i3是int，ri是一个引用，与i3绑定在一起int &amp;r3 = i3, &amp;r4 = i2;     //r3和r4都是引用</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>指针（pointer）</strong></td><td>是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0</td></tr><tr><td><strong>&amp;运算符（&amp; operator）</strong></td><td>取地址运算符</td></tr><tr><td><strong>*运算符（ * operator ）</strong></td><td>解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值</td></tr><tr><td><strong>空指针（null pointer）</strong></td><td>值为0的指针，空指针合法但是不指向任何对象</td></tr><tr><td><strong>nullptr</strong></td><td>是表示空指针的字面值常量</td></tr><tr><td><strong>void*</strong></td><td>可以指向任意非常量的指针类型，不能执行解引用操作</td></tr></tbody></table><pre><code>//指针int *ip1, *ip2;     //ip1和ip2都是指向int型对象的指针double dp, *dp2;    //dp2是指向double型对象的指针，dp是double型对象int ival = 42;int *p = &amp;ival;     //p存放变量ival的地址，或者说p是指向变量ival的指针cout &lt;&lt; *p;         //由符号*得到指针p所指的对象，输出42*p = 0;             //由符号*得到指针p所指的对象，即可经由p为变量ival赋值cout &lt;&lt; *p;         //输出0//指向指针的指针int ival = 1024;int *pi = &amp;ival;        //pi指向一个int型的数int **ppi = &amp;pi;        //ppi指向一个int型的指针//指向指针的引用int i = 42;int *pn;            //pn是一个int型指针int *&amp;r = pn;       //r是一个对指针pn的引用r = &amp;i;             //r引用了一个指针，因此给r赋值&amp;i就是令pn指向i*r = 0;             //解引用r得到i，也就是pn指向的对象，将i的值改为0//空指针int *p1 = nullptr;      //等价于int *p1 = 0;int *p2 = 0;            //直接将p2初始化为字面常量0//需要首先#include cstdlibint *p3 = NULL;         //等价于int *p3 = 0;//指针作为判断条件int *pi = 0;        //pi合法，是一个空指针int *pi2 = &amp;ival;   //pi2是一个合法的指针，存放着ival的地址if(pi)              //pi的值是0，因此条件的值为false    //...if(pi2)             //pi2指向ival，因此它的值不是0，条件的值是true    //...//void*指针double obj = 3.14, *pd = &amp;obj;  //正确：void*能存放任意类型对象的地址void *pv = &amp;obj;                //obj可以是任意类型的对象pv = pd;                        //pv可以存放任意类型的指针</code></pre><h1 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4.const限定符"></a>4.const限定符</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>const</strong></td><td>是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化</td></tr></tbody></table><pre><code>const int bufSize = 512;        //输入缓冲区大小bufSize = 1024;                 //错误：试图向const对象写值const int i = get_size();   //正确：运行时初始化const int j = 42;           //正确：编译时初始化const int k;                //错误：k是一个未经初始化的常量const int ci = i;           //正确：i的值被拷贝给了cij = ci;                 //正确：ci的值被拷贝给了j</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>对常量的引用（reference to const）</strong></td><td>是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果</td></tr><tr><td><strong>常量引用（const reference）</strong></td><td>是一种习惯叫法，含义是指向常量的引用</td></tr></tbody></table><pre><code>const int ci = 1024;const int &amp;r1 = ci;     //正确：引用及其对应的对象都是常量r1 - 42;                //错误：r1是对常量的引用int &amp;r2 = ci;           //错误：视图让一个非常量引用指向一个常量对象</code></pre><pre><code>int i = 42;const int &amp;r1 = i;      //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42;     //正确：r1是一个常量引用const int &amp;r3 = r1 * 2; //正确：r3是一个常量引用int &amp;r4 = r1 * 2;       //错误：r4是一个普通的非常量引用</code></pre><pre><code>int i = 42;int &amp;r1 = i;            //引用ri绑定对象iconst int &amp;r2 = i;      //r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0;                 //r1并非常量，i的值修改为0r2 = 0;                 //错误：r2是一个常量引用</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>指向常量的指针（pointer to const）</strong></td><td>是一个指针，存放着某个常量对象的指针。指向常量的指针不能用来改变它所指对象的值</td></tr><tr><td><strong>常量指针（const pointer）</strong></td><td>是一种指针，它的值永不改变</td></tr></tbody></table><pre><code>//指向常量的指针const double pi = 3.14;     //pi是个常量，值不能改变double *ptr = &amp;pi;          //错误：ptr是一个普通指针const double *cptr = &amp;pi;   //正确：cptr可以指向一个双精度常量*cptr = 42;                 //错误：不能给*cptr赋值double dval = 3.14;         //dval是非常量cptr = &amp;dval;               //正确：但是不能通过cptr改变dval的值//常量指针int errNumb = 0;int *const curErr = &amp;errNumnb;      //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi;      //pip是一个指向常量对象的常量指针</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>顶层const（top-level const）</strong></td><td>是一个const，规定某对象的值不能改变</td></tr><tr><td><strong>底层const（low-level const）</strong></td><td>一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略</td></tr></tbody></table><pre><code>int i = 0;int *const p1 = &amp;i;         //不能改变p1的值，这是一个顶层constconst int ci = 42;          //不能改变c1的值，这是一个顶层constconst int *p2 = &amp;ci;        //允许改变p2的值，这是一个底层constconst int *const p3 = p2;   //靠右的const是顶层const，靠左的是底层constconst int &amp;r = ci;          //用于声明引用的const都是底层consti = ci;                     //正确：ci是一个顶层const，对此操作无影响p2 = p3;                    //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响int *p = p3;                //错误：p3包含底层const的定义，而p没有p2 = p3;                    //正确：p2和p3都是底层constp2 = &amp;i;                    //正确：int*能转换成const int*int &amp;r = ci;                //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2 = i;          //正确：const int&amp;可以绑定到一个普通int上</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>常量表达式（const expression）</strong></td><td>能在编译时计算并获取结果的表达式</td></tr><tr><td><strong>constexpr</strong></td><td>是一种函数，用于代表一条常量表达式</td></tr></tbody></table><pre><code>//常量表达式const int max_files = 20;           //max_files是常量表达式const int limit = max_files + 1;    //limit是常量表达式int staff_size = 27;                //staff_size不是常量表达式const int sz = get_size();          //sz不是常量表达式//constexprconstexpr int mf = 20;          //20是常量表达式constexpr int limit = mf + 1;   //mf + 1是常量表达式constexpr int sz = size();      //只有当size是一个constexpr函数时                                //才是一条正确的声明语句const int *p = nullptr;     //p是一个指向整型常量的指针constexpr int *np = nullptr;    //np是一个指向整数的常量指针，其值为空int j = 0;constexpr int i = 42;           //i的类型是整型常量//i和j都必须定义在函数体之外constexpr const int *p = &amp;i;    //p是常量指针，指向整型常量iconstexpr int *pl = &amp;j;         //p1是常量指针，指向整数j</code></pre><h1 id="5-处理类型"><a href="#5-处理类型" class="headerlink" title="5.处理类型"></a>5.处理类型</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类型别名（type alias）</strong></td><td>是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义</td></tr><tr><td><strong>typedef</strong></td><td>为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名</td></tr><tr><td><strong>别名声明（alias declaration）</strong></td><td>为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词</td></tr></tbody></table><pre><code>//类型别名typedef double wages;       //wages是double的同义词typedef wages base, *p;     //base是double的同义词，p是double*的同义词//别名声明using SI = Sales_item;      //SI是Sales_item的同义词，Sales_item是自定义类wages hourly, weekly;       //等价于double hourly、weekly;SI item;                    //等价于Sales_item itemtypedef char *pstring;const pstring cstr = 0;     //cstr是指向char的常量指针，而不是一个指向const char的指针，因为pstring基本类型是指针const pstring *ps;          //ps是一个指针，它的对象是指向char的常量指针</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>auto</strong></td><td>是一个类型说明符，通过变量的初始值来推断变量的类型</td></tr></tbody></table><pre><code>auto i = 0, *p = &amp;i;    //正确：i是整数、p是整形指针auto sz = 0, pi = 3.14; //错误：sz和pi的类型不一致int i = 0, &amp;r = i;auto a = r;         //a是一个整数（r是i的别名，而i是一个整数）//auto一般会忽略掉顶层const，同时底层const则会保留下来const int ci = i, &amp;cr = ci;auto b = ci;        //b是一个整数（ci的顶层const特性被忽略掉了）auto c = cr;        //c是一个整数（cr是ci的别名，ci本身是一个顶层const）auto d = &amp;i;        //d是一个整型指针（整数的地址就是指向整数的指针）auto e = &amp;ci;       //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）//如果希望推断出的auto类型是一个顶层const，需要明确指出const auto f = ci;  //ci的扮演类型是int，f是const int//可以将引用的类型设为auto，此时原来的初始化规则仍然适用auto &amp;g = ci;       //g是一个整型常量引用，绑定到ciauto &amp;h = 42;       //错误：不能为非常量引用绑定字面值const auto &amp;j = 42; //正确：可以为常量引用绑定字面值//切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型auto k = ci, &amp;l = i;    //k是整数，l是整型引用auto &amp;m = ci, *p = &amp;ci; //m是对整型常量的引用，p是指向整型常量的指针//错误：i的类型是int而&amp;ci的类型是const intauto &amp;n = i, *p2 = &amp;ci;</code></pre><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>decltype</strong></td><td>是一个类型说明符，从变量或表达式推断得到类型</td></tr></tbody></table><pre><code>decltype(f()) sum = x;  //sum的类型就是函数f的返回类型const int ci = 0, &amp;cj = ci;decltype(ci) x = 0;     //x的类型是const intdecltype(cj) y = x;     //y的类型是const int&amp;， y绑定到变量xdecltype(cj) z;         //错误：z是一个引用，必须初始化//decltype的结果可以是引用类型int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;      //正确：加法的结果是int，因此b是一个（未初始化的）intdecltype(*p) c;         //错误：c是int&amp;，必须初始化//decltype的表达式如果是加上了括号的变量，结果将是引用decltype((i)) d;        //错误：d是int&amp;，必须初始化decltype(i) e;          //正确：e是一个（未初始化的）int</code></pre><h1 id="6-以类的形式自定义数据结构"><a href="#6-以类的形式自定义数据结构" class="headerlink" title="6.以类的形式自定义数据结构"></a>6.以类的形式自定义数据结构</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>类（class）</strong></td><td>名字定义在类内部</td></tr><tr><td><strong>struct</strong></td><td>是一个关键字，用于定义类</td></tr><tr><td><strong>数据成员（data memeber）</strong></td><td>组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化</td></tr><tr><td><strong>类内初始值（in-class initializer）</strong></td><td>在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内</td></tr><tr><td><strong>头文件保护符（header guard）</strong></td><td>使用预处理变量以防止头文件被某个文件重复包含</td></tr><tr><td><strong>预处理变量（preprocessor variable）</strong></td><td>由预处理管理的变量。在程序编译之前，预处理器负责将程序中的预处变量替换成它的真实值</td></tr><tr><td><strong>预处理器（preprocessor）</strong></td><td>在C++编译过程中执行的一段程序</td></tr><tr><td><strong>#define</strong></td><td>是一条预处理指令，用于定义一个预处理变量</td></tr><tr><td><strong>#endif</strong></td><td>是一条预处理指令，用于结束一个#ifdef或#ifndef区域</td></tr><tr><td><strong>#ifdef</strong></td><td>是一条预处理指令，用于判断给定的变量是否已经定义</td></tr><tr><td><strong>ifndef</strong></td><td>是一条预处理指令，用于判断给定的变量是否尚未定义</td></tr></tbody></table><pre><code>//类struct Sales_data{    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><pre><code>//头文件保护符#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;struct Sales_data{    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 术语表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
