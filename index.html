<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>游戏还是生活</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="游戏还是生活">
<meta property="og:url" content="https://oliverbvb.github.io/index.html">
<meta property="og:site_name" content="游戏还是生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Oliver">
<meta property="article:tag" content="游戏，编程，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="游戏还是生活" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">游戏还是生活</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当然是全都要</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://oliverbvb.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-C-Primer术语表5-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2020-04-01T14:56:17.615Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/">C-Primer术语表5-函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1.函数基础"></a>1.函数基础</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数（function）</strong></td>
<td>可调用的计算单元</td>
</tr>
<tr>
<td><strong>函数体（function body）</strong></td>
<td>是一个块，用于定义函数所执行的操作</td>
</tr>
<tr>
<td><strong>()运算符（()operator）</strong></td>
<td>调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）</td>
</tr>
<tr>
<td><strong>对象生命周期（object lifetime）</strong></td>
<td>每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象</td>
</tr>
<tr>
<td><strong>局部变量（local variable）</strong></td>
<td>定义在块中的变量</td>
</tr>
<tr>
<td><strong>隐藏名字（hidden name）</strong></td>
<td>某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体</td>
</tr>
<tr>
<td><strong>自动对象（automatic object）</strong></td>
<td>仅存在于函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象：当到达了定义所在的块的末尾时，销毁该对象</td>
</tr>
<tr>
<td><strong>局部静态对象（local static object）</strong></td>
<td>它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁</td>
</tr>
<tr>
<td><strong>函数原型（function prototype）</strong></td>
<td>函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型</td>
</tr>
<tr>
<td><strong>分离式编译（separate compliation）</strong></td>
<td>把一个程序分割成多个独立源文件的能力</td>
</tr>
<tr>
<td><strong>链接（link）</strong></td>
<td>是一个编译过程，负责把若干对象文件链接起来形成可执行程序</td>
</tr>
<tr>
<td><strong>可执行文件（executable file）</strong></td>
<td>是操作系统能够执行的文件，包含着与程序有关的代码</td>
</tr>
<tr>
<td><strong>对象文件（object file）</strong></td>
<td>编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件</td>
</tr>
<tr>
<td><strong>对象代码（object code）</strong></td>
<td>编译器将我们的源代码转换成对象代码格式</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数的形参列表</span><br><span class="line">void f1()&#123; &#x2F;*...*&#x2F; &#125;        &#x2F;&#x2F;隐式地定义空形参列表</span><br><span class="line">void f2(void)&#123; &#x2F;*...*&#x2F; &#125;    &#x2F;&#x2F;显式地定义空形参列表</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部静态对象</span><br><span class="line">size_t count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    static size_t ctr &#x3D; 0;      &#x2F;&#x2F;调用结束后，这个值仍然有效</span><br><span class="line">    return ++ctr;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;输出从1到10的数字</span><br><span class="line">    for(size_t i &#x3D; 0; i !&#x3D; 10; ++i)</span><br><span class="line">        cout &lt;&lt; count_calls() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2.参数传递"></a>2.参数传递</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>形参（parameter）</strong></td>
<td>在函数的形参列表中声明的局部变量。用实参初始化形参。</td>
</tr>
<tr>
<td><strong>实参（argument）</strong></td>
<td>函数调用时提供的值，用于初始化函数的形参</td>
</tr>
<tr>
<td><strong>引用传递（pass by reference）</strong></td>
<td>描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上</td>
</tr>
<tr>
<td><strong>值传递（pass by value）</strong></td>
<td>描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本</td>
</tr>
<tr>
<td><strong>传引用调用（call by reference）</strong></td>
<td>参见引用传递</td>
</tr>
<tr>
<td><strong>传值调用（call by value）</strong></td>
<td>参见值传递</td>
</tr>
<tr>
<td><strong>initializer_list</strong></td>
<td>是一个标准类，表示的是一个组花括号包围的类型相同的对象，对象之间以逗号隔开</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针形参</span><br><span class="line">void reset(int *ip)</span><br><span class="line">&#123;</span><br><span class="line">    *ip &#x3D; 0;    &#x2F;&#x2F;改变指针ip所指对象的值</span><br><span class="line">    ip &#x3D; 0;     &#x2F;&#x2F;只改变了ip的局部拷贝，实参未被改变</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const形参</span><br><span class="line">void fcn(const int i)&#123;&#x2F;* fcn能够读取i，但是不能向i写值 *&#x2F;&#125;  &#x2F;&#x2F;既可以传入const int也可以传入int</span><br><span class="line">void fcn(int i)&#123;&#125;   &#x2F;&#x2F;错误：重复定义了fcn(int)</span><br><span class="line"></span><br><span class="line">&#x2F;* 数组形参 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尽管形式不同，但这三个print函数是等价的</span><br><span class="line">&#x2F;&#x2F;每个函数都有一个const int*类型的形参</span><br><span class="line">void print(const int*);</span><br><span class="line">void print(const int[]);    &#x2F;&#x2F;可以看出来，函数的意图是作用于一个数组</span><br><span class="line">void print(const int[10]);  &#x2F;&#x2F;这里的维度表示我们期望数组含有多少元素，实际不一定</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多维数组</span><br><span class="line">&#x2F;&#x2F;matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span><br><span class="line">void print(int (*matrix)[10], int rowSize)&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;等价定义</span><br><span class="line">void print(int matrix[][10], int rowSize)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 可变形参 *&#x2F;</span><br><span class="line"></span><br><span class="line">void error_msg(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto beg &#x3D; il.begin(); beg !&#x3D; il.end(); ++beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">&#x2F;&#x2F;expected和actual是string对象</span><br><span class="line">if(expected !&#x3D; actual)</span><br><span class="line">    error_msg(&#123;&quot;funxtionX&quot;, expected, actual&#125;);</span><br><span class="line">else</span><br><span class="line">    error_msg(&#123;&quot;functionX&quot;, &quot;okay&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="3-返回类型"><a href="#3-返回类型" class="headerlink" title="3.返回类型"></a>3.返回类型</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回类型（return type）</strong></td>
<td>是函数声明的一部分，用于指定函数返回值的类型</td>
</tr>
<tr>
<td><strong>递归函数（recursive function）</strong></td>
<td>直接或间接调用自身的函数</td>
</tr>
<tr>
<td><strong>递归循环（recursion loop）</strong></td>
<td>描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程</td>
</tr>
<tr>
<td><strong>尾置返回类型（trailing return type）</strong></td>
<td>把参数列表后面指定的返回类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不要返回局部对象的引用或指针，因为函数完成后，它所占用的存储空间也随之被释放掉</span><br><span class="line">&#x2F;&#x2F;严重错误：这个函数试图返回局部对象的引用</span><br><span class="line">const string &amp;manip()</span><br><span class="line">&#123;</span><br><span class="line">    string ret;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以某种方式改变一下ret</span><br><span class="line">    if(!ret.empty())</span><br><span class="line">        return ret;         &#x2F;&#x2F;错误：返回局部对象的引用</span><br><span class="line">    else</span><br><span class="line">        return &quot;Empty&quot;;     &#x2F;&#x2F;错误：&quot;Empty&quot;是一个局部临时量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用一个返回引用的函数得到左值，其他返回类型得到右值</span><br><span class="line">char &amp;get_val(string &amp;str, string::size_type ix)</span><br><span class="line">&#123;</span><br><span class="line">    return str[ix];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s(&quot;a value&quot;);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    get_val(s, 0) &#x3D; &#39;A&#39;;        &#x2F;&#x2F;将s[0]的值改为A</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列表初始化返回值</span><br><span class="line">vector&lt;string&gt; process()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    &#x2F;&#x2F;expected和actual是string对象</span><br><span class="line">    if(expected.empty())</span><br><span class="line">        return &#123;&#125;;              &#x2F;&#x2F;返回一个空vector对象</span><br><span class="line">    else if(expected &#x3D;&#x3D; actual)</span><br><span class="line">        return &#123;&quot;functionX&quot;, &quot;okay&quot;&#125;;   &#x2F;&#x2F;返回列表初始化的vector对象</span><br><span class="line">    else</span><br><span class="line">        return &#123;&quot;functionX&quot;, expected, actual&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用尾置返回类型</span><br><span class="line">&#x2F;&#x2F;func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用decltype</span><br><span class="line">int odd[] &#x3D; &#123;1, 3, 5, 7, 9&#125;;</span><br><span class="line">int even[] &#x3D; &#123;0, 2, 4, 6, 8&#125;;</span><br><span class="line">&#x2F;&#x2F;返回一个指针，该指针指向含有5个整数的数组</span><br><span class="line">decltype(odd) *arrPtr(int i)</span><br><span class="line">&#123;</span><br><span class="line">    return (i % 2) ? &amp;odd : &amp;even;  &#x2F;&#x2F;返回一个指向数组的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>重载函数（overloaded function）</strong></td>
<td>函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别</td>
</tr>
<tr>
<td><strong>函数匹配（function matching）</strong></td>
<td>编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较</td>
</tr>
<tr>
<td><strong>重载确定（overload resolution）</strong></td>
<td>参见函数匹配</td>
</tr>
<tr>
<td><strong>最佳匹配（best match）</strong></td>
<td>从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差</td>
</tr>
<tr>
<td><strong>无匹配（no match）</strong></td>
<td>是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配</td>
</tr>
<tr>
<td><strong>二义性调用（ambiguous call）</strong></td>
<td>是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</td>
</tr>
<tr>
<td><strong>候选函数（candidate function）</strong></td>
<td>解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内</td>
</tr>
<tr>
<td><strong>可行函数（viable function）</strong></td>
<td>是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(const Account&amp;);      &#x2F;&#x2F;根据Account查找记录</span><br><span class="line">Record lookup(const Phone&amp;);        &#x2F;&#x2F;根据Phone查找记录</span><br><span class="line">Record lookup(const Name&amp;);         &#x2F;&#x2F;根据Name查找记录</span><br><span class="line">Account acct;</span><br><span class="line">Phone phone;</span><br><span class="line">Record r1 &#x3D; lookup(acct);</span><br><span class="line">Record r2 &#x3D; lookup(phone);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</span><br><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(const Phone);     &#x2F;&#x2F;重复声明了</span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);    &#x2F;&#x2F;重复声明</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的</span><br><span class="line">Record lookup(Account&amp;);        &#x2F;&#x2F;函数作用于Account的引用</span><br><span class="line">Record lookup(const Account&amp;);  &#x2F;&#x2F;新函数，作用于常量引用</span><br><span class="line">Record lookup(Account*);        &#x2F;&#x2F;新函数，作用于指向Account的指针</span><br><span class="line">Record lookup(const Account*);  &#x2F;&#x2F;新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure>

<h1 id="5-默认实参、内联函数和预处理宏"><a href="#5-默认实参、内联函数和预处理宏" class="headerlink" title="5.默认实参、内联函数和预处理宏"></a>5.默认实参、内联函数和预处理宏</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认实参（default argument）</strong></td>
<td>当调用缺少了某个实参时，为该实参指定的默认值</td>
</tr>
<tr>
<td><strong>内联函数（inline function）</strong></td>
<td>请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销</td>
</tr>
<tr>
<td><strong>constexpr</strong></td>
<td>可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数</td>
</tr>
<tr>
<td><strong>预处理宏（preprocessor marco）</strong></td>
<td>类似于内联函数的一种预处理功能。除了assert之外，现在C++程序很少再使用预处理宏</td>
</tr>
<tr>
<td><strong>Assert</strong></td>
<td>是一个预处理宏，作用于一条表示条件的表达式。当未定义预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条错误信息并终止当前程序的执行</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认实参</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39; &#39;);</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39;*&#39;);      &#x2F;&#x2F;错误：重复声明</span><br><span class="line">string screen(sz &#x3D; 24, sz &#x3D; 80. char);  &#x2F;&#x2F;正确：添加默认实参</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内联版本：寻找两个string对象中较短的那个</span><br><span class="line">inline const string &amp;</span><br><span class="line">shorterString(const string &amp;s1, const string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">    return s1.size() &lt;&#x3D; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constexpr函数，函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句</span><br><span class="line">constexpr int new_sz() &#123;return 42;&#125;</span><br><span class="line">constexpr int foo &#x3D; new_sz();   &#x2F;&#x2F;正确：foo是一个常量表达式</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/" data-id="ck8hgey210003zguw9k9i8kwz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C-Primer术语表4-语句" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/" class="article-date">
  <time datetime="2020-04-01T14:55:44.911Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/">C-Primer术语表4-语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-简单语句"><a href="#1-简单语句" class="headerlink" title="1.简单语句"></a>1.简单语句</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>控制流（flow of control）</strong></td>
<td>程序的执行路径</td>
</tr>
<tr>
<td><strong>表达式语句（expression statement）</strong></td>
<td>即一条表达式后面跟上一个分号，令表达式执行求值过程</td>
</tr>
<tr>
<td><strong>空语句（null statement）</strong></td>
<td>只含有一个分号的语句</td>
</tr>
<tr>
<td><strong>块（block）</strong></td>
<td>包围在花括号内的由0条或多条语句组成的序列。块也是一条语句，所以只要是能使用语句的地方，就可以使用块</td>
</tr>
<tr>
<td><strong>复合语句（compound statement）</strong></td>
<td>和块是同义词</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ival + 5;       &#x2F;&#x2F;一条没什么实际用处的表达式语句</span><br><span class="line">cout &lt;&lt; ival;   &#x2F;&#x2F;一条有用的表达式语句</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重复读入数据直至到达文件末尾或某次输入的值等于sought</span><br><span class="line">while(cin &gt;&gt; s &amp;&amp; s !&#x3D; sought)</span><br><span class="line">    ;   &#x2F;&#x2F;空语句</span><br></pre></td></tr></table></figure>

<h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>if语句（if statement）</strong></td>
<td>判断条件，根据其结果有选择地执行语句。如果条件为真，执行if分支的代码；如果条件为假，控制权转移到if结构之后的第一条语句</td>
</tr>
<tr>
<td><strong>if else语句（if else statement）</strong></td>
<td>判断条件，根据其结果分别执行if分支或else分支的语句</td>
</tr>
<tr>
<td><strong>悬垂else（dangling else）</strong></td>
<td>是一个俗语，指的是如何处理嵌套if语句中if分支多于else分支的情况</td>
</tr>
<tr>
<td><strong>switch语句（switch statement）</strong></td>
<td>一种条件语句</td>
</tr>
<tr>
<td><strong>带标签语句（lebeled statement）</strong></td>
<td>前面带有标签的语句。所谓标签是指一个标识符以及紧跟着的一个冒号。对于同一个标识符来说，用作标签的同时还能用于其他目的，互不干扰</td>
</tr>
<tr>
<td><strong>case标签（case label）</strong></td>
<td>在switch语句中紧跟在case关键字之后的常量表达式（参见2.4.4节）。在同一个switch语句中任意两个case标签的值不能相同</td>
</tr>
<tr>
<td><strong>default标签（default label）</strong></td>
<td>是一种特殊的case标签，当switch表达式的值与所有case标签都无法匹配时，程序执行default标签下的内容</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注意</span><br><span class="line">case true:</span><br><span class="line">    &#x2F;&#x2F;因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法</span><br><span class="line">    string file_name;       &#x2F;&#x2F;错误：控制流绕过一个隐式初始化的变量</span><br><span class="line">    int ival &#x3D; 0;           &#x2F;&#x2F;错误：控制流绕过一个显式初始化的变量</span><br><span class="line">    int jval;               &#x2F;&#x2F;正确：因为jval没有初始化</span><br><span class="line">    break;</span><br><span class="line">case false:</span><br><span class="line">    &#x2F;&#x2F;正确：jval虽然在作用域内，但是它没有被初始化</span><br><span class="line">    jval &#x3D; next_num();      &#x2F;&#x2F;正确：给jval赋一个值</span><br><span class="line">    if(file_name.empty())   &#x2F;&#x2F;file_name在作用域内，但是没有被初始化</span><br><span class="line">        &#x2F;&#x2F;...</span><br></pre></td></tr></table></figure>

<h1 id="3-迭代语句"><a href="#3-迭代语句" class="headerlink" title="3.迭代语句"></a>3.迭代语句</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>while语句（while statement）</strong></td>
<td>只要指定的条件为真，就一直迭代执行目标语句</td>
</tr>
<tr>
<td><strong>for语句（for statement）</strong></td>
<td>替换迭代执行的迭代语句。常常用于遍历一个容器或者重复计算若干次</td>
</tr>
<tr>
<td><strong>范围for语句（range for statement）</strong></td>
<td>在一个序列中进行迭代的语句</td>
</tr>
<tr>
<td><strong>do while语句（do while statement）</strong></td>
<td>与while语句类似，区别是do while语句先执行循环体，再判断条件。循环体代码至少会执行一次</td>
</tr>
</tbody></table>
<h1 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4.跳转语句"></a>4.跳转语句</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>break语句（break statement）</strong></td>
<td>终止离它最近的循环或switch语句。控制权转移到循环或switch之后的第一条语句</td>
</tr>
<tr>
<td><strong>continue语句（continue statement）</strong></td>
<td>终止离它最近的循环的当前迭代。控制权转移到while或do while语句的条件部分、或者范围for循环的下一次迭代、或者传统for循环头部的表达式</td>
</tr>
<tr>
<td><strong>goto语句（goto statement）</strong></td>
<td>令控制权无条件转移到同一函数中一个指定的带标签语句。goto语句容易造成程序的控制流混乱，应禁止使用</td>
</tr>
</tbody></table>
<h1 id="5-try语句块和异常处理"><a href="#5-try语句块和异常处理" class="headerlink" title="5.try语句块和异常处理"></a>5.try语句块和异常处理</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>异常安全（exception safe）</strong></td>
<td>是一个术语，表示的含义是当抛出异常后，程序能执行正确的行为</td>
</tr>
<tr>
<td><strong>throw表达式（throw expression）</strong></td>
<td>一种中断当前执行路径的表达式</td>
</tr>
<tr>
<td><strong>引发（raise）</strong></td>
<td>含义类似于throw。在C++语言中既可以说抛出异常，也可以说引发异常</td>
</tr>
<tr>
<td><strong>try语句块（try block）</strong></td>
<td>跟在try关键字后面的块，以及一个或多个catch子句</td>
</tr>
<tr>
<td><strong>catch子句（catch clause）</strong></td>
<td>由三部分组成：catch关键字、括号里的异常声明以及一个语句块。catch子句的代码负责处理在异常声明中定义的异常</td>
</tr>
<tr>
<td><strong>异常处理代码（exception handler）</strong></td>
<td>程序某处引发异常后，用于处理该异常的另一处代码。和catch子句是同义词</td>
</tr>
<tr>
<td><strong>异常声明（exception declaration）</strong></td>
<td>位于catch子句中的声明，指明了该catch子句能处理的异常类型</td>
</tr>
<tr>
<td><strong>terminate</strong></td>
<td>是一个标准库函数，当异常没有被捕捉到时调用。terminate终止当前程序的执行</td>
</tr>
<tr>
<td><strong>异常类（exception class）</strong></td>
<td>是标准库定义的一组类，用于表示程序发生的错误</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* throw表达式 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;首先检查两条数据是否是关于同一种书籍的</span><br><span class="line">if(item1.isbn() !&#x3D; item2.isbn())</span><br><span class="line">    throw runtime_error(&quot;Data must refer to same ISBN&quot;);</span><br><span class="line">&#x2F;&#x2F;如果程序执行到了这里，表示两个ISBN是相同的</span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;* try语句块 *&#x2F;</span><br><span class="line">try&#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125;catch(exception-declaration)&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;catch(exception-declaration)&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;   &#x2F;&#x2F;...</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/" data-id="ck8hgey1q0000zguwavrm752e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C-Primer术语表3-表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A83-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-01T14:55:06.264Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A83-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C-Primer术语表3-表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>表达式（expression）</strong></td>
<td>C++程序中最低级别的计算。表达式将运算符作用于一个或多个运算对象，每个表达式都有对应的求值结果。表达式本身也可以作为运算对象，这时就得到了对多个运算符求值的复合表达式</td>
</tr>
<tr>
<td><strong>运算对象（operand）</strong></td>
<td>表达式在某些值上执行运算，这些值就是运算对象。一个运算符有一个或多个相关的运算对象</td>
</tr>
<tr>
<td><strong>运算符（operator）</strong></td>
<td>决定表达式所做操作的符号。C++语言定义了一套运算符并说明了这些运算符作用于内置类型时的含义</td>
</tr>
<tr>
<td><strong>结果（result）</strong></td>
<td>计算表达式得到的值或对象</td>
</tr>
<tr>
<td><strong><a href="https://zh.cppreference.com/w/cpp/language/operator_precedence" target="_blank" rel="noopener">优先级（precedence）</a></strong></td>
<td>规定了复合表达式中不同运算符的执行顺序。与低优先级的运算符相比，高优先级的运算符组合得更紧密</td>
</tr>
<tr>
<td><strong>结合律（associativity）</strong></td>
<td>规定具有相同优先级的运算符如何组合在一起。结合律分为左结合律（运算符从左向右组合）和右结合律（运算符从右向左组合）</td>
</tr>
<tr>
<td><strong>求值顺序（order of evaluation）</strong></td>
<td>是某个运算符的运算对象的求值顺序。大多数情况下，编译器可以选择运算对象求值的顺序。不过运算对象一定要在运算符之前得到求值结果</td>
</tr>
<tr>
<td><strong>一元运算符（unary operators）</strong></td>
<td>只有一个运算对象参与运算的运算符</td>
</tr>
<tr>
<td><strong>二元运算符（binary operator）</strong></td>
<td>有两个运算对象参与运算的运算符</td>
</tr>
<tr>
<td><strong>重载运算符（overloaded operator）</strong></td>
<td>针对某种运算符重新定义的适用于类类型的版本</td>
</tr>
<tr>
<td><strong>左值（lvalue）</strong></td>
<td>是指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象</td>
</tr>
<tr>
<td><strong>右值（rvalue）</strong></td>
<td>是指一种表达式，其结果是指而非值所在的位置</td>
</tr>
<tr>
<td><strong>复合表达式（compound expression）</strong></td>
<td>含有多于一个运算符的表达式</td>
</tr>
</tbody></table>
<h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&amp;&amp;运算符（&amp;&amp;operator）</strong></td>
<td>逻辑与运算符，如果两个运算对象都是真，结果才为真。只有当左侧运算对象为真时才会检查右侧对象</td>
</tr>
<tr>
<td><strong>&#124;&#124;运算符（&#124;&#124; operator）</strong></td>
<td>逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象</td>
</tr>
<tr>
<td><strong>!运算符（!operator）</strong></td>
<td>逻辑非运算符，将它的运算对象的布尔值取反</td>
</tr>
<tr>
<td><strong>短路求值（short-circuit evaluation）</strong></td>
<td>是一个专有名词，描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值</td>
</tr>
<tr>
<td><strong>++运算符（++operator）</strong></td>
<td>递增运算符。包括两种形式：前置版本和后置版本</td>
</tr>
<tr>
<td><strong>–运算符（–operator）</strong></td>
<td>递减运算符。包括两种形式：前置版本和后置版本</td>
</tr>
<tr>
<td><strong>?:运算符（?:operator）</strong></td>
<td>条件运算符</td>
</tr>
<tr>
<td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td>
<td>左移运算符，将左侧运算对象的值的（可能是提升后的）副本向左移位，移动的位数由右侧运算对象确定</td>
</tr>
<tr>
<td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td>
<td>右移运算符，除了移动方向相反，其他性质都和左移运算符类似</td>
</tr>
<tr>
<td><strong>&amp;运算符（&amp;operator）</strong></td>
<td>位与运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位都是1，所得结果中该位为1；否则所得结果中该位为0</td>
</tr>
<tr>
<td><strong>&#124;运算符（&#124; operator）</strong></td>
<td>位或运算符，由两个运算对象生成一个新的整型值。如果两个运算对象对应的位至少有一个是1，所得结果中该位为1；否则所得结果中该位为0</td>
</tr>
<tr>
<td><strong><del>运算符（</del>operator）</strong></td>
<td>位求反运算符，生成一个新的整数值。该值的每一位恰好与（可能是提升后的）运算对象的对应位相反</td>
</tr>
<tr>
<td><strong>sizeof</strong></td>
<td>是一个运算符，返回存储对象所需的字节数，该对象的类型可能是某个给定的类型名字，也可鞥由表达式的返回结果确定</td>
</tr>
<tr>
<td><strong>,运算符（,operator）</strong></td>
<td>逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，当且仅当右侧运算对象是左值时逗号运算符的结果是左值</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;条件运算符</span><br><span class="line">cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;);   &#x2F;&#x2F;输出pass或者fail</span><br><span class="line">cout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;     &#x2F;&#x2F;输出1或者0</span><br><span class="line">cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;;       &#x2F;&#x2F;错误：试图比较cout和60，因为小于运算符的优先级低于移位运算符，所以先输出了grade再进行比较</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sizeof运算符</span><br><span class="line">Sales_data data, *p;</span><br><span class="line">sizeof(Sales_data);         &#x2F;&#x2F;存储Sales_data类型的对象所占的空间大小</span><br><span class="line">sizeof data;                &#x2F;&#x2F;data的类型的大小，即sizeof(Sales_data)</span><br><span class="line">sizeof p;                   &#x2F;&#x2F;指针所占的空间大小</span><br><span class="line">sizeof *p;                  &#x2F;&#x2F;p所指类型的空间大小，即sizeof(Sales_data)</span><br><span class="line">sizeof data.revenue;        &#x2F;&#x2F;Sales_data的revenue成员对应类型的大小</span><br><span class="line">sizeof Sales_data::revenue; &#x2F;&#x2F;另一种获取revenue大小的方式</span><br></pre></td></tr></table></figure>

<h1 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>转换（conversion）</strong></td>
<td>一种类型的值改变成另一种类型的值的过程。C++语言定义了内置类型的转换规则。类类型同样可以转换</td>
</tr>
<tr>
<td><strong>隐式转换（implicit conversion）</strong></td>
<td>由编译器自动执行的类型转换。假如表达式需要某种特定的类型而运算对象是另外一种类型，此时只要规则允许，编译器就会自动地将运算对象转换成所需的类型</td>
</tr>
<tr>
<td><strong>算术转换（arithmetic conversion）</strong></td>
<td>从一种算术类型转换成另一种算术类型。在二元运算符的上下文中，为了保留精度，算术转换通常把较小的类型转换成较大的类型</td>
</tr>
<tr>
<td><strong>整型提升（integral promotion）</strong></td>
<td>把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即short、char等）总是会得到提升</td>
</tr>
<tr>
<td><strong>强制类型转换（cast）</strong></td>
<td>一种显式的类型转换</td>
</tr>
<tr>
<td><strong>static_cast</strong></td>
<td>显式地执行某种定义明确的类型转换，常用于替代由编译器隐式执行的类型转换</td>
</tr>
<tr>
<td><strong>const_cast</strong></td>
<td>一种涉及const的强制类型转换。将底层const对象转换成对应的非常量类型，或者执行相反的转换</td>
</tr>
<tr>
<td><strong>reinterpret_cast</strong></td>
<td>把运算对象的内容解释成另外一种类型。这种强制类型转换本质上依赖于机器而且非常危险</td>
</tr>
<tr>
<td><strong>dynamic_cast</strong></td>
<td>和继承及运行时类型识别一起使用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 隐式转换 *&#x2F;</span><br><span class="line"></span><br><span class="line">int ival &#x3D; 3.541 + 3;   &#x2F;&#x2F;结果为6，编译器可能会警告该运算损失了精度</span><br><span class="line">int ia[10];     &#x2F;&#x2F;含有10个整数的数组</span><br><span class="line">int* ip &#x3D; ia;   &#x2F;&#x2F;ia转换成指向数组首元素的指针</span><br><span class="line">&#x2F;&#x2F;转换成布尔类型</span><br><span class="line">char *cp &#x3D; get_string();</span><br><span class="line">if(cp) &#x2F;*...*&#x2F;      &#x2F;&#x2F;如果指针cp不是0，条件为真</span><br><span class="line">while(*cp) &#x2F;*...*&#x2F;  &#x2F;&#x2F;如果*cp不是空字符，条件为真</span><br><span class="line">&#x2F;&#x2F;转换成常量</span><br><span class="line">int i;</span><br><span class="line">const int &amp;j &#x3D; i;   &#x2F;&#x2F;非常量转换成const int的引用</span><br><span class="line">const int *p &#x3D; &amp;i;  &#x2F;&#x2F;非常量的地址转换成const的地址</span><br><span class="line">int &amp;r &#x3D; j, *q &#x3D; p; &#x2F;&#x2F;错误：不允许const转换成非常量</span><br><span class="line">&#x2F;&#x2F;类类型转换</span><br><span class="line">string s;</span><br><span class="line">while(cin &gt;&gt; s)     &#x2F;&#x2F;while的条件部分把cin转换成布尔值</span><br><span class="line"></span><br><span class="line">&#x2F;* 显式转换 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;static_cast</span><br><span class="line">double slope &#x3D; static_cast&lt;double&gt;(j) &#x2F; i;  &#x2F;&#x2F;进行强制类型转换以便执行浮点数除法</span><br><span class="line">void *p &#x3D; &amp;d;                               &#x2F;&#x2F;正确：任何非常量对象的地址都能存入void*</span><br><span class="line">double *dp &#x3D; static_cast&lt;double*&gt;(p);       &#x2F;&#x2F;正确：将void*转换回初始的指针类型</span><br><span class="line">&#x2F;&#x2F;const_cast</span><br><span class="line">const char *pc;</span><br><span class="line">char *p &#x3D; const_cast&lt;char*&gt;(pc);&#x2F;&#x2F;正确：但是通过p写值是未定义的行为</span><br><span class="line">const char *cp;</span><br><span class="line">char *q &#x3D; static_cast&lt;char*&gt;(cp);       &#x2F;&#x2F;错误：static_cast不能转换掉const性质</span><br><span class="line">static_cast&lt;string&gt;(cp);                &#x2F;&#x2F;正确：字符串字面值转换成string类型</span><br><span class="line">const_cast&lt;string&gt;(cp);                 &#x2F;&#x2F;错误：const_cast只改变常量属性</span><br><span class="line">&#x2F;&#x2F;reinterpret_cast</span><br><span class="line">int *ip;</span><br><span class="line">char *pc &#x3D; reinterpret_cast&lt;char*&gt;(ip);</span><br><span class="line">string str(pc);                         &#x2F;&#x2F;错误：可能导致异常的运行时行为，必须牢记pc所指的真实对象是一个int而非字符</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A83-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ck8hgey200002zguwgtf8hshs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C-Primer术语表2-字符串、向量和数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A82-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2020-04-01T14:53:55.725Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A82-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">C-Primer术语表2-字符串、向量和数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-命名空间的using声明"><a href="#1-命名空间的using声明" class="headerlink" title="1.命名空间的using声明"></a>1.命名空间的using声明</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>using声明（using declaration）</strong></td>
<td>令命名空间中的某个名字可被程序直接使用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">&#x2F;&#x2F;using声明，当我们使用名字cin时，从命名空间std中获取它</span><br><span class="line">using std::cin</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cin &gt;&gt; i;           &#x2F;&#x2F;正确</span><br><span class="line">    cout &lt;&lt; i;          &#x2F;&#x2F;错误：没有对应的using声明，必须使用完整的名字</span><br><span class="line">    std::cout &lt;&lt; i;     &#x2F;&#x2F;正确：显式地从std中使用cout</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-标准库类型string"><a href="#2-标准库类型string" class="headerlink" title="2.标准库类型string"></a>2.标准库类型string</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>容器（container）</strong></td>
<td>是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型</td>
</tr>
<tr>
<td><strong>缓冲区溢出（buffer overflow）</strong></td>
<td>一种严重的程序故障，主要的原因是视图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等</td>
</tr>
<tr>
<td><strong>string</strong></td>
<td>是一种标准库类型，表示字符的序列</td>
</tr>
<tr>
<td><strong>拷贝初始化（copy initialization）</strong></td>
<td>使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本</td>
</tr>
<tr>
<td><strong>直接初始化（direct initialization）</strong></td>
<td>不使用赋值号（=）的初始化形式</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s1;                          &#x2F;&#x2F;默认初始化，s1是一个空字符串</span><br><span class="line">string s2 &#x3D; s1;                     &#x2F;&#x2F;s2是s1的副本</span><br><span class="line">string s3 &#x3D; &quot;hiya&quot;;                 &#x2F;&#x2F;s3是该字符串字面值的副本</span><br><span class="line">string s4(10, &#39;c&#39;);                 &#x2F;&#x2F;s4的内容是cccccccccc</span><br><span class="line">string s5 &#x3D; &quot;hiya&quot;;                 &#x2F;&#x2F;拷贝初始化</span><br><span class="line">string s6(&quot;hiya&quot;);                  &#x2F;&#x2F;直接初始化</span><br><span class="line">string s7(10, &#39;c&#39;);                 &#x2F;&#x2F;直接初始化，s7的内容是cccccccccc</span><br><span class="line">string s8 &#x3D; string(10, &#39;c&#39;);        &#x2F;&#x2F;拷贝初始化，s8的内容是cccccccccc</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;字面值和string对象相加</span><br><span class="line">string s1 &#x3D; &quot;hello&quot;, s2 &#x3D; &quot;world&quot;;</span><br><span class="line">string s3 &#x3D; s1 + &quot;, &quot; + s2  + &#39;\n&#39;;</span><br><span class="line">string s4 &#x3D; s1 + &quot;, &quot;;              &#x2F;&#x2F;正确：把一个string对象和一个字面值相加</span><br><span class="line">string s5 &#x3D; &quot;hello&quot; + &quot;, &quot;;         &#x2F;&#x2F;错误，两个运算对象都不是string</span><br><span class="line">string s6 &#x3D; s1 + &quot;, &quot; + &quot;world&quot;;    &#x2F;&#x2F;正确</span><br><span class="line">string s7 &#x3D; &quot;hello&quot; + &quot;, &quot; + s2;    &#x2F;&#x2F;错误：不能把字面值直接相加</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>getline</strong></td>
<td>在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留</td>
</tr>
<tr>
<td><strong>empty</strong></td>
<td>是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type</td>
</tr>
<tr>
<td><strong>size_type</strong></td>
<td>是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型</td>
</tr>
<tr>
<td><strong>&lt;&lt;运算符（&lt;&lt;operator）</strong></td>
<td>标准库类型string定义的输出运算符，负责输出string对象中的字符</td>
</tr>
<tr>
<td><strong>&gt;&gt;运算符（&gt;&gt;operator）</strong></td>
<td>标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string line;</span><br><span class="line">    &#x2F;&#x2F;每次读入一整行，直至到达文件末尾</span><br><span class="line">    while(getline(cin, line))</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;每次读入一整行，遇到空行直接跳过</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">    if(!line.empty())</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string line;</span><br><span class="line">&#x2F;&#x2F;每次读入一整行，输出其中超过80个字符的行</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">    if(line.size() &gt; 80)</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>范围for语句（range for）</strong></td>
<td>一种控制语句，可以在值的一个特定集合内迭代</td>
</tr>
<tr>
<td><strong>索引（index）</strong></td>
<td>是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置</td>
</tr>
<tr>
<td><strong>[]运算符 （[]operator）</strong></td>
<td>下标运算符</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;范围for语句</span><br><span class="line">string s(&quot;Hellow World!!!&quot;);</span><br><span class="line">&#x2F;&#x2F;转换成大写形式</span><br><span class="line">for(auto &amp;c : s)        &#x2F;&#x2F;对于s中的每个字符（注意：c是引用）</span><br><span class="line">    c &#x3D; toupper(c);     &#x2F;&#x2F;c是一个引用，因此赋值语句将改变s中字符的值</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;[]运算符</span><br><span class="line">&#x2F;&#x2F;依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span><br><span class="line">for(decltype(s.size()) index &#x3D; 0; index !&#x3D; s.size() &amp;&amp; !isspace(s[index]); ++index)</span><br><span class="line">    s[index] &#x3D; toupper(s[index]);   &#x2F;&#x2F;将当前字符改成大写形式</span><br></pre></td></tr></table></figure>

<h1 id="3-标准库类型vector"><a href="#3-标准库类型vector" class="headerlink" title="3.标准库类型vector"></a>3.标准库类型vector</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>vector</strong></td>
<td>是一种标准库类型，容纳某指定类型的一组元素</td>
</tr>
<tr>
<td><strong>类模板（class template）</strong></td>
<td>用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息</td>
</tr>
<tr>
<td><strong>实例化（instantiation）</strong></td>
<td>编译器生成一个指定的模板类或函数的过程</td>
</tr>
<tr>
<td><strong>push_back</strong></td>
<td>是vector的成员，向vector对象的末尾添加元素</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;               &#x2F;&#x2F;ivec保存int类型的对象</span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   &#x2F;&#x2F;保存Sales_item类型的对象</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;    &#x2F;&#x2F;该向量的元素是vector对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;    &#x2F;&#x2F;列表初始化</span><br><span class="line">vector&lt;string&gt; v2(&quot;a&quot;, &quot;an&quot;, &quot;the&quot;);    &#x2F;&#x2F;错误</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; ivec(10, -1);   &#x2F;&#x2F;10个int类型的元素，每个元素都初始化为-1</span><br><span class="line">vector&lt;string&gt; svec(10, &quot;hi!&quot;); &#x2F;&#x2F;10个string类型的元素，每个都被初始化为&quot;hi!&quot;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; ivec(10);       &#x2F;&#x2F;10个元素，每个都初始化为0</span><br><span class="line">vector&lt;string&gt; svec(10);    &#x2F;&#x2F;10个元素，每个都是空string对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从标准输入中读取单词，将其作为vector对象的元素存储</span><br><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;        &#x2F;&#x2F;空vector对象</span><br><span class="line">while(cin &gt;&gt; word)&#123;</span><br><span class="line">    text.push_back(word);   &#x2F;&#x2F;把word添加到text后面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不能用下标形式添加元素</span><br><span class="line">vector&lt;int&gt; ivec;   &#x2F;&#x2F;空vector对象</span><br><span class="line">for(decltype(ivec.size()) ix &#x3D; 0; ix !&#x3D; 10; ++ix)</span><br><span class="line">    ivec[ix] &#x3D; ix;  &#x2F;&#x2F;严重错误：ivec不包含任何元素</span><br><span class="line"></span><br><span class="line">for(decltype(ivec.size()) ix &#x3D; 0; ix !&#x3D; 10; ++ix)</span><br><span class="line">    ivec.push_back(ix); &#x2F;&#x2F;正确：添加一个新元素，该元素的值是ix</span><br></pre></td></tr></table></figure>

<h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4.迭代器"></a>4.迭代器</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>迭代器（iterator）</strong></td>
<td>是一种类型，用于访问容器中的元素或者在元素之间移动</td>
</tr>
<tr>
<td><strong>迭代器运算（iterator arithmetic）</strong></td>
<td>是string或vector的迭代器的运算</td>
</tr>
<tr>
<td><strong>begin</strong></td>
<td>是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针</td>
</tr>
<tr>
<td><strong>end</strong></td>
<td>是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</td>
</tr>
<tr>
<td><strong>尾后迭代器（off-the-end iterator）</strong></td>
<td>end函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置</td>
</tr>
<tr>
<td><strong>difference_type</strong></td>
<td>由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离</td>
</tr>
<tr>
<td><strong>++运算符（++operator）</strong></td>
<td>是迭代器和指针定义的递增运算符</td>
</tr>
<tr>
<td><strong>-&gt;运算符（-&gt;operator）</strong></td>
<td>箭头运算符</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;some string&quot;);</span><br><span class="line">if(s.begin() !&#x3D; s.end())&#123;   &#x2F;&#x2F;确保s非空</span><br><span class="line">    auto it &#x3D; s.begin();    &#x2F;&#x2F;it表示s的第一个字符</span><br><span class="line">    *it &#x3D; toupper(*it);     &#x2F;&#x2F;将当前字符改成大写形式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it;       &#x2F;&#x2F;it能读写vector&lt;int&gt;的元素</span><br><span class="line">string::iterator it2;           &#x2F;&#x2F;it2能读写string对象中的字符</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::const_iterator it3;    &#x2F;&#x2F;it3只能读元素，不能写字符</span><br><span class="line">string:const_iterator it4;          &#x2F;&#x2F;it3只能读字符，不能写字符</span><br></pre></td></tr></table></figure>

<h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>size_t</strong></td>
<td>是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小</td>
</tr>
<tr>
<td><strong>指针运算（pointer arithmetic）</strong></td>
<td>是指针类型支持的算术运算中。指向数组的指针所支持的运算种类与迭代器运算一样</td>
</tr>
<tr>
<td><strong>prtdiff_t</strong></td>
<td>是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离</td>
</tr>
<tr>
<td><strong>C风格字符串（C-style string）</strong></td>
<td>以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错</td>
</tr>
<tr>
<td><strong>以空字符结束的字符串（null-terminated string）</strong></td>
<td>是一个字符串，它的最后一个字符后面还跟着一个空字符（’\0’）</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针和数组</span><br><span class="line">string nums[] &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;    &#x2F;&#x2F;数组的元素是string对象</span><br><span class="line">string *p &#x3D; &amp;nums[0];                       &#x2F;&#x2F;p指向nums的第一个元素</span><br><span class="line">string *p2 &#x3D; nums;  &#x2F;&#x2F;等价于p2 &#x3D; &amp;nums[0]</span><br><span class="line">int ia[] &#x3D; &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">int *beg &#x3D; begin(ia);       &#x2F;&#x2F;指向ia首元素的指针</span><br><span class="line">int *last &#x3D; end(ia);        &#x2F;&#x2F;指向arr尾元素的下一位置的指针</span><br><span class="line">ptrdiff_t n &#x3D; end(ia) - begin(ia);     &#x2F;&#x2F;n的类型是ptrdiff_t，值是10，也就是ia中元素的数量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C风格字符串</span><br><span class="line">char ca[] &#x3D; &#123;&#39;C&#39;, &#39;+&#39;, &#39;+&#39;&#125;;        &#x2F;&#x2F;不以空字符结束</span><br><span class="line">cout &lt;&lt; strlen(ca) &lt;&lt; endl;         &#x2F;&#x2F;严重错误：ca没有以空字符结束</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;比较两个C风格字符串</span><br><span class="line">const char ca1[] &#x3D; &quot;A string example&quot;;</span><br><span class="line">const char ca2[] &#x3D; &quot;A different string&quot;;</span><br><span class="line">if(ca1 &lt; ca2)           &#x2F;&#x2F;未定义的：视图比较两个无关地址</span><br><span class="line">if(strcmp(ca1, ca2) &lt; 0)    &#x2F;&#x2F;正确</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;混用string对象和C风格字符串</span><br><span class="line">string s &#x3D; ca1;</span><br><span class="line">char *str &#x3D; s;      &#x2F;&#x2F;错误：不能用string对象初始化char*</span><br><span class="line">const char *str &#x3D; s.c_str();    &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A82-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/" data-id="ck8hgey1z0001zguwhau120ug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C-Primer术语表1-变量和基本类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A81-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2020-03-31T15:55:15.310Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A81-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">C-Primer术语表1-变量和基本类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-基本内置类型"><a href="#1-基本内置类型" class="headerlink" title="1 基本内置类型"></a>1 基本内置类型</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本类型（base type）</strong></td>
<td>是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符</td>
</tr>
<tr>
<td><strong>算术类型（arithmetic type）</strong></td>
<td>布尔值、字符、整数、浮点数等内置类型</td>
</tr>
<tr>
<td><strong>void类型</strong></td>
<td>是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量</td>
</tr>
<tr>
<td><strong>字节（byte）</strong></td>
<td>内存中可寻址的最小单元，大多数机器的字节占8位</td>
</tr>
<tr>
<td><strong>字（word）</strong></td>
<td>在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool bIsOK &#x3D; true;          &#x2F;&#x2F;布尔类型，最下小尺寸未定义</span><br><span class="line">char chChar &#x3D; &#39;a&#39;;          &#x2F;&#x2F;字符，最小尺寸8位</span><br><span class="line">wchar_t chChar2 &#x3D; L&#39;a&#39;;     &#x2F;&#x2F;宽字符，最小尺寸16位</span><br><span class="line">char16_t chChar3 &#x3D; u&#39;a&#39;;    &#x2F;&#x2F;Unicode字符，最下尺寸16位</span><br><span class="line">char32_t chChar4 &#x3D; U&#39;a&#39;;    &#x2F;&#x2F;Unicode字符，最下尺寸32位</span><br><span class="line">short sId &#x3D; 0;              &#x2F;&#x2F;短整型，最小尺寸16位</span><br><span class="line">int nId &#x3D; 0;                &#x2F;&#x2F;整型，最小尺寸16位</span><br><span class="line">long lId &#x3D; 0;               &#x2F;&#x2F;长整型，最小尺寸32位</span><br><span class="line">long long llId &#x3D; 0;         &#x2F;&#x2F;长整型，最小尺寸64位</span><br><span class="line">float fValue &#x3D; 1.23f;       &#x2F;&#x2F;单精度浮点数，最小尺寸6位有效数字</span><br><span class="line">double dValue &#x3D; 1.23;       &#x2F;&#x2F;双精度浮点数，最小尺寸10位有效数字</span><br><span class="line">long double ldValue &#x3D; 1.23L;&#x2F;&#x2F;扩展精度浮点数，最小尺寸10位有效数字</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>带符号类型（signed）</strong></td>
<td>保存正数、负数或0的整型</td>
</tr>
<tr>
<td><strong>无符号类型（unsigned）</strong></td>
<td>保存大于等于0的整型</td>
</tr>
<tr>
<td><strong>转换（conversion）</strong></td>
<td>一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换</td>
</tr>
<tr>
<td><strong>定义（definition）</strong></td>
<td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td>
</tr>
<tr>
<td><strong>未定义（undefined）</strong></td>
<td>即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned u &#x3D; 10;</span><br><span class="line">int i &#x3D; -42;</span><br><span class="line">std::cout &lt;&lt; i + i &lt;&lt; std::endl;    &#x2F;&#x2F;输出-84</span><br><span class="line">std::cout &lt;&lt; u + i &lt;&lt; std::endl;    &#x2F;&#x2F;如果int占32位，输出4294967264</span><br><span class="line"></span><br><span class="line">unsigned u1 &#x3D; 42, u2 &#x3D; 10;</span><br><span class="line">std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl;  &#x2F;&#x2F;正确：输出32</span><br><span class="line">std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl;  &#x2F;&#x2F;正确：不过，结果是取模后的值</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>字面值（literal）</strong></td>
<td>是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值</td>
</tr>
<tr>
<td><strong>字符串（string）</strong></td>
<td>是一种库类型，表示可变长字符序列</td>
</tr>
<tr>
<td><strong>不可打印字符（noprintable character）</strong></td>
<td>不具有可见形式的字符，如控制符、退格、换行符等</td>
</tr>
<tr>
<td><strong>转义序列（escape sequence）</strong></td>
<td>字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L&#39;a&#39;        &#x2F;&#x2F;宽字符型字面值，类型是wchar_t</span><br><span class="line">u8&quot;hi!&quot;     &#x2F;&#x2F;utf-8字符串字面值</span><br><span class="line">42ULL       &#x2F;&#x2F;无符号整型字面值，类型是unsigned long long</span><br><span class="line">1E-3F       &#x2F;&#x2F;单精度浮点型字面值，类型是float</span><br><span class="line">3.14159L    &#x2F;&#x2F;扩展精度浮点型字面值，类型是long double</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">换行符      \n      横向制表符      \t      报警（响铃）符      \a</span><br><span class="line">纵向制表符  \v      退格符          \b      双引号              \&quot;</span><br><span class="line">反斜线      \\      问号            \?      单引号              \&#39;</span><br><span class="line">回车符      \r      进纸符          \f</span><br></pre></td></tr></table></figure>

<h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>变量（variable）</strong></td>
<td>命名的对象或引用。C++语言要求变量要先声明后使用</td>
</tr>
<tr>
<td><strong>对象（object）</strong></td>
<td>是内存的一块区域，具有某种类型，变量是命名了的对象</td>
</tr>
<tr>
<td><strong>类型说明符（type specifier）</strong></td>
<td>类型的名字</td>
</tr>
<tr>
<td><strong>被初始化（initialized）</strong></td>
<td>变量在定义的同时被赋予初始值，变量一般都应该被初始化</td>
</tr>
<tr>
<td><strong>列表初始化（list initialization）</strong></td>
<td>利用花括号把一个或多个初始值放在一起的初始化形式</td>
</tr>
<tr>
<td><strong>默认初始化（default initialization）</strong></td>
<td>当对象未被显式地附于初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0, value,                                 &#x2F;&#x2F;sum、value和units_sold都是int</span><br><span class="line">        units_sold &#x3D; 0                              &#x2F;&#x2F;sum和units_sold初值为0</span><br><span class="line">Sales_item item;                                    &#x2F;&#x2F;item的类型是Sales_item，Sales_item是一个自定义类</span><br><span class="line">std::string book(&quot;0-201-78345-X&quot;);                  &#x2F;&#x2F;book通过一个string字面值初始化</span><br><span class="line">double price &#x3D; 109.99, discount &#x3D; price * 0.16;     &#x2F;&#x2F;price先被定义并赋值，随后被用于初始化discount</span><br><span class="line">double salePrice &#x3D; applyDiscount(price, discount);  &#x2F;&#x2F;调用函数applyDiscound，然后用函数的返回值初始化salePrice</span><br><span class="line"></span><br><span class="line">int units_sold&#123;0&#125;;              &#x2F;&#x2F;列表初始化</span><br><span class="line">long double ld &#x3D; 3.1415926536;</span><br><span class="line">int a&#123;ld&#125;, b &#x3D; &#123;ld&#125;;            &#x2F;&#x2F;错误：使用列表初始化且初始值存在丢失信息的危险，则编译器将报错</span><br><span class="line">int c(ld), d &#x3D; ld;              &#x2F;&#x2F;正确：转换执行，且确实丢失了部分值</span><br><span class="line"></span><br><span class="line">std::string empty;              &#x2F;&#x2F;empty默认初始化为一个空串</span><br><span class="line">Sales_item item;                &#x2F;&#x2F;被默认初始化的Sales_item对象</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分离式编译（separate compilation）</strong></td>
<td>把程序分割为多个单独文件的能力</td>
</tr>
<tr>
<td><strong>声明（declaration）</strong></td>
<td>声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用</td>
</tr>
<tr>
<td><strong>声明符（declarator）</strong></td>
<td>是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有</td>
</tr>
<tr>
<td><strong>定义（definition）</strong></td>
<td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i;                   &#x2F;&#x2F;声明i而非定义i</span><br><span class="line">int j;                          &#x2F;&#x2F;声明并定义j</span><br><span class="line">extern double pi &#x3D; 3.1416;      &#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标识符（identifier）</strong></td>
<td>标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++保留了一些名字供<a href="https://devdocs.io/cpp-keywords/" target="_blank" rel="noopener">语言</a>本身使用，这些名字不能被用作标识符。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用域（scope）</strong></td>
<td>是程序的一部分，在其中某些名字有意义。C++有几级作用域：<br>- <strong>全局（global）</strong>——名字定义在所有其他作用域之外<br>- <strong>类（class）</strong>——名字定义在类内部<br>- <strong>命名空间（namespace）</strong>——名字定义在命名空间内部<br>- <strong>块（block）</strong>——名字定义在块内部</td>
</tr>
<tr>
<td><strong>在作用域内（in scope）</strong></td>
<td>名字在当前作用域内可见</td>
</tr>
<tr>
<td><strong>内层作用域（inner scope）</strong></td>
<td>嵌套（包含）在其他作用域之内的作用域</td>
</tr>
<tr>
<td><strong>外层作用域（outer scope）</strong></td>
<td>嵌套（包含）着别的作用域的作用域</td>
</tr>
</tbody></table>
<h1 id="3-复合类型"><a href="#3-复合类型" class="headerlink" title="3.复合类型"></a>3.复合类型</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>复合类型（compound type）</strong></td>
<td>是一种类型，它的定义以其他类型为基础</td>
</tr>
<tr>
<td><strong>引用（reference）</strong></td>
<td>是某个对象的别名</td>
</tr>
<tr>
<td><strong>绑定（bind）</strong></td>
<td>令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int &amp;refVal &#x3D; ival;         &#x2F;&#x2F;refVal指向ival（是ival的另一个名字）</span><br><span class="line">int &amp;refVal2;               &#x2F;&#x2F;报错：引用必须被初始化</span><br><span class="line">refVal &#x3D; 2;                 &#x2F;&#x2F;把2赋给refVal指向的对象，此处即是赋给了ival</span><br><span class="line">int ii &#x3D; refVal;            &#x2F;&#x2F;与ii &#x3D; ival执行结果一样</span><br><span class="line"></span><br><span class="line">int i &#x3D; 1024, i2 &#x3D; 2048;    &#x2F;&#x2F;i和i2都是int</span><br><span class="line">int &amp;r &#x3D; i, r2 &#x3D; i2;        &#x2F;&#x2F;r是一个引用，与i绑定在一起，r2是int</span><br><span class="line">int i3 &#x3D; 1024, &amp;ri &#x3D; i3;    &#x2F;&#x2F;i3是int，ri是一个引用，与i3绑定在一起</span><br><span class="line">int &amp;r3 &#x3D; i3, &amp;r4 &#x3D; i2;     &#x2F;&#x2F;r3和r4都是引用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指针（pointer）</strong></td>
<td>是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0</td>
</tr>
<tr>
<td><strong>&amp;运算符（&amp; operator）</strong></td>
<td>取地址运算符</td>
</tr>
<tr>
<td><strong>*运算符（ * operator ）</strong></td>
<td>解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值</td>
</tr>
<tr>
<td><strong>空指针（null pointer）</strong></td>
<td>值为0的指针，空指针合法但是不指向任何对象</td>
</tr>
<tr>
<td><strong>nullptr</strong></td>
<td>是表示空指针的字面值常量</td>
</tr>
<tr>
<td><strong>void*</strong></td>
<td>可以指向任意非常量的指针类型，不能执行解引用操作</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针</span><br><span class="line">int *ip1, *ip2;     &#x2F;&#x2F;ip1和ip2都是指向int型对象的指针</span><br><span class="line">double dp, *dp2;    &#x2F;&#x2F;dp2是指向double型对象的指针，dp是double型对象</span><br><span class="line">int ival &#x3D; 42;</span><br><span class="line">int *p &#x3D; &amp;ival;     &#x2F;&#x2F;p存放变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line">cout &lt;&lt; *p;         &#x2F;&#x2F;由符号*得到指针p所指的对象，输出42</span><br><span class="line">*p &#x3D; 0;             &#x2F;&#x2F;由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span><br><span class="line">cout &lt;&lt; *p;         &#x2F;&#x2F;输出0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向指针的指针</span><br><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int *pi &#x3D; &amp;ival;        &#x2F;&#x2F;pi指向一个int型的数</span><br><span class="line">int **ppi &#x3D; &amp;pi;        &#x2F;&#x2F;ppi指向一个int型的指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向指针的引用</span><br><span class="line">int i &#x3D; 42;</span><br><span class="line">int *pn;            &#x2F;&#x2F;pn是一个int型指针</span><br><span class="line">int *&amp;r &#x3D; pn;       &#x2F;&#x2F;r是一个对指针pn的引用</span><br><span class="line">r &#x3D; &amp;i;             &#x2F;&#x2F;r引用了一个指针，因此给r赋值&amp;i就是令pn指向i</span><br><span class="line">*r &#x3D; 0;             &#x2F;&#x2F;解引用r得到i，也就是pn指向的对象，将i的值改为0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空指针</span><br><span class="line">int *p1 &#x3D; nullptr;      &#x2F;&#x2F;等价于int *p1 &#x3D; 0;</span><br><span class="line">int *p2 &#x3D; 0;            &#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class="line">&#x2F;&#x2F;需要首先#include cstdlib</span><br><span class="line">int *p3 &#x3D; NULL;         &#x2F;&#x2F;等价于int *p3 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指针作为判断条件</span><br><span class="line">int *pi &#x3D; 0;        &#x2F;&#x2F;pi合法，是一个空指针</span><br><span class="line">int *pi2 &#x3D; &amp;ival;   &#x2F;&#x2F;pi2是一个合法的指针，存放着ival的地址</span><br><span class="line">if(pi)              &#x2F;&#x2F;pi的值是0，因此条件的值为false</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">if(pi2)             &#x2F;&#x2F;pi2指向ival，因此它的值不是0，条件的值是true</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;void*指针</span><br><span class="line">double obj &#x3D; 3.14, *pd &#x3D; &amp;obj;  &#x2F;&#x2F;正确：void*能存放任意类型对象的地址</span><br><span class="line">void *pv &#x3D; &amp;obj;                &#x2F;&#x2F;obj可以是任意类型的对象</span><br><span class="line">pv &#x3D; pd;                        &#x2F;&#x2F;pv可以存放任意类型的指针</span><br></pre></td></tr></table></figure>

<h1 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4.const限定符"></a>4.const限定符</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>const</strong></td>
<td>是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize &#x3D; 512;        &#x2F;&#x2F;输入缓冲区大小</span><br><span class="line">bufSize &#x3D; 1024;                 &#x2F;&#x2F;错误：试图向const对象写值</span><br><span class="line">const int i &#x3D; get_size();   &#x2F;&#x2F;正确：运行时初始化</span><br><span class="line">const int j &#x3D; 42;           &#x2F;&#x2F;正确：编译时初始化</span><br><span class="line">const int k;                &#x2F;&#x2F;错误：k是一个未经初始化的常量</span><br><span class="line">const int ci &#x3D; i;           &#x2F;&#x2F;正确：i的值被拷贝给了ci</span><br><span class="line">j &#x3D; ci;                 &#x2F;&#x2F;正确：ci的值被拷贝给了j</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>对常量的引用（reference to const）</strong></td>
<td>是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果</td>
</tr>
<tr>
<td><strong>常量引用（const reference）</strong></td>
<td>是一种习惯叫法，含义是指向常量的引用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci &#x3D; 1024;</span><br><span class="line">const int &amp;r1 &#x3D; ci;     &#x2F;&#x2F;正确：引用及其对应的对象都是常量</span><br><span class="line">r1 - 42;                &#x2F;&#x2F;错误：r1是对常量的引用</span><br><span class="line">int &amp;r2 &#x3D; ci;           &#x2F;&#x2F;错误：视图让一个非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">const int &amp;r1 &#x3D; i;      &#x2F;&#x2F;允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2 &#x3D; 42;     &#x2F;&#x2F;正确：r1是一个常量引用</span><br><span class="line">const int &amp;r3 &#x3D; r1 * 2; &#x2F;&#x2F;正确：r3是一个常量引用</span><br><span class="line">int &amp;r4 &#x3D; r1 * 2;       &#x2F;&#x2F;错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int &amp;r1 &#x3D; i;            &#x2F;&#x2F;引用ri绑定对象i</span><br><span class="line">const int &amp;r2 &#x3D; i;      &#x2F;&#x2F;r2也绑定对象i，但是不允许通过r2修改i的值</span><br><span class="line">r1 &#x3D; 0;                 &#x2F;&#x2F;r1并非常量，i的值修改为0</span><br><span class="line">r2 &#x3D; 0;                 &#x2F;&#x2F;错误：r2是一个常量引用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指向常量的指针（pointer to const）</strong></td>
<td>是一个指针，存放着某个常量对象的指针。指向常量的指针不能用来改变它所指对象的值</td>
</tr>
<tr>
<td><strong>常量指针（const pointer）</strong></td>
<td>是一种指针，它的值永不改变</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指向常量的指针</span><br><span class="line">const double pi &#x3D; 3.14;     &#x2F;&#x2F;pi是个常量，值不能改变</span><br><span class="line">double *ptr &#x3D; &amp;pi;          &#x2F;&#x2F;错误：ptr是一个普通指针</span><br><span class="line">const double *cptr &#x3D; &amp;pi;   &#x2F;&#x2F;正确：cptr可以指向一个双精度常量</span><br><span class="line">*cptr &#x3D; 42;                 &#x2F;&#x2F;错误：不能给*cptr赋值</span><br><span class="line">double dval &#x3D; 3.14;         &#x2F;&#x2F;dval是非常量</span><br><span class="line">cptr &#x3D; &amp;dval;               &#x2F;&#x2F;正确：但是不能通过cptr改变dval的值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常量指针</span><br><span class="line">int errNumb &#x3D; 0;</span><br><span class="line">int *const curErr &#x3D; &amp;errNumnb;      &#x2F;&#x2F;curErr将一直指向errNumb</span><br><span class="line">const double pi &#x3D; 3.14159;</span><br><span class="line">const double *const pip &#x3D; &amp;pi;      &#x2F;&#x2F;pip是一个指向常量对象的常量指针</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>顶层const（top-level const）</strong></td>
<td>是一个const，规定某对象的值不能改变</td>
</tr>
<tr>
<td><strong>底层const（low-level const）</strong></td>
<td>一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">int *const p1 &#x3D; &amp;i;         &#x2F;&#x2F;不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci &#x3D; 42;          &#x2F;&#x2F;不能改变c1的值，这是一个顶层const</span><br><span class="line">const int *p2 &#x3D; &amp;ci;        &#x2F;&#x2F;允许改变p2的值，这是一个底层const</span><br><span class="line">const int *const p3 &#x3D; p2;   &#x2F;&#x2F;靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r &#x3D; ci;          &#x2F;&#x2F;用于声明引用的const都是底层const</span><br><span class="line"></span><br><span class="line">i &#x3D; ci;                     &#x2F;&#x2F;正确：ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 &#x3D; p3;                    &#x2F;&#x2F;正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br><span class="line"></span><br><span class="line">int *p &#x3D; p3;                &#x2F;&#x2F;错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2 &#x3D; p3;                    &#x2F;&#x2F;正确：p2和p3都是底层const</span><br><span class="line">p2 &#x3D; &amp;i;                    &#x2F;&#x2F;正确：int*能转换成const int*</span><br><span class="line">int &amp;r &#x3D; ci;                &#x2F;&#x2F;错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2 &#x3D; i;          &#x2F;&#x2F;正确：const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>常量表达式（const expression）</strong></td>
<td>能在编译时计算并获取结果的表达式</td>
</tr>
<tr>
<td><strong>constexpr</strong></td>
<td>是一种函数，用于代表一条常量表达式</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;常量表达式</span><br><span class="line">const int max_files &#x3D; 20;           &#x2F;&#x2F;max_files是常量表达式</span><br><span class="line">const int limit &#x3D; max_files + 1;    &#x2F;&#x2F;limit是常量表达式</span><br><span class="line">int staff_size &#x3D; 27;                &#x2F;&#x2F;staff_size不是常量表达式</span><br><span class="line">const int sz &#x3D; get_size();          &#x2F;&#x2F;sz不是常量表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constexpr</span><br><span class="line"></span><br><span class="line">constexpr int mf &#x3D; 20;          &#x2F;&#x2F;20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1;   &#x2F;&#x2F;mf + 1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size();      &#x2F;&#x2F;只有当size是一个constexpr函数时</span><br><span class="line">                                &#x2F;&#x2F;才是一条正确的声明语句</span><br><span class="line"></span><br><span class="line">const int *p &#x3D; nullptr;     &#x2F;&#x2F;p是一个指向整型常量的指针</span><br><span class="line">constexpr int *np &#x3D; nullptr;    &#x2F;&#x2F;np是一个指向整数的常量指针，其值为空</span><br><span class="line">int j &#x3D; 0;</span><br><span class="line">constexpr int i &#x3D; 42;           &#x2F;&#x2F;i的类型是整型常量</span><br><span class="line">&#x2F;&#x2F;i和j都必须定义在函数体之外</span><br><span class="line">constexpr const int *p &#x3D; &amp;i;    &#x2F;&#x2F;p是常量指针，指向整型常量i</span><br><span class="line">constexpr int *pl &#x3D; &amp;j;         &#x2F;&#x2F;p1是常量指针，指向整数j</span><br></pre></td></tr></table></figure>

<h1 id="5-处理类型"><a href="#5-处理类型" class="headerlink" title="5.处理类型"></a>5.处理类型</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型别名（type alias）</strong></td>
<td>是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义</td>
</tr>
<tr>
<td><strong>typedef</strong></td>
<td>为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名</td>
</tr>
<tr>
<td><strong>别名声明（alias declaration）</strong></td>
<td>为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类型别名</span><br><span class="line">typedef double wages;       &#x2F;&#x2F;wages是double的同义词</span><br><span class="line">typedef wages base, *p;     &#x2F;&#x2F;base是double的同义词，p是double*的同义词</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;别名声明</span><br><span class="line">using SI &#x3D; Sales_item;      &#x2F;&#x2F;SI是Sales_item的同义词，Sales_item是自定义类</span><br><span class="line"></span><br><span class="line">wages hourly, weekly;       &#x2F;&#x2F;等价于double hourly、weekly;</span><br><span class="line">SI item;                    &#x2F;&#x2F;等价于Sales_item item</span><br><span class="line"></span><br><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr &#x3D; 0;     &#x2F;&#x2F;cstr是指向char的常量指针，而不是一个指向const char的指针，因为pstring基本类型是指针</span><br><span class="line">const pstring *ps;          &#x2F;&#x2F;ps是一个指针，它的对象是指向char的常量指针</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>auto</strong></td>
<td>是一个类型说明符，通过变量的初始值来推断变量的类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">auto i &#x3D; 0, *p &#x3D; &amp;i;    &#x2F;&#x2F;正确：i是整数、p是整形指针</span><br><span class="line">auto sz &#x3D; 0, pi &#x3D; 3.14; &#x2F;&#x2F;错误：sz和pi的类型不一致</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0, &amp;r &#x3D; i;</span><br><span class="line">auto a &#x3D; r;         &#x2F;&#x2F;a是一个整数（r是i的别名，而i是一个整数）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;auto一般会忽略掉顶层const，同时底层const则会保留下来</span><br><span class="line">const int ci &#x3D; i, &amp;cr &#x3D; ci;</span><br><span class="line">auto b &#x3D; ci;        &#x2F;&#x2F;b是一个整数（ci的顶层const特性被忽略掉了）</span><br><span class="line">auto c &#x3D; cr;        &#x2F;&#x2F;c是一个整数（cr是ci的别名，ci本身是一个顶层const）</span><br><span class="line">auto d &#x3D; &amp;i;        &#x2F;&#x2F;d是一个整型指针（整数的地址就是指向整数的指针）</span><br><span class="line">auto e &#x3D; &amp;ci;       &#x2F;&#x2F;e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span><br><span class="line">&#x2F;&#x2F;如果希望推断出的auto类型是一个顶层const，需要明确指出</span><br><span class="line">const auto f &#x3D; ci;  &#x2F;&#x2F;ci的扮演类型是int，f是const int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以将引用的类型设为auto，此时原来的初始化规则仍然适用</span><br><span class="line">auto &amp;g &#x3D; ci;       &#x2F;&#x2F;g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h &#x3D; 42;       &#x2F;&#x2F;错误：不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j &#x3D; 42; &#x2F;&#x2F;正确：可以为常量引用绑定字面值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型</span><br><span class="line">auto k &#x3D; ci, &amp;l &#x3D; i;    &#x2F;&#x2F;k是整数，l是整型引用</span><br><span class="line">auto &amp;m &#x3D; ci, *p &#x3D; &amp;ci; &#x2F;&#x2F;m是对整型常量的引用，p是指向整型常量的指针</span><br><span class="line">&#x2F;&#x2F;错误：i的类型是int而&amp;ci的类型是const int</span><br><span class="line">auto &amp;n &#x3D; i, *p2 &#x3D; &amp;ci;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>decltype</strong></td>
<td>是一个类型说明符，从变量或表达式推断得到类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum &#x3D; x;  &#x2F;&#x2F;sum的类型就是函数f的返回类型</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; 0, &amp;cj &#x3D; ci;</span><br><span class="line">decltype(ci) x &#x3D; 0;     &#x2F;&#x2F;x的类型是const int</span><br><span class="line">decltype(cj) y &#x3D; x;     &#x2F;&#x2F;y的类型是const int&amp;， y绑定到变量x</span><br><span class="line">decltype(cj) z;         &#x2F;&#x2F;错误：z是一个引用，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的结果可以是引用类型</span><br><span class="line">int i &#x3D; 42, *p &#x3D; &amp;i, &amp;r &#x3D; i;</span><br><span class="line">decltype(r + 0) b;      &#x2F;&#x2F;正确：加法的结果是int，因此b是一个（未初始化的）int</span><br><span class="line">decltype(*p) c;         &#x2F;&#x2F;错误：c是int&amp;，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的表达式如果是加上了括号的变量，结果将是引用</span><br><span class="line">decltype((i)) d;        &#x2F;&#x2F;错误：d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;          &#x2F;&#x2F;正确：e是一个（未初始化的）int</span><br></pre></td></tr></table></figure>

<h1 id="6-以类的形式自定义数据结构"><a href="#6-以类的形式自定义数据结构" class="headerlink" title="6.以类的形式自定义数据结构"></a>6.以类的形式自定义数据结构</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类（class）</strong></td>
<td>名字定义在类内部</td>
</tr>
<tr>
<td><strong>struct</strong></td>
<td>是一个关键字，用于定义类</td>
</tr>
<tr>
<td><strong>数据成员（data memeber）</strong></td>
<td>组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化</td>
</tr>
<tr>
<td><strong>类内初始值（in-class initializer）</strong></td>
<td>在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内</td>
</tr>
<tr>
<td><strong>头文件保护符（header guard）</strong></td>
<td>使用预处理变量以防止头文件被某个文件重复包含</td>
</tr>
<tr>
<td><strong>预处理变量（preprocessor variable）</strong></td>
<td>由预处理管理的变量。在程序编译之前，预处理器负责将程序中的预处变量替换成它的真实值</td>
</tr>
<tr>
<td><strong>预处理器（preprocessor）</strong></td>
<td>在C++编译过程中执行的一段程序</td>
</tr>
<tr>
<td><strong>#define</strong></td>
<td>是一条预处理指令，用于定义一个预处理变量</td>
</tr>
<tr>
<td><strong>#endif</strong></td>
<td>是一条预处理指令，用于结束一个#ifdef或#ifndef区域</td>
</tr>
<tr>
<td><strong>#ifdef</strong></td>
<td>是一条预处理指令，用于判断给定的变量是否已经定义</td>
</tr>
<tr>
<td><strong>ifndef</strong></td>
<td>是一条预处理指令，用于判断给定的变量是否尚未定义</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类</span><br><span class="line">struct Sales_data&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold &#x3D; 0;</span><br><span class="line">    double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;头文件保护符</span><br><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold &#x3D; 0;</span><br><span class="line">    double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/03/31/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A81-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" data-id="ck8hg2t9g0000ccuw56modgh9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/">C-Primer术语表5-函数</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/">C-Primer术语表4-语句</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A83-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C-Primer术语表3-表达式</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A82-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">C-Primer术语表2-字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/03/31/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A81-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">C-Primer术语表1-变量和基本类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Oliver<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>