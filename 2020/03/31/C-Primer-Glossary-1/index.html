<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C-Primer-Glossary-1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一节 变量和基本类型术语表本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。 1 基本内置类型   术语 说明    基本类型（base type） 是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符   算术类型（arithmetic type） 布尔值、字符、整数、浮点数等内置类型   void类">
<meta property="og:type" content="article">
<meta property="og:title" content="C-Primer-Glossary-1">
<meta property="og:url" content="http://yoursite.com/2020/03/31/C-Primer-Glossary-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一节 变量和基本类型术语表本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。 1 基本内置类型   术语 说明    基本类型（base type） 是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符   算术类型（arithmetic type） 布尔值、字符、整数、浮点数等内置类型   void类">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-31T15:55:15.310Z">
<meta property="article:modified_time" content="2020-03-31T15:57:10.901Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C-Primer-Glossary-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/C-Primer-Glossary-1/" class="article-date">
  <time datetime="2020-03-31T15:55:15.310Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C-Primer-Glossary-1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一节-变量和基本类型术语表"><a href="#第一节-变量和基本类型术语表" class="headerlink" title="第一节 变量和基本类型术语表"></a>第一节 变量和基本类型术语表</h1><p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h2 id="1-基本内置类型"><a href="#1-基本内置类型" class="headerlink" title="1 基本内置类型"></a>1 基本内置类型</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本类型（base type）</strong></td>
<td>是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符</td>
</tr>
<tr>
<td><strong>算术类型（arithmetic type）</strong></td>
<td>布尔值、字符、整数、浮点数等内置类型</td>
</tr>
<tr>
<td><strong>void类型</strong></td>
<td>是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量</td>
</tr>
<tr>
<td><strong>字节（byte）</strong></td>
<td>内存中可寻址的最小单元，大多数机器的字节占8位</td>
</tr>
<tr>
<td><strong>字（word）</strong></td>
<td>在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool bIsOK &#x3D; true;          &#x2F;&#x2F;布尔类型，最下小尺寸未定义</span><br><span class="line">char chChar &#x3D; &#39;a&#39;;          &#x2F;&#x2F;字符，最小尺寸8位</span><br><span class="line">wchar_t chChar2 &#x3D; L&#39;a&#39;;     &#x2F;&#x2F;宽字符，最小尺寸16位</span><br><span class="line">char16_t chChar3 &#x3D; u&#39;a&#39;;    &#x2F;&#x2F;Unicode字符，最下尺寸16位</span><br><span class="line">char32_t chChar4 &#x3D; U&#39;a&#39;;    &#x2F;&#x2F;Unicode字符，最下尺寸32位</span><br><span class="line">short sId &#x3D; 0;              &#x2F;&#x2F;短整型，最小尺寸16位</span><br><span class="line">int nId &#x3D; 0;                &#x2F;&#x2F;整型，最小尺寸16位</span><br><span class="line">long lId &#x3D; 0;               &#x2F;&#x2F;长整型，最小尺寸32位</span><br><span class="line">long long llId &#x3D; 0;         &#x2F;&#x2F;长整型，最小尺寸64位</span><br><span class="line">float fValue &#x3D; 1.23f;       &#x2F;&#x2F;单精度浮点数，最小尺寸6位有效数字</span><br><span class="line">double dValue &#x3D; 1.23;       &#x2F;&#x2F;双精度浮点数，最小尺寸10位有效数字</span><br><span class="line">long double ldValue &#x3D; 1.23L;&#x2F;&#x2F;扩展精度浮点数，最小尺寸10位有效数字</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>带符号类型（signed）</strong></td>
<td>保存正数、负数或0的整型</td>
</tr>
<tr>
<td><strong>无符号类型（unsigned）</strong></td>
<td>保存大于等于0的整型</td>
</tr>
<tr>
<td><strong>转换（conversion）</strong></td>
<td>一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换</td>
</tr>
<tr>
<td><strong>定义（definition）</strong></td>
<td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td>
</tr>
<tr>
<td><strong>未定义（undefined）</strong></td>
<td>即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned u &#x3D; 10;</span><br><span class="line">int i &#x3D; -42;</span><br><span class="line">std::cout &lt;&lt; i + i &lt;&lt; std::endl;    &#x2F;&#x2F;输出-84</span><br><span class="line">std::cout &lt;&lt; u + i &lt;&lt; std::endl;    &#x2F;&#x2F;如果int占32位，输出4294967264</span><br><span class="line"></span><br><span class="line">unsigned u1 &#x3D; 42, u2 &#x3D; 10;</span><br><span class="line">std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl;  &#x2F;&#x2F;正确：输出32</span><br><span class="line">std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl;  &#x2F;&#x2F;正确：不过，结果是取模后的值</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>字面值（literal）</strong></td>
<td>是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值</td>
</tr>
<tr>
<td><strong>字符串（string）</strong></td>
<td>是一种库类型，表示可变长字符序列</td>
</tr>
<tr>
<td><strong>不可打印字符（noprintable character）</strong></td>
<td>不具有可见形式的字符，如控制符、退格、换行符等</td>
</tr>
<tr>
<td><strong>转义序列（escape sequence）</strong></td>
<td>字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L&#39;a&#39;        &#x2F;&#x2F;宽字符型字面值，类型是wchar_t</span><br><span class="line">u8&quot;hi!&quot;     &#x2F;&#x2F;utf-8字符串字面值</span><br><span class="line">42ULL       &#x2F;&#x2F;无符号整型字面值，类型是unsigned long long</span><br><span class="line">1E-3F       &#x2F;&#x2F;单精度浮点型字面值，类型是float</span><br><span class="line">3.14159L    &#x2F;&#x2F;扩展精度浮点型字面值，类型是long double</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">换行符      \n      横向制表符      \t      报警（响铃）符      \a</span><br><span class="line">纵向制表符  \v      退格符          \b      双引号              \&quot;</span><br><span class="line">反斜线      \\      问号            \?      单引号              \&#39;</span><br><span class="line">回车符      \r      进纸符          \f</span><br></pre></td></tr></table></figure>

<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>变量（variable）</strong></td>
<td>命名的对象或引用。C++语言要求变量要先声明后使用</td>
</tr>
<tr>
<td><strong>对象（object）</strong></td>
<td>是内存的一块区域，具有某种类型，变量是命名了的对象</td>
</tr>
<tr>
<td><strong>类型说明符（type specifier）</strong></td>
<td>类型的名字</td>
</tr>
<tr>
<td><strong>被初始化（initialized）</strong></td>
<td>变量在定义的同时被赋予初始值，变量一般都应该被初始化</td>
</tr>
<tr>
<td><strong>列表初始化（list initialization）</strong></td>
<td>利用花括号把一个或多个初始值放在一起的初始化形式</td>
</tr>
<tr>
<td><strong>默认初始化（default initialization）</strong></td>
<td>当对象未被显式地附于初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0, value,                                 &#x2F;&#x2F;sum、value和units_sold都是int</span><br><span class="line">        units_sold &#x3D; 0                              &#x2F;&#x2F;sum和units_sold初值为0</span><br><span class="line">Sales_item item;                                    &#x2F;&#x2F;item的类型是Sales_item，Sales_item是一个自定义类</span><br><span class="line">std::string book(&quot;0-201-78345-X&quot;);                  &#x2F;&#x2F;book通过一个string字面值初始化</span><br><span class="line">double price &#x3D; 109.99, discount &#x3D; price * 0.16;     &#x2F;&#x2F;price先被定义并赋值，随后被用于初始化discount</span><br><span class="line">double salePrice &#x3D; applyDiscount(price, discount);  &#x2F;&#x2F;调用函数applyDiscound，然后用函数的返回值初始化salePrice</span><br><span class="line"></span><br><span class="line">int units_sold&#123;0&#125;;              &#x2F;&#x2F;列表初始化</span><br><span class="line">long double ld &#x3D; 3.1415926536;</span><br><span class="line">int a&#123;ld&#125;, b &#x3D; &#123;ld&#125;;            &#x2F;&#x2F;错误：使用列表初始化且初始值存在丢失信息的危险，则编译器将报错</span><br><span class="line">int c(ld), d &#x3D; ld;              &#x2F;&#x2F;正确：转换执行，且确实丢失了部分值</span><br><span class="line"></span><br><span class="line">std::string empty;              &#x2F;&#x2F;empty默认初始化为一个空串</span><br><span class="line">Sales_item item;                &#x2F;&#x2F;被默认初始化的Sales_item对象</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分离式编译（separate compilation）</strong></td>
<td>把程序分割为多个单独文件的能力</td>
</tr>
<tr>
<td><strong>声明（declaration）</strong></td>
<td>声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用</td>
</tr>
<tr>
<td><strong>声明符（declarator）</strong></td>
<td>是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有</td>
</tr>
<tr>
<td><strong>定义（definition）</strong></td>
<td>为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i;                   &#x2F;&#x2F;声明i而非定义i</span><br><span class="line">int j;                          &#x2F;&#x2F;声明并定义j</span><br><span class="line">extern double pi &#x3D; 3.1416;      &#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标识符（identifier）</strong></td>
<td>标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++保留了一些名字供<a href="https://devdocs.io/cpp-keywords/" target="_blank" rel="noopener">语言</a>本身使用，这些名字不能被用作标识符。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用域（scope）</strong></td>
<td>是程序的一部分，在其中某些名字有意义。C++有几级作用域：<br>- <strong>全局（global）</strong>——名字定义在所有其他作用域之外<br>- <strong>类（class）</strong>——名字定义在类内部<br>- <strong>命名空间（namespace）</strong>——名字定义在命名空间内部<br>- <strong>块（block）</strong>——名字定义在块内部</td>
</tr>
<tr>
<td><strong>在作用域内（in scope）</strong></td>
<td>名字在当前作用域内可见</td>
</tr>
<tr>
<td><strong>内层作用域（inner scope）</strong></td>
<td>嵌套（包含）在其他作用域之内的作用域</td>
</tr>
<tr>
<td><strong>外层作用域（outer scope）</strong></td>
<td>嵌套（包含）着别的作用域的作用域</td>
</tr>
</tbody></table>
<h2 id="3-复合类型"><a href="#3-复合类型" class="headerlink" title="3.复合类型"></a>3.复合类型</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>复合类型（compound type）</strong></td>
<td>是一种类型，它的定义以其他类型为基础</td>
</tr>
<tr>
<td><strong>引用（reference）</strong></td>
<td>是某个对象的别名</td>
</tr>
<tr>
<td><strong>绑定（bind）</strong></td>
<td>令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int &amp;refVal &#x3D; ival;         &#x2F;&#x2F;refVal指向ival（是ival的另一个名字）</span><br><span class="line">int &amp;refVal2;               &#x2F;&#x2F;报错：引用必须被初始化</span><br><span class="line">refVal &#x3D; 2;                 &#x2F;&#x2F;把2赋给refVal指向的对象，此处即是赋给了ival</span><br><span class="line">int ii &#x3D; refVal;            &#x2F;&#x2F;与ii &#x3D; ival执行结果一样</span><br><span class="line"></span><br><span class="line">int i &#x3D; 1024, i2 &#x3D; 2048;    &#x2F;&#x2F;i和i2都是int</span><br><span class="line">int &amp;r &#x3D; i, r2 &#x3D; i2;        &#x2F;&#x2F;r是一个引用，与i绑定在一起，r2是int</span><br><span class="line">int i3 &#x3D; 1024, &amp;ri &#x3D; i3;    &#x2F;&#x2F;i3是int，ri是一个引用，与i3绑定在一起</span><br><span class="line">int &amp;r3 &#x3D; i3, &amp;r4 &#x3D; i2;     &#x2F;&#x2F;r3和r4都是引用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指针（pointer）</strong></td>
<td>是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0</td>
</tr>
<tr>
<td><strong>&amp;运算符（&amp; operator）</strong></td>
<td>取地址运算符</td>
</tr>
<tr>
<td><strong>*运算符（ * operator ）</strong></td>
<td>解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值</td>
</tr>
<tr>
<td><strong>空指针（null pointer）</strong></td>
<td>值为0的指针，空指针合法但是不指向任何对象</td>
</tr>
<tr>
<td><strong>nullptr</strong></td>
<td>是表示空指针的字面值常量</td>
</tr>
<tr>
<td><strong>void*</strong></td>
<td>可以指向任意非常量的指针类型，不能执行解引用操作</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针</span><br><span class="line">int *ip1, *ip2;     &#x2F;&#x2F;ip1和ip2都是指向int型对象的指针</span><br><span class="line">double dp, *dp2;    &#x2F;&#x2F;dp2是指向double型对象的指针，dp是double型对象</span><br><span class="line">int ival &#x3D; 42;</span><br><span class="line">int *p &#x3D; &amp;ival;     &#x2F;&#x2F;p存放变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line">cout &lt;&lt; *p;         &#x2F;&#x2F;由符号*得到指针p所指的对象，输出42</span><br><span class="line">*p &#x3D; 0;             &#x2F;&#x2F;由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span><br><span class="line">cout &lt;&lt; *p;         &#x2F;&#x2F;输出0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向指针的指针</span><br><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int *pi &#x3D; &amp;ival;        &#x2F;&#x2F;pi指向一个int型的数</span><br><span class="line">int **ppi &#x3D; &amp;pi;        &#x2F;&#x2F;ppi指向一个int型的指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向指针的引用</span><br><span class="line">int i &#x3D; 42;</span><br><span class="line">int *pn;            &#x2F;&#x2F;pn是一个int型指针</span><br><span class="line">int *&amp;r &#x3D; pn;       &#x2F;&#x2F;r是一个对指针pn的引用</span><br><span class="line">r &#x3D; &amp;i;             &#x2F;&#x2F;r引用了一个指针，因此给r赋值&amp;i就是令pn指向i</span><br><span class="line">*r &#x3D; 0;             &#x2F;&#x2F;解引用r得到i，也就是pn指向的对象，将i的值改为0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空指针</span><br><span class="line">int *p1 &#x3D; nullptr;      &#x2F;&#x2F;等价于int *p1 &#x3D; 0;</span><br><span class="line">int *p2 &#x3D; 0;            &#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class="line">&#x2F;&#x2F;需要首先#include cstdlib</span><br><span class="line">int *p3 &#x3D; NULL;         &#x2F;&#x2F;等价于int *p3 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指针作为判断条件</span><br><span class="line">int *pi &#x3D; 0;        &#x2F;&#x2F;pi合法，是一个空指针</span><br><span class="line">int *pi2 &#x3D; &amp;ival;   &#x2F;&#x2F;pi2是一个合法的指针，存放着ival的地址</span><br><span class="line">if(pi)              &#x2F;&#x2F;pi的值是0，因此条件的值为false</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">if(pi2)             &#x2F;&#x2F;pi2指向ival，因此它的值不是0，条件的值是true</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;void*指针</span><br><span class="line">double obj &#x3D; 3.14, *pd &#x3D; &amp;obj;  &#x2F;&#x2F;正确：void*能存放任意类型对象的地址</span><br><span class="line">void *pv &#x3D; &amp;obj;                &#x2F;&#x2F;obj可以是任意类型的对象</span><br><span class="line">pv &#x3D; pd;                        &#x2F;&#x2F;pv可以存放任意类型的指针</span><br></pre></td></tr></table></figure>

<h2 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4.const限定符"></a>4.const限定符</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>const</strong></td>
<td>是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize &#x3D; 512;        &#x2F;&#x2F;输入缓冲区大小</span><br><span class="line">bufSize &#x3D; 1024;                 &#x2F;&#x2F;错误：试图向const对象写值</span><br><span class="line">const int i &#x3D; get_size();   &#x2F;&#x2F;正确：运行时初始化</span><br><span class="line">const int j &#x3D; 42;           &#x2F;&#x2F;正确：编译时初始化</span><br><span class="line">const int k;                &#x2F;&#x2F;错误：k是一个未经初始化的常量</span><br><span class="line">const int ci &#x3D; i;           &#x2F;&#x2F;正确：i的值被拷贝给了ci</span><br><span class="line">j &#x3D; ci;                 &#x2F;&#x2F;正确：ci的值被拷贝给了j</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>对常量的引用（reference to const）</strong></td>
<td>是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果</td>
</tr>
<tr>
<td><strong>常量引用（const reference）</strong></td>
<td>是一种习惯叫法，含义是指向常量的引用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci &#x3D; 1024;</span><br><span class="line">const int &amp;r1 &#x3D; ci;     &#x2F;&#x2F;正确：引用及其对应的对象都是常量</span><br><span class="line">r1 - 42;                &#x2F;&#x2F;错误：r1是对常量的引用</span><br><span class="line">int &amp;r2 &#x3D; ci;           &#x2F;&#x2F;错误：视图让一个非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">const int &amp;r1 &#x3D; i;      &#x2F;&#x2F;允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2 &#x3D; 42;     &#x2F;&#x2F;正确：r1是一个常量引用</span><br><span class="line">const int &amp;r3 &#x3D; r1 * 2; &#x2F;&#x2F;正确：r3是一个常量引用</span><br><span class="line">int &amp;r4 &#x3D; r1 * 2;       &#x2F;&#x2F;错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int &amp;r1 &#x3D; i;            &#x2F;&#x2F;引用ri绑定对象i</span><br><span class="line">const int &amp;r2 &#x3D; i;      &#x2F;&#x2F;r2也绑定对象i，但是不允许通过r2修改i的值</span><br><span class="line">r1 &#x3D; 0;                 &#x2F;&#x2F;r1并非常量，i的值修改为0</span><br><span class="line">r2 &#x3D; 0;                 &#x2F;&#x2F;错误：r2是一个常量引用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指向常量的指针（pointer to const）</strong></td>
<td>是一个指针，存放着某个常量对象的指针。指向常量的指针不能用来改变它所指对象的值</td>
</tr>
<tr>
<td><strong>常量指针（const pointer）</strong></td>
<td>是一种指针，它的值永不改变</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指向常量的指针</span><br><span class="line">const double pi &#x3D; 3.14;     &#x2F;&#x2F;pi是个常量，值不能改变</span><br><span class="line">double *ptr &#x3D; &amp;pi;          &#x2F;&#x2F;错误：ptr是一个普通指针</span><br><span class="line">const double *cptr &#x3D; &amp;pi;   &#x2F;&#x2F;正确：cptr可以指向一个双精度常量</span><br><span class="line">*cptr &#x3D; 42;                 &#x2F;&#x2F;错误：不能给*cptr赋值</span><br><span class="line">double dval &#x3D; 3.14;         &#x2F;&#x2F;dval是非常量</span><br><span class="line">cptr &#x3D; &amp;dval;               &#x2F;&#x2F;正确：但是不能通过cptr改变dval的值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常量指针</span><br><span class="line">int errNumb &#x3D; 0;</span><br><span class="line">int *const curErr &#x3D; &amp;errNumnb;      &#x2F;&#x2F;curErr将一直指向errNumb</span><br><span class="line">const double pi &#x3D; 3.14159;</span><br><span class="line">const double *const pip &#x3D; &amp;pi;      &#x2F;&#x2F;pip是一个指向常量对象的常量指针</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>顶层const（top-level const）</strong></td>
<td>是一个const，规定某对象的值不能改变</td>
</tr>
<tr>
<td><strong>底层const（low-level const）</strong></td>
<td>一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">int *const p1 &#x3D; &amp;i;         &#x2F;&#x2F;不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci &#x3D; 42;          &#x2F;&#x2F;不能改变c1的值，这是一个顶层const</span><br><span class="line">const int *p2 &#x3D; &amp;ci;        &#x2F;&#x2F;允许改变p2的值，这是一个底层const</span><br><span class="line">const int *const p3 &#x3D; p2;   &#x2F;&#x2F;靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r &#x3D; ci;          &#x2F;&#x2F;用于声明引用的const都是底层const</span><br><span class="line"></span><br><span class="line">i &#x3D; ci;                     &#x2F;&#x2F;正确：ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 &#x3D; p3;                    &#x2F;&#x2F;正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br><span class="line"></span><br><span class="line">int *p &#x3D; p3;                &#x2F;&#x2F;错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2 &#x3D; p3;                    &#x2F;&#x2F;正确：p2和p3都是底层const</span><br><span class="line">p2 &#x3D; &amp;i;                    &#x2F;&#x2F;正确：int*能转换成const int*</span><br><span class="line">int &amp;r &#x3D; ci;                &#x2F;&#x2F;错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2 &#x3D; i;          &#x2F;&#x2F;正确：const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>常量表达式（const expression）</strong></td>
<td>能在编译时计算并获取结果的表达式</td>
</tr>
<tr>
<td><strong>constexpr</strong></td>
<td>是一种函数，用于代表一条常量表达式</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;常量表达式</span><br><span class="line">const int max_files &#x3D; 20;           &#x2F;&#x2F;max_files是常量表达式</span><br><span class="line">const int limit &#x3D; max_files + 1;    &#x2F;&#x2F;limit是常量表达式</span><br><span class="line">int staff_size &#x3D; 27;                &#x2F;&#x2F;staff_size不是常量表达式</span><br><span class="line">const int sz &#x3D; get_size();          &#x2F;&#x2F;sz不是常量表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constexpr</span><br><span class="line"></span><br><span class="line">constexpr int mf &#x3D; 20;          &#x2F;&#x2F;20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1;   &#x2F;&#x2F;mf + 1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size();      &#x2F;&#x2F;只有当size是一个constexpr函数时</span><br><span class="line">                                &#x2F;&#x2F;才是一条正确的声明语句</span><br><span class="line"></span><br><span class="line">const int *p &#x3D; nullptr;     &#x2F;&#x2F;p是一个指向整型常量的指针</span><br><span class="line">constexpr int *np &#x3D; nullptr;    &#x2F;&#x2F;np是一个指向整数的常量指针，其值为空</span><br><span class="line">int j &#x3D; 0;</span><br><span class="line">constexpr int i &#x3D; 42;           &#x2F;&#x2F;i的类型是整型常量</span><br><span class="line">&#x2F;&#x2F;i和j都必须定义在函数体之外</span><br><span class="line">constexpr const int *p &#x3D; &amp;i;    &#x2F;&#x2F;p是常量指针，指向整型常量i</span><br><span class="line">constexpr int *pl &#x3D; &amp;j;         &#x2F;&#x2F;p1是常量指针，指向整数j</span><br></pre></td></tr></table></figure>

<h2 id="5-处理类型"><a href="#5-处理类型" class="headerlink" title="5.处理类型"></a>5.处理类型</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型别名（type alias）</strong></td>
<td>是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义</td>
</tr>
<tr>
<td><strong>typedef</strong></td>
<td>为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名</td>
</tr>
<tr>
<td><strong>别名声明（alias declaration）</strong></td>
<td>为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类型别名</span><br><span class="line">typedef double wages;       &#x2F;&#x2F;wages是double的同义词</span><br><span class="line">typedef wages base, *p;     &#x2F;&#x2F;base是double的同义词，p是double*的同义词</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;别名声明</span><br><span class="line">using SI &#x3D; Sales_item;      &#x2F;&#x2F;SI是Sales_item的同义词，Sales_item是自定义类</span><br><span class="line"></span><br><span class="line">wages hourly, weekly;       &#x2F;&#x2F;等价于double hourly、weekly;</span><br><span class="line">SI item;                    &#x2F;&#x2F;等价于Sales_item item</span><br><span class="line"></span><br><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr &#x3D; 0;     &#x2F;&#x2F;cstr是指向char的常量指针，而不是一个指向const char的指针，因为pstring基本类型是指针</span><br><span class="line">const pstring *ps;          &#x2F;&#x2F;ps是一个指针，它的对象是指向char的常量指针</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>auto</strong></td>
<td>是一个类型说明符，通过变量的初始值来推断变量的类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">auto i &#x3D; 0, *p &#x3D; &amp;i;    &#x2F;&#x2F;正确：i是整数、p是整形指针</span><br><span class="line">auto sz &#x3D; 0, pi &#x3D; 3.14; &#x2F;&#x2F;错误：sz和pi的类型不一致</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0, &amp;r &#x3D; i;</span><br><span class="line">auto a &#x3D; r;         &#x2F;&#x2F;a是一个整数（r是i的别名，而i是一个整数）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;auto一般会忽略掉顶层const，同时底层const则会保留下来</span><br><span class="line">const int ci &#x3D; i, &amp;cr &#x3D; ci;</span><br><span class="line">auto b &#x3D; ci;        &#x2F;&#x2F;b是一个整数（ci的顶层const特性被忽略掉了）</span><br><span class="line">auto c &#x3D; cr;        &#x2F;&#x2F;c是一个整数（cr是ci的别名，ci本身是一个顶层const）</span><br><span class="line">auto d &#x3D; &amp;i;        &#x2F;&#x2F;d是一个整型指针（整数的地址就是指向整数的指针）</span><br><span class="line">auto e &#x3D; &amp;ci;       &#x2F;&#x2F;e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span><br><span class="line">&#x2F;&#x2F;如果希望推断出的auto类型是一个顶层const，需要明确指出</span><br><span class="line">const auto f &#x3D; ci;  &#x2F;&#x2F;ci的扮演类型是int，f是const int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以将引用的类型设为auto，此时原来的初始化规则仍然适用</span><br><span class="line">auto &amp;g &#x3D; ci;       &#x2F;&#x2F;g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h &#x3D; 42;       &#x2F;&#x2F;错误：不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j &#x3D; 42; &#x2F;&#x2F;正确：可以为常量引用绑定字面值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型</span><br><span class="line">auto k &#x3D; ci, &amp;l &#x3D; i;    &#x2F;&#x2F;k是整数，l是整型引用</span><br><span class="line">auto &amp;m &#x3D; ci, *p &#x3D; &amp;ci; &#x2F;&#x2F;m是对整型常量的引用，p是指向整型常量的指针</span><br><span class="line">&#x2F;&#x2F;错误：i的类型是int而&amp;ci的类型是const int</span><br><span class="line">auto &amp;n &#x3D; i, *p2 &#x3D; &amp;ci;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>decltype</strong></td>
<td>是一个类型说明符，从变量或表达式推断得到类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum &#x3D; x;  &#x2F;&#x2F;sum的类型就是函数f的返回类型</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; 0, &amp;cj &#x3D; ci;</span><br><span class="line">decltype(ci) x &#x3D; 0;     &#x2F;&#x2F;x的类型是const int</span><br><span class="line">decltype(cj) y &#x3D; x;     &#x2F;&#x2F;y的类型是const int&amp;， y绑定到变量x</span><br><span class="line">decltype(cj) z;         &#x2F;&#x2F;错误：z是一个引用，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的结果可以是引用类型</span><br><span class="line">int i &#x3D; 42, *p &#x3D; &amp;i, &amp;r &#x3D; i;</span><br><span class="line">decltype(r + 0) b;      &#x2F;&#x2F;正确：加法的结果是int，因此b是一个（未初始化的）int</span><br><span class="line">decltype(*p) c;         &#x2F;&#x2F;错误：c是int&amp;，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的表达式如果是加上了括号的变量，结果将是引用</span><br><span class="line">decltype((i)) d;        &#x2F;&#x2F;错误：d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;          &#x2F;&#x2F;正确：e是一个（未初始化的）int</span><br></pre></td></tr></table></figure>

<h2 id="6-以类的形式自定义数据结构"><a href="#6-以类的形式自定义数据结构" class="headerlink" title="6.以类的形式自定义数据结构"></a>6.以类的形式自定义数据结构</h2><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类（class）</strong></td>
<td>名字定义在类内部</td>
</tr>
<tr>
<td><strong>struct</strong></td>
<td>是一个关键字，用于定义类</td>
</tr>
<tr>
<td><strong>数据成员（data memeber）</strong></td>
<td>组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化</td>
</tr>
<tr>
<td><strong>类内初始值（in-class initializer）</strong></td>
<td>在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内</td>
</tr>
<tr>
<td><strong>头文件保护符（header guard）</strong></td>
<td>使用预处理变量以防止头文件被某个文件重复包含</td>
</tr>
<tr>
<td><strong>预处理变量（preprocessor variable）</strong></td>
<td>由预处理管理的变量。在程序编译之前，预处理器负责将程序中的预处变量替换成它的真实值</td>
</tr>
<tr>
<td><strong>预处理器（preprocessor）</strong></td>
<td>在C++编译过程中执行的一段程序</td>
</tr>
<tr>
<td><strong>#define</strong></td>
<td>是一条预处理指令，用于定义一个预处理变量</td>
</tr>
<tr>
<td><strong>#endif</strong></td>
<td>是一条预处理指令，用于结束一个#ifdef或#ifndef区域</td>
</tr>
<tr>
<td><strong>#ifdef</strong></td>
<td>是一条预处理指令，用于判断给定的变量是否已经定义</td>
</tr>
<tr>
<td><strong>ifndef</strong></td>
<td>是一条预处理指令，用于判断给定的变量是否尚未定义</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类</span><br><span class="line">struct Sales_data&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold &#x3D; 0;</span><br><span class="line">    double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;头文件保护符</span><br><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold &#x3D; 0;</span><br><span class="line">    double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/31/C-Primer-Glossary-1/" data-id="ck8g34j3u0000qouw688y70t1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/03/31/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/31/C-Primer-Glossary-1/">C-Primer-Glossary-1</a>
          </li>
        
          <li>
            <a href="/2020/03/31/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>