<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C-Primer术语表5-函数 | 游戏还是生活</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。 1.函数基础   术语 说明    函数（function） 可调用的计算单元   函数体（function body） 是一个块，用于定义函数所执行的操作   ()运算符（()operator） 调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）   对象生命周期（o">
<meta property="og:type" content="article">
<meta property="og:title" content="C-Primer术语表5-函数">
<meta property="og:url" content="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="游戏还是生活">
<meta property="og:description" content="本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。 1.函数基础   术语 说明    函数（function） 可调用的计算单元   函数体（function body） 是一个块，用于定义函数所执行的操作   ()运算符（()operator） 调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）   对象生命周期（o">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-01T14:56:17.615Z">
<meta property="article:modified_time" content="2020-04-01T14:57:01.427Z">
<meta property="article:author" content="Oliver">
<meta property="article:tag" content="游戏，编程，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="游戏还是生活" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">游戏还是生活</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当然是全都要</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://oliverbvb.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C-Primer术语表5-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2020-04-01T14:56:17.615Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C-Primer术语表5-函数
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文整理记录《C++ Primer》第五版书中章节后的术语表，并添加部分代码示例。</p>
<h1 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1.函数基础"></a>1.函数基础</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数（function）</strong></td>
<td>可调用的计算单元</td>
</tr>
<tr>
<td><strong>函数体（function body）</strong></td>
<td>是一个块，用于定义函数所执行的操作</td>
</tr>
<tr>
<td><strong>()运算符（()operator）</strong></td>
<td>调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）</td>
</tr>
<tr>
<td><strong>对象生命周期（object lifetime）</strong></td>
<td>每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象</td>
</tr>
<tr>
<td><strong>局部变量（local variable）</strong></td>
<td>定义在块中的变量</td>
</tr>
<tr>
<td><strong>隐藏名字（hidden name）</strong></td>
<td>某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体</td>
</tr>
<tr>
<td><strong>自动对象（automatic object）</strong></td>
<td>仅存在于函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象：当到达了定义所在的块的末尾时，销毁该对象</td>
</tr>
<tr>
<td><strong>局部静态对象（local static object）</strong></td>
<td>它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁</td>
</tr>
<tr>
<td><strong>函数原型（function prototype）</strong></td>
<td>函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型</td>
</tr>
<tr>
<td><strong>分离式编译（separate compliation）</strong></td>
<td>把一个程序分割成多个独立源文件的能力</td>
</tr>
<tr>
<td><strong>链接（link）</strong></td>
<td>是一个编译过程，负责把若干对象文件链接起来形成可执行程序</td>
</tr>
<tr>
<td><strong>可执行文件（executable file）</strong></td>
<td>是操作系统能够执行的文件，包含着与程序有关的代码</td>
</tr>
<tr>
<td><strong>对象文件（object file）</strong></td>
<td>编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件</td>
</tr>
<tr>
<td><strong>对象代码（object code）</strong></td>
<td>编译器将我们的源代码转换成对象代码格式</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数的形参列表</span><br><span class="line">void f1()&#123; &#x2F;*...*&#x2F; &#125;        &#x2F;&#x2F;隐式地定义空形参列表</span><br><span class="line">void f2(void)&#123; &#x2F;*...*&#x2F; &#125;    &#x2F;&#x2F;显式地定义空形参列表</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部静态对象</span><br><span class="line">size_t count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    static size_t ctr &#x3D; 0;      &#x2F;&#x2F;调用结束后，这个值仍然有效</span><br><span class="line">    return ++ctr;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;输出从1到10的数字</span><br><span class="line">    for(size_t i &#x3D; 0; i !&#x3D; 10; ++i)</span><br><span class="line">        cout &lt;&lt; count_calls() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2.参数传递"></a>2.参数传递</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>形参（parameter）</strong></td>
<td>在函数的形参列表中声明的局部变量。用实参初始化形参。</td>
</tr>
<tr>
<td><strong>实参（argument）</strong></td>
<td>函数调用时提供的值，用于初始化函数的形参</td>
</tr>
<tr>
<td><strong>引用传递（pass by reference）</strong></td>
<td>描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上</td>
</tr>
<tr>
<td><strong>值传递（pass by value）</strong></td>
<td>描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本</td>
</tr>
<tr>
<td><strong>传引用调用（call by reference）</strong></td>
<td>参见引用传递</td>
</tr>
<tr>
<td><strong>传值调用（call by value）</strong></td>
<td>参见值传递</td>
</tr>
<tr>
<td><strong>initializer_list</strong></td>
<td>是一个标准类，表示的是一个组花括号包围的类型相同的对象，对象之间以逗号隔开</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针形参</span><br><span class="line">void reset(int *ip)</span><br><span class="line">&#123;</span><br><span class="line">    *ip &#x3D; 0;    &#x2F;&#x2F;改变指针ip所指对象的值</span><br><span class="line">    ip &#x3D; 0;     &#x2F;&#x2F;只改变了ip的局部拷贝，实参未被改变</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const形参</span><br><span class="line">void fcn(const int i)&#123;&#x2F;* fcn能够读取i，但是不能向i写值 *&#x2F;&#125;  &#x2F;&#x2F;既可以传入const int也可以传入int</span><br><span class="line">void fcn(int i)&#123;&#125;   &#x2F;&#x2F;错误：重复定义了fcn(int)</span><br><span class="line"></span><br><span class="line">&#x2F;* 数组形参 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尽管形式不同，但这三个print函数是等价的</span><br><span class="line">&#x2F;&#x2F;每个函数都有一个const int*类型的形参</span><br><span class="line">void print(const int*);</span><br><span class="line">void print(const int[]);    &#x2F;&#x2F;可以看出来，函数的意图是作用于一个数组</span><br><span class="line">void print(const int[10]);  &#x2F;&#x2F;这里的维度表示我们期望数组含有多少元素，实际不一定</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多维数组</span><br><span class="line">&#x2F;&#x2F;matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span><br><span class="line">void print(int (*matrix)[10], int rowSize)&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;等价定义</span><br><span class="line">void print(int matrix[][10], int rowSize)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 可变形参 *&#x2F;</span><br><span class="line"></span><br><span class="line">void error_msg(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto beg &#x3D; il.begin(); beg !&#x3D; il.end(); ++beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">&#x2F;&#x2F;expected和actual是string对象</span><br><span class="line">if(expected !&#x3D; actual)</span><br><span class="line">    error_msg(&#123;&quot;funxtionX&quot;, expected, actual&#125;);</span><br><span class="line">else</span><br><span class="line">    error_msg(&#123;&quot;functionX&quot;, &quot;okay&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="3-返回类型"><a href="#3-返回类型" class="headerlink" title="3.返回类型"></a>3.返回类型</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回类型（return type）</strong></td>
<td>是函数声明的一部分，用于指定函数返回值的类型</td>
</tr>
<tr>
<td><strong>递归函数（recursive function）</strong></td>
<td>直接或间接调用自身的函数</td>
</tr>
<tr>
<td><strong>递归循环（recursion loop）</strong></td>
<td>描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程</td>
</tr>
<tr>
<td><strong>尾置返回类型（trailing return type）</strong></td>
<td>把参数列表后面指定的返回类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不要返回局部对象的引用或指针，因为函数完成后，它所占用的存储空间也随之被释放掉</span><br><span class="line">&#x2F;&#x2F;严重错误：这个函数试图返回局部对象的引用</span><br><span class="line">const string &amp;manip()</span><br><span class="line">&#123;</span><br><span class="line">    string ret;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以某种方式改变一下ret</span><br><span class="line">    if(!ret.empty())</span><br><span class="line">        return ret;         &#x2F;&#x2F;错误：返回局部对象的引用</span><br><span class="line">    else</span><br><span class="line">        return &quot;Empty&quot;;     &#x2F;&#x2F;错误：&quot;Empty&quot;是一个局部临时量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用一个返回引用的函数得到左值，其他返回类型得到右值</span><br><span class="line">char &amp;get_val(string &amp;str, string::size_type ix)</span><br><span class="line">&#123;</span><br><span class="line">    return str[ix];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s(&quot;a value&quot;);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    get_val(s, 0) &#x3D; &#39;A&#39;;        &#x2F;&#x2F;将s[0]的值改为A</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列表初始化返回值</span><br><span class="line">vector&lt;string&gt; process()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    &#x2F;&#x2F;expected和actual是string对象</span><br><span class="line">    if(expected.empty())</span><br><span class="line">        return &#123;&#125;;              &#x2F;&#x2F;返回一个空vector对象</span><br><span class="line">    else if(expected &#x3D;&#x3D; actual)</span><br><span class="line">        return &#123;&quot;functionX&quot;, &quot;okay&quot;&#125;;   &#x2F;&#x2F;返回列表初始化的vector对象</span><br><span class="line">    else</span><br><span class="line">        return &#123;&quot;functionX&quot;, expected, actual&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用尾置返回类型</span><br><span class="line">&#x2F;&#x2F;func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用decltype</span><br><span class="line">int odd[] &#x3D; &#123;1, 3, 5, 7, 9&#125;;</span><br><span class="line">int even[] &#x3D; &#123;0, 2, 4, 6, 8&#125;;</span><br><span class="line">&#x2F;&#x2F;返回一个指针，该指针指向含有5个整数的数组</span><br><span class="line">decltype(odd) *arrPtr(int i)</span><br><span class="line">&#123;</span><br><span class="line">    return (i % 2) ? &amp;odd : &amp;even;  &#x2F;&#x2F;返回一个指向数组的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4.函数重载"></a>4.函数重载</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>重载函数（overloaded function）</strong></td>
<td>函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别</td>
</tr>
<tr>
<td><strong>函数匹配（function matching）</strong></td>
<td>编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较</td>
</tr>
<tr>
<td><strong>重载确定（overload resolution）</strong></td>
<td>参见函数匹配</td>
</tr>
<tr>
<td><strong>最佳匹配（best match）</strong></td>
<td>从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差</td>
</tr>
<tr>
<td><strong>无匹配（no match）</strong></td>
<td>是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配</td>
</tr>
<tr>
<td><strong>二义性调用（ambiguous call）</strong></td>
<td>是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</td>
</tr>
<tr>
<td><strong>候选函数（candidate function）</strong></td>
<td>解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内</td>
</tr>
<tr>
<td><strong>可行函数（viable function）</strong></td>
<td>是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(const Account&amp;);      &#x2F;&#x2F;根据Account查找记录</span><br><span class="line">Record lookup(const Phone&amp;);        &#x2F;&#x2F;根据Phone查找记录</span><br><span class="line">Record lookup(const Name&amp;);         &#x2F;&#x2F;根据Name查找记录</span><br><span class="line">Account acct;</span><br><span class="line">Phone phone;</span><br><span class="line">Record r1 &#x3D; lookup(acct);</span><br><span class="line">Record r2 &#x3D; lookup(phone);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</span><br><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(const Phone);     &#x2F;&#x2F;重复声明了</span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);    &#x2F;&#x2F;重复声明</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果形参是某种类型的指针或引用，则通过区分其指向的常量对象还是非常量对象可以实现函数重载，此时的const是底层的</span><br><span class="line">Record lookup(Account&amp;);        &#x2F;&#x2F;函数作用于Account的引用</span><br><span class="line">Record lookup(const Account&amp;);  &#x2F;&#x2F;新函数，作用于常量引用</span><br><span class="line">Record lookup(Account*);        &#x2F;&#x2F;新函数，作用于指向Account的指针</span><br><span class="line">Record lookup(const Account*);  &#x2F;&#x2F;新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure>

<h1 id="5-默认实参、内联函数和预处理宏"><a href="#5-默认实参、内联函数和预处理宏" class="headerlink" title="5.默认实参、内联函数和预处理宏"></a>5.默认实参、内联函数和预处理宏</h1><table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认实参（default argument）</strong></td>
<td>当调用缺少了某个实参时，为该实参指定的默认值</td>
</tr>
<tr>
<td><strong>内联函数（inline function）</strong></td>
<td>请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销</td>
</tr>
<tr>
<td><strong>constexpr</strong></td>
<td>可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数</td>
</tr>
<tr>
<td><strong>预处理宏（preprocessor marco）</strong></td>
<td>类似于内联函数的一种预处理功能。除了assert之外，现在C++程序很少再使用预处理宏</td>
</tr>
<tr>
<td><strong>Assert</strong></td>
<td>是一个预处理宏，作用于一条表示条件的表达式。当未定义预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条错误信息并终止当前程序的执行</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认实参</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39; &#39;);</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39;*&#39;);      &#x2F;&#x2F;错误：重复声明</span><br><span class="line">string screen(sz &#x3D; 24, sz &#x3D; 80. char);  &#x2F;&#x2F;正确：添加默认实参</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内联版本：寻找两个string对象中较短的那个</span><br><span class="line">inline const string &amp;</span><br><span class="line">shorterString(const string &amp;s1, const string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">    return s1.size() &lt;&#x3D; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constexpr函数，函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句</span><br><span class="line">constexpr int new_sz() &#123;return 42;&#125;</span><br><span class="line">constexpr int foo &#x3D; new_sz();   &#x2F;&#x2F;正确：foo是一个常量表达式</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://oliverbvb.github.io/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/" data-id="ck8hgey210003zguw9k9i8kwz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C-Primer术语表4-语句</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A85-%E5%87%BD%E6%95%B0/">C-Primer术语表5-函数</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A84-%E8%AF%AD%E5%8F%A5/">C-Primer术语表4-语句</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A83-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C-Primer术语表3-表达式</a>
          </li>
        
          <li>
            <a href="/2020/04/01/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A82-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">C-Primer术语表2-字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/03/31/C-Primer%E6%9C%AF%E8%AF%AD%E8%A1%A81-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">C-Primer术语表1-变量和基本类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Oliver<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>